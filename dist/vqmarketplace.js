/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/app.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/app-tenant/hooks/index.ts":
/*!***************************************!*\
  !*** ./src/app-tenant/hooks/index.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const tenantModelsProvider = __webpack_require__(/*! ../tenantModelsProvider */ \"./src/app-tenant/tenantModelsProvider.ts\");\nconst init = (app) => {\n    /**\n     * Those hooks need to be secured with basic authentification!\n     * Example request:\n     * {\n            \"id\": \"ev_2smoc99sQkEif5cbM3\",\n            \"occurred_at\": 1519165748,\n            \"source\": \"admin_console\",\n            \"user\": \"adrian@vq-labs.com\",\n            \"object\": \"event\",\n            \"api_version\": \"v2\",\n            \"content\": {\n                \"subscription\": {\n                    \"id\": \"2smoc99sQkEif3gbLy\",\n                    \"customer_id\": \"B4bhYdQjZWfD5M3Z\",\n                    \"plan_id\": \"starter\",\n                    \"plan_quantity\": 1,\n                    \"plan_unit_price\": 0,\n                    \"billing_period\": 1,\n                    \"billing_period_unit\": \"month\",\n                    \"plan_free_quantity\": 0,\n                    \"status\": \"active\",\n                    \"current_term_start\": 1519165748,\n                    \"current_term_end\": 1521584948,\n                    \"next_billing_at\": 1521584948,\n                    \"created_at\": 1519165748,\n                    \"started_at\": 1519165748,\n                    \"activated_at\": 1519165748,\n                    \"updated_at\": 1519165748,\n                    \"has_scheduled_changes\": false,\n                    \"resource_version\": 1519165748526,\n                    \"deleted\": false,\n                    \"object\": \"subscription\",\n                    \"currency_code\": \"EUR\",\n                    \"due_invoices_count\": 0,\n                    \"mrr\": 0\n                },\n                \"customer\": {\n                    \"id\": \"B4bhYdQjZWfD5M3Z\",\n                    \"first_name\": \"Adrian\",\n                    \"last_name\": \"Barwicki\",\n                    \"email\": \"adrian+rentals@vq-labs.com\",\n                    \"auto_collection\": \"on\",\n                    \"net_term_days\": 0,\n                    \"allow_direct_debit\": false,\n                    \"created_at\": 1518557059,\n                    \"taxability\": \"taxable\",\n                    \"updated_at\": 1519165586,\n                    \"locale\": \"en-GB\",\n                    \"resource_version\": 1519165586847,\n                    \"deleted\": false,\n                    \"object\": \"customer\",\n                    \"card_status\": \"valid\",\n                    \"primary_payment_source_id\": \"pm_1mk51UzQkEhz1dbZZ\",\n                    \"payment_method\": {\n                        \"object\": \"payment_method\",\n                        \"type\": \"card\",\n                        \"reference_id\": \"cus_CMSUTx3xrQNCTn/card_1BxjZ5JzBaRgxnTAyY3AIW5F\",\n                        \"gateway\": \"stripe\",\n                        \"gateway_account_id\": \"gw_1mkVvwZQYP8JAn2Td1\",\n                        \"status\": \"valid\"\n                    },\n                    \"promotional_credits\": 0,\n                    \"refundable_credits\": 0,\n                    \"excess_payments\": 0,\n                    \"unbilled_charges\": 0,\n                    \"preferred_currency_code\": \"EUR\",\n                    \"meta_data\": {\n                        \"tenantId\": \"rentkitchen\",\n                        \"marketplaceUrl\": \"https://rentkitchen.vqmarketplace.com\",\n                        \"marketplaceType\": \"services\",\n                        \"country\": \"DE\"\n                    }\n                },\n                \"card\": {\n                    \"status\": \"valid\",\n                    \"gateway\": \"stripe\",\n                    \"gateway_account_id\": \"gw_1mkVvwZQYP8JAn2Td1\",\n                    \"first_name\": \"Adrian\",\n                    \"last_name\": \"Barwicki\",\n                    \"iin\": \"538734\",\n                    \"last4\": \"0549\",\n                    \"card_type\": \"mastercard\",\n                    \"funding_type\": \"credit\",\n                    \"expiry_month\": 1,\n                    \"expiry_year\": 2021,\n                    \"issuing_country\": \"DE\",\n                    \"billing_country\": \"DE\",\n                    \"ip_address\": \"172.58.91.136\",\n                    \"object\": \"card\",\n                    \"masked_number\": \"************0549\",\n                    \"customer_id\": \"B4bhYdQjZWfD5M3Z\",\n                    \"payment_source_id\": \"pm_1mk51UzQkEhz1dbZZ\"\n                },\n                \"invoice\": {\n                    \"id\": \"1\",\n                    \"customer_id\": \"B4bhYdQjZWfD5M3Z\",\n                    \"subscription_id\": \"2smoc99sQkEif3gbLy\",\n                    \"recurring\": true,\n                    \"status\": \"paid\",\n                    \"price_type\": \"tax_exclusive\",\n                    \"date\": 1519165748,\n                    \"due_date\": 1519165748,\n                    \"net_term_days\": 0,\n                    \"exchange_rate\": 1.0,\n                    \"total\": 0,\n                    \"amount_paid\": 0,\n                    \"amount_adjusted\": 0,\n                    \"write_off_amount\": 0,\n                    \"credits_applied\": 0,\n                    \"amount_due\": 0,\n                    \"paid_at\": 1519165748,\n                    \"updated_at\": 1519165748,\n                    \"resource_version\": 1519165748515,\n                    \"deleted\": false,\n                    \"object\": \"invoice\",\n                    \"first_invoice\": true,\n                    \"amount_to_collect\": 0,\n                    \"round_off_amount\": 0,\n                    \"new_sales_amount\": 0,\n                    \"has_advance_charges\": false,\n                    \"currency_code\": \"EUR\",\n                    \"base_currency_code\": \"EUR\",\n                    \"tax\": 0,\n                    \"line_items\": [{\n                        \"id\": \"li_2smoc99sQkEif48bM0\",\n                        \"date_from\": 1519165748,\n                        \"date_to\": 1521584948,\n                        \"unit_amount\": 0,\n                        \"quantity\": 1,\n                        \"is_taxed\": false,\n                        \"tax_amount\": 0,\n                        \"object\": \"line_item\",\n                        \"subscription_id\": \"2smoc99sQkEif3gbLy\",\n                        \"amount\": 0,\n                        \"description\": \"Starter\",\n                        \"entity_type\": \"plan\",\n                        \"entity_id\": \"starter\",\n                        \"tax_exempt_reason\": \"tax_not_configured\",\n                        \"discount_amount\": 0,\n                        \"item_level_discount_amount\": 0\n                    }],\n                    \"sub_total\": 0,\n                    \"linked_payments\": [],\n                    \"applied_credits\": [],\n                    \"adjustment_credit_notes\": [],\n                    \"issued_credit_notes\": [],\n                    \"linked_orders\": [],\n                    \"billing_address\": {\n                        \"first_name\": \"Adrian\",\n                        \"last_name\": \"Barwicki\",\n                        \"validation_status\": \"not_validated\",\n                        \"object\": \"billing_address\"\n                    }\n                }\n            },\n            \"event_type\": \"subscription_created\",\n            \"webhook_status\": \"not_configured\"\n        }\n     */\n    const getTenantForChargebeeEvent = (req, res, next) => {\n        const chargebeeEvent = req.body;\n        const tenantEmail = chargebeeEvent.content.customer.email;\n        tenantModelsProvider\n            .getTenant({\n            email: tenantEmail\n        }, (err, tenantRef, tenantModels) => {\n            if (err) {\n                return res.status(400).send(err);\n            }\n            req.tenantModels = tenantModels;\n            req.tenantRef = tenantRef;\n            return next();\n        });\n    };\n    app.post(\"/api/hooks/tenant/subscription\", getTenantForChargebeeEvent, (req, res) => {\n        const chargebeeEvent = req.body;\n        const tenantRef = req.tenantRef;\n        if ([\n            \"subscription_created\",\n            \"subscription_cancelled\",\n            \"subscription_changed\"\n        ].indexOf(chargebeeEvent.event_type) === -1) {\n            return res.send({ ok: true, desc: \"This webhook has not been implemented.\" });\n        }\n        // chargebee customer ID update (in case not present)\n        tenantRef.chargebeeCustomerId = chargebeeEvent.content.subscription.customer_id;\n        /**\n         * Subscription created - we update tenant plan giving him new rights for use of the software\n         */\n        if (chargebeeEvent.event_type === \"subscription_created\") {\n            tenantRef.chargebeeSubscriptionId = chargebeeEvent.content.subscription.id;\n            if (chargebeeEvent.content.subscription.status === \"active\") {\n                tenantRef.activePlan = chargebeeEvent.content.subscription.plan_id;\n            }\n        }\n        /**\n         * Subscription cancelled - we update tenant plan stripping him from rights for use of the software or degrading him to the lowest sub. level.\n         */\n        if (chargebeeEvent.event_type === \"subscription_cancelled\") {\n            tenantRef.chargebeeSubscriptionId = undefined;\n            tenantRef.activePlan = \"starter\";\n        }\n        /**\n        * Subscription changed - we update tenant plan.\n        */\n        if (chargebeeEvent.event_type === \"subscription_changed\") {\n            tenantRef.chargebeeSubscriptionId = chargebeeEvent.content.subscription.id;\n            if (chargebeeEvent.content.subscription.status === \"active\") {\n                tenantRef.activePlan = chargebeeEvent.content.subscription.plan_id;\n            }\n        }\n        return tenantRef\n            .save()\n            .then(() => res.send({\n            ok: true\n        }))\n            .catch((err) => res.send(err));\n    });\n};\nmodule.exports = {\n    init\n};\n\n\n//# sourceURL=webpack:///./src/app-tenant/hooks/index.ts?");

/***/ }),

/***/ "./src/app-tenant/index.ts":
/*!*********************************!*\
  !*** ./src/app-tenant/index.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(__dirname) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst async = __webpack_require__(/*! async */ \"async\");\nconst db = __webpack_require__(/*! ../app/models/models */ \"./src/app/models/models.ts\");\nconst utils = __webpack_require__(/*! ../app/utils */ \"./src/app/utils/index.js\");\nconst cryptoService = __webpack_require__(/*! ../app/services/cryptoService */ \"./src/app/services/cryptoService.js\");\nconst subscriptionService = __webpack_require__(/*! ../app/services/subscriptionService */ \"./src/app/services/subscriptionService.js\");\nconst emailService = __webpack_require__(/*! ../app/services/emailService.js */ \"./src/app/services/emailService.js\");\nconst emailTemplateGenerator = __webpack_require__(/*! ../app/services/emailTemplateGenerator.js */ \"./src/app/services/emailTemplateGenerator.js\");\nconst hooks = __webpack_require__(/*! ./hooks */ \"./src/app-tenant/hooks/index.ts\");\nconst request = __webpack_require__(/*! request */ \"request\");\nconst tenantModelsProvider = __webpack_require__(/*! ./tenantModelsProvider */ \"./src/app-tenant/tenantModelsProvider.ts\");\nconst service = __webpack_require__(/*! ./service */ \"./src/app-tenant/service.ts\");\nconst initRoutes = (app, express) => {\n    app.use(express.static(__dirname + \"/public\"));\n    hooks.init(app, express);\n    app.get(\"/cb/stripe\", (req, res) => {\n        const stripeAuthCode = req.query.code;\n        let tenantId, userId;\n        let appConfig;\n        try {\n            const splitted = req.query.state.split(\"@\");\n            tenantId = splitted[0];\n            userId = splitted[1];\n        }\n        catch (err) {\n            return res.status(400).send(\"Missing state param\");\n        }\n        const models = db.get(tenantId);\n        if (!models) {\n            res\n                .status(400)\n                .send({\n                code: \"TENANT_NOT_FOUND\"\n            });\n            return;\n        }\n        async.waterfall([\n            cb => {\n                models\n                    .appConfig\n                    .findAll()\n                    .then(rAppConfig => {\n                    appConfig = rAppConfig;\n                    cb();\n                }, cb);\n            },\n            cb => {\n                const stripePublicKey = appConfig.find(_ => _.fieldKey === \"STRIPE_PUBLIC_KEY\" && _.fieldValue);\n                const stripePrivateKey = appConfig.find(_ => _.fieldKey === \"STRIPE_PRIVATE_KEY\" && _.fieldValue);\n                if (!stripePublicKey || !stripePrivateKey) {\n                    cb({\n                        code: \"PAYMENTS_NOT_CONFIGURED\"\n                    });\n                    return;\n                }\n                request\n                    .post({\n                    url: \"https://connect.stripe.com/oauth/token\",\n                    form: {\n                        grant_type: \"authorization_code\",\n                        code: stripeAuthCode,\n                        client_id: stripePublicKey.fieldValue,\n                        client_secret: stripePrivateKey.fieldValue\n                    }\n                }, (err, response, body) => {\n                    if (err) {\n                        cb(err);\n                        return;\n                    }\n                    const stripeAccountAccess = JSON.parse(body);\n                    if (stripeAccountAccess.error) {\n                        cb({\n                            code: \"PAYMENTS_ERROR\",\n                            err: stripeAccountAccess\n                        });\n                        return;\n                    }\n                    cb(undefined, stripeAccountAccess);\n                });\n            },\n            (stripeAccountAccess, cb) => {\n                async\n                    .parallel([\n                    cb => models\n                        .userPaymentAccount\n                        .findOne({\n                        where: {\n                            $and: [\n                                {\n                                    networkId: \"stripe\"\n                                }, {\n                                    userId: userId\n                                }\n                            ]\n                        }\n                    })\n                        .then(paymentAccount => {\n                        if (paymentAccount) {\n                            return cb();\n                        }\n                        models\n                            .userPaymentAccount\n                            .create({\n                            userId,\n                            accountId: stripeAccountAccess.stripe_user_id,\n                            networkId: \"stripe\"\n                        }, () => cb(), cb);\n                    }, cb)\n                ], cb);\n            }\n        ], err => {\n            if (err) {\n                return res.status(400).send(err);\n            }\n            res.redirect(`https://${models.tenantId}.vqmarketplace.com/app/account/payments`);\n        });\n    });\n    app.get(\"/api/tenant\", (req, res) => {\n        tenantModelsProvider.getModels((err, tenantModels) => {\n            if (err) {\n                return res.status(400).send(err);\n            }\n            tenantModels\n                .tenant\n                .findAll({\n                where: req.query\n            })\n                .then((rTenants) => {\n                const processedTenants = rTenants\n                    .map(_ => {\n                    return {\n                        tenantId: _.tenantId,\n                        stripePublicKey: _.stripeAccount ? _.stripeAccount.keys.publishable : undefined,\n                    };\n                });\n                res.send(processedTenants);\n            }, err => res.status(400).send(err));\n        });\n    });\n    app.get(\"/api/tenant/:tenantId\", (req, res) => {\n        tenantModelsProvider.getModels((err, tenantModels) => {\n            if (err) {\n                return res.status(400).send(err);\n            }\n            tenantModels.tenant\n                .findOne({\n                where: {\n                    tenantId: req.params.tenantId\n                }\n            })\n                .then((rTenant) => {\n                if (!rTenant) {\n                    return res.status(404).send({\n                        code: \"NOT_FOUND\"\n                    });\n                }\n                return res.send({\n                    id: rTenant.id,\n                    tenantId: rTenant.tenantId,\n                    emailVerified: rTenant.emailVerified,\n                    marketplaceName: rTenant.marketplaceName,\n                    marketplaceType: rTenant.marketplaceType,\n                    status: rTenant.status\n                });\n            }, err => res.status(400).send(err));\n        });\n    });\n    /* Trial Form User Registration Steps */\n    app.post(\"/api/trial-registration/step-1\", (req, res) => {\n        const tenant = req.body;\n        service.createNewTenant({\n            email: tenant.email,\n            source: tenant.source\n        }, (err, rTenant) => {\n            if (err) {\n                return res.status(400).send(err);\n            }\n            rTenant.verificationKey = cryptoService\n                .encodeObj(rTenant.apiKey);\n            var body = \"<p style=\\\"color: #374550;\\\">You can copy and paste the verification code below or click the link to continue with the registration process:</p><br><br>\" +\n                \"<span style=\\\"color: #374550;\\\"><b>Verification Code: </b>\" + rTenant.verificationKey + \"</span><br><br>\" +\n                \"<span style=\\\"color: #374550;\\\"><b><a href=\\\"\" + process.env.WEB_URL + \"/get-started?verificationCode=\" + encodeURIComponent(rTenant.verificationKey) + \"\\\">Click here if you are unable to paste the code</a></b></span>\";\n            emailTemplateGenerator.generateSingleColumnEmail(\"Marketplace Registration\", \"Welcome to VQ-Marketplace\", body, function (html) {\n                emailService.sendTemplateEmail(rTenant.email, \"Welcome to VQ-Marketplace\", html);\n                // we should not send here the API KEY\n                return res.send({\n                    tenant: rTenant\n                });\n            });\n        });\n    });\n    app.post(\"/api/trial-registration/step-2\", (req, res) => {\n        const tenant = req.body;\n        let encryptedToken = tenant.verificationCode;\n        let apiKey;\n        try {\n            encryptedToken = encryptedToken.split(\" \").join(\"+\");\n            apiKey = cryptoService.decodeObj(encryptedToken);\n        }\n        catch (err) {\n            return res.status(400)\n                .send({\n                httpCode: 400,\n                code: \"WRONG_DATA\"\n            });\n        }\n        tenantModelsProvider.getModels((err, tenantModels) => {\n            if (err) {\n                return res.status(400).send(err);\n            }\n            tenantModels\n                .tenant\n                .findOne({\n                where: {\n                    apiKey\n                }\n            })\n                .then(rTenant => {\n                if (!rTenant) {\n                    return res.status(400).send({\n                        httpCode: 400,\n                        code: \"WRONG_DATA\"\n                    });\n                }\n                if (rTenant.emailVerified) {\n                    return res.status(400).send({\n                        httpCode: 400,\n                        code: \"EMAIL_ALREADY_VERIFIED\"\n                    });\n                }\n                return rTenant\n                    .update({\n                    emailVerified: 1\n                })\n                    .then(() => {\n                    res.send({\n                        tenant: rTenant\n                    });\n                }, err => {\n                    res.status(400).send(err);\n                });\n            }, err => res.status(400).send(err));\n        });\n    });\n    app.post(\"/api/trial-registration/step-3\", (req, res) => {\n        const tenant = req.body;\n        tenantModelsProvider.getModels((err, tenantModels) => {\n            if (err) {\n                return res.status(400).send(err);\n            }\n            tenantModels\n                .tenant\n                .update({\n                firstName: tenant.firstName,\n                lastName: tenant.lastName,\n                country: tenant.country\n            }, {\n                where: {\n                    apiKey: tenant.apiKey\n                }\n            })\n                .then(tenant => {\n                return res.send({\n                    tenant: tenant\n                });\n            }, err => res.status(400).send(err));\n        });\n    });\n    /**\n     * It starts the marketplace!\n     * This endpoint is called after:\n     * 1) tenant has been initialized\n     * 2) tenant has confirmed its email\n     *\n     * Here the tenant can give a marketplace.\n     *\n     * Request:\n     * apiKey:YDJkyR6dPdeqtHd05bR3BIqUw3BA8JlM\n     * marketplaceName:Adrian\n     * password:hello\n     * repeatPassword:hello\n     */\n    app.post(\"/api/trial-registration/step-4\", (req, res) => {\n        const tenant = req.body;\n        const apiKey = tenant.apiKey;\n        const marketplaceType = tenant.marketplaceType;\n        const tenantId = utils.stringToSlug(tenant.marketplaceName);\n        if (!tenantId) {\n            return res.status(400)\n                .send({\n                code: \"MARKETPLACE_NAME_WRONG_FORMAT\"\n            });\n        }\n        const reserveredKeywords = [\n            \"innodb\",\n            \"blog\",\n            tenantModelsProvider.rootDbName,\n            \"help\"\n        ];\n        if (reserveredKeywords.indexOf(tenantId) !== -1) {\n            return res.status(400)\n                .send({\n                code: \"MARKETPLACE_NAME_NOT_ALLOWED\"\n            });\n        }\n        let tenantModels;\n        let tenantRef;\n        async.waterfall([\n            cb => {\n                tenantModelsProvider.getModels((err, rTenantModels) => {\n                    if (err) {\n                        return cb(err);\n                    }\n                    tenantModels = rTenantModels;\n                    cb();\n                });\n            },\n            cb => tenantModels\n                .tenant\n                .findOne({\n                where: {\n                    tenantId\n                }\n            })\n                .then(foundTenant => {\n                if (foundTenant) {\n                    return cb({\n                        httpCode: 400,\n                        code: \"MARKETPLACE_NAME_NOT_ALLOWED\"\n                    });\n                }\n                return cb();\n            }, cb),\n            cb => tenantModels\n                .tenant\n                .findOne({\n                where: {\n                    apiKey: tenant.apiKey\n                }\n            })\n                .then(rTenant => {\n                if (!rTenant) {\n                    return setTimeout(() => {\n                        return cb({\n                            httpCode: 400,\n                            code: \"WRONG_API_KEY\"\n                        });\n                    }, 500);\n                }\n                if (!rTenant.emailVerified) {\n                    return cb({\n                        httpCode: 400,\n                        code: \"EMAIL_NOT_VERIFIED\"\n                    });\n                }\n                // Has api key been used?\n                if (rTenant.status !== 0) {\n                    return cb({\n                        httpCode: 400,\n                        code: \"API_KEY_USED\"\n                    });\n                }\n                tenantRef = rTenant;\n                cb();\n            }),\n            cb => {\n                tenantRef.marketplaceName = tenant.marketplaceName;\n                tenantRef.marketplaceType = tenant.marketplaceType;\n                tenantRef.tenantId = tenantId;\n                tenantRef.status = 1;\n                tenantRef\n                    .save()\n                    .then(() => cb(), cb);\n            }\n        ], err => {\n            if (err) {\n                return res.status(err.httpCode).send(err);\n            }\n            const marketplaceUrl = process.env.APP_URL.replace(\"?tenantId?\", tenantRef.tenantId);\n            const configOverwrites = {\n                NAME: tenantRef.marketplaceName,\n                SEO_TITLE: tenantRef.marketplaceName,\n                DOMAIN: marketplaceUrl\n            };\n            if (process.env.CHARGEBEE_SITE && process.env.CHARGEBEE_API_KEY) {\n                subscriptionService.ensureCustomerDataSaved(tenantRef);\n            }\n            // this can last some time, up to one minute, it should be run async\n            service\n                .deployNewMarketplace(tenantId, apiKey, tenant.password, tenant.repeatPassword, marketplaceType, configOverwrites, () => {\n                console.log(\"MARKETPLACE CREATED\");\n                res.send(tenantRef);\n                const body = `<p style=\"color: #374550;\">\n                                Your journey to run an online marketplace has just begun! You can now easily build and manage your online marketplace and at the same time go to market, get your first users and validate your idea.\n                            </p>\n                            <br>\n                            <p style=\"color: #374550;\"><b>Here is your marketplace information</b></p>\n                            <p style=\"color: #374550;\"><b>- Your account's email address:</b> ${tenantRef.email}</p>\n                            <p style=\"color: #374550; margin-bottom: 0;\"><b>- Your marketplace address:</b> <a href=\"${marketplaceUrl}/app\">${marketplaceUrl}/app</a></p>\n                            <p style=\"color: #374550; margin:0;\">This is the public address of your marketplace, the one you should share with your visitors. </p>\n                            <p style=\"color: #374550; margin-bottom: 0;\"><b>- Your marketplace admin panel:</b> <a href=\"${marketplaceUrl}/app/admin\">${marketplaceUrl}/app/admin</a></p>\n                            <p style=\"color: #374550; margin:0;\">This is where you, as the owner, can make changes to your marketplace.</p>\n                            <br>\n                            \n                            <p style=\"color: #374550;\">\n                                Please beware that the marketplace platform is the BETA version which means it is under development based on the feedback we collect from BETA users.\n                                We would be happy if you also gave us feedback so that we can build a platform that meets your expectations. Anyone who gives feedback will be rewarded once VQ-Marketplace goes public.\n                            </p>\n\n                            <p style=\"color: #374550;\">\n                                If you need any help with configuring your marketplace or you want to contact us for a feedback, send us an email to ani@vq-labs.com.\n                            </p>\n                            <br>\n                            <p>Cheers,<br>\n                            VQ Labs Team</p>`;\n                emailTemplateGenerator\n                    .generateSingleColumnEmail(\"Marketplace Registration\", \"Welcome to your Marketplace, \" + tenantRef.firstName, body, html => {\n                    emailService.sendTemplateEmail(tenantRef.email, `Welcome to your Marketplace, ${tenantRef.firstName}`, html);\n                });\n            });\n        });\n    });\n    app.post(\"/api/trial-registration/getTenantStatus\", (req, res) => {\n        const apiKey = req.body.apiKey;\n        tenantModelsProvider.getModels((err, tenantModels) => {\n            if (err) {\n                return res.status(400).send(err);\n            }\n            tenantModels\n                .tenant\n                .findOne({\n                where: {\n                    apiKey: apiKey\n                },\n                attributes: [\n                    \"status\",\n                    \"tenantId\"\n                ]\n            })\n                .then(tenant => {\n                return res.status(200).send({\n                    tenant\n                });\n            }, err => res.status(400).send(err));\n        });\n    });\n    app.post(\"/api/trial-registration/resendVerificationCode\", (req, res) => {\n        const apiKey = req.body.apiKey;\n        tenantModelsProvider.getModels((err, tenantModels) => {\n            if (err) {\n                return res.status(400).send(err);\n            }\n            tenantModels\n                .tenant\n                .findOne({\n                where: {\n                    apiKey: apiKey\n                }\n            })\n                .then(rTenant => {\n                if (!rTenant) {\n                    return res.status(400)\n                        .send({\n                        httpCode: 400,\n                        code: \"WRONG_DATA\"\n                    });\n                }\n                else if (rTenant.emailVerified) {\n                    return res.status(400).json({\n                        httpCode: 400,\n                        code: \"EMAIL_ALREADY_VERIFIED\",\n                        tenantStatus: rTenant.status\n                    });\n                }\n                else {\n                    rTenant.verificationKey = cryptoService\n                        .encodeObj(rTenant.apiKey);\n                    var body = \"<p>You can copy and paste the verification code below or click the link to continue with the registration process:</p><br><br>\" +\n                        \"<b>Verification Code: </b>\" + rTenant.verificationKey + \"<br><br>\" +\n                        \"<b><a href=\\\"\" + process.env.WEB_URL + \"/get-started?verificationCode=\" + encodeURIComponent(rTenant.verificationKey).replace(/%20/g, \"+\") + \"\\\">Click here if you are unable to paste the code</a></b>\";\n                    emailTemplateGenerator.generateSingleColumnEmail(\"Marketplace Registration\", \"Welcome to VQ-Marketplace\", body, function (html) {\n                        emailService.sendTemplateEmail(rTenant.email, \"Your VQ-Marketplace Validation Code\", html);\n                        return res.send({\n                            tenant: rTenant\n                        });\n                    });\n                }\n            }, err => res.status(400).send(err));\n        });\n    });\n};\nmodule.exports = {\n    getModels: tenantModelsProvider.getModels,\n    initRoutes\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, \"/\"))\n\n//# sourceURL=webpack:///./src/app-tenant/index.ts?");

/***/ }),

/***/ "./src/app-tenant/models/index.js":
/*!****************************************!*\
  !*** ./src/app-tenant/models/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(__dirname) {const async = __webpack_require__(/*! async */ \"async\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst mysql = __webpack_require__(/*! mysql2 */ \"mysql2\");\nconst Sequelize = __webpack_require__(/*! sequelize */ \"sequelize\");\n\nconst tenantConnections = {};\n\nconst create = (tenantId, cb) => {\n  if (tenantConnections[tenantId]) {\n    throw new Error(`Tenant ${tenantId} already initialised!`);\n  }\n\n  console.log(`Creating ${tenantId}`);\n\n  var isNewDatabase = false;\n\n  async.waterfall([cb => {\n    const connection = mysql.createConnection({\n      host: process.env.VQ_DB_HOST,\n      user: process.env.VQ_DB_USER,\n      password: process.env.VQ_DB_PASSWORD\n    });\n\n    connection.connect();\n\n    connection.query(\"CREATE DATABASE ?? CHARACTER SET utf8 COLLATE utf8_general_ci;\", [tenantId], (err, results, fields) => {\n      if (err) {\n        if (err.code === \"ER_DB_CREATE_EXISTS\") {\n          return cb();\n        }\n\n        return cb(err);\n      }\n\n      isNewDatabase = true;\n\n      cb();\n    });\n\n    connection.end();\n  }, cb => {\n    const db = {};\n    const sequelize = new Sequelize(tenantId, process.env.VQ_DB_USER, process.env.VQ_DB_PASSWORD, {\n      host: process.env.VQ_DB_HOST,\n      logging: false,\n      dialect: \"mysql\",\n      pool: {\n        max: 5,\n        min: 0,\n        idle: 10000\n      }\n    });\n\n    fs.readdirSync(__dirname).filter(file => {\n      return file.indexOf(\".\") !== 0 && file !== \"index.js\";\n    }).forEach(file => {\n      var model = sequelize.import(path.join(__dirname, file));\n      db[model.name] = model;\n    });\n\n    Object.keys(db).forEach(modelName => {\n      if (\"associate\" in db[modelName]) {\n        db[modelName].associate(db);\n      }\n    });\n\n    db.seq = sequelize;\n    db.Sequelize = Sequelize;\n\n    tenantConnections[tenantId] = db;\n\n    cb();\n  }, cb => {\n    const models = tenantConnections[tenantId];\n\n    models.seq.sync().then(() => {\n      cb();\n    }, cb);\n  }], cb);\n};\n\nconst get = tenantId => {\n  if (tenantConnections[tenantId]) {\n    return tenantConnections[tenantId];\n  }\n\n  throw new Error(`Tenant ${tenantId} does not exists`);\n};\n\nmodule.exports = {\n  create,\n  get\n};\n/* WEBPACK VAR INJECTION */}.call(this, \"/\"))\n\n//# sourceURL=webpack:///./src/app-tenant/models/index.js?");

/***/ }),

/***/ "./src/app-tenant/service.ts":
/*!***********************************!*\
  !*** ./src/app-tenant/service.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst async = __webpack_require__(/*! async */ \"async\");\nconst tenantDb = __webpack_require__(/*! ./models */ \"./src/app-tenant/models/index.js\");\nconst db = __webpack_require__(/*! ../app/models/models */ \"./src/app/models/models.ts\");\n// const workers = require(\"../app/workers\");\nconst randomstring = __webpack_require__(/*! randomstring */ \"randomstring\");\nconst authCtrl = __webpack_require__(/*! ../app/controllers/authCtrl */ \"./src/app/controllers/authCtrl.ts\");\nconst tenantModelsProvider = __webpack_require__(/*! ./tenantModelsProvider */ \"./src/app-tenant/tenantModelsProvider.ts\");\nexports.createNewTenant = (tenant, cb) => {\n    tenantModelsProvider.getModels((err, tenantModels) => {\n        tenantModels\n            .tenant\n            .findOrCreate({\n            where: {\n                email: tenant.email\n            },\n            defaults: {\n                status: tenant.status,\n                tenantId: tenant.tenantId,\n                emailVerified: tenant.emailVerified,\n                apiKey: randomstring.generate(32),\n                source: tenant.source\n            }\n        })\n            .spread((tenant, isNew) => {\n            if (!isNew) {\n                return cb({ code: \"TENANT_EMAIL_TAKEN\", httpCode: 400 });\n            }\n            return cb(undefined, tenant);\n        }, cb);\n    });\n};\nexports.deployNewMarketplace = (tenantId, apiKey, password, repeatPassword, marketplaceType, configOverwrites, cb) => {\n    /**\n     * Intialize the tentant db first!\n     */\n    tenantModelsProvider.getModels(() => {\n        const tenantModels = tenantDb.get(\"vq-marketplace\");\n        let marketplaceModels;\n        let tenantRef;\n        const marketplaceCategories = __webpack_require__(\"./src/example-configs sync recursive ^\\\\.\\\\/.*\\\\/categories\\\\.json$\")(`./${marketplaceType}/categories.json`);\n        const marketplaceConfig = __webpack_require__(\"./src/example-configs sync recursive ^\\\\.\\\\/.*\\\\/config\\\\.json$\")(`./${marketplaceType}/config.json`);\n        if (!marketplaceConfig) {\n            console.log('Marketplace config for %s was not found in example-configs directory', marketplaceType);\n        }\n        Object\n            .keys(configOverwrites)\n            .forEach(configOverwriteKey => {\n            marketplaceConfig[configOverwriteKey] = configOverwrites[configOverwriteKey];\n        });\n        async.waterfall([\n            (cb) => {\n                tenantModels\n                    .tenant\n                    .findOne({\n                    where: {\n                        $and: [\n                            { tenantId },\n                            { apiKey }\n                        ]\n                    }\n                })\n                    .then((rTenantRef) => {\n                    if (!rTenantRef) {\n                        return cb({\n                            code: \"TENANT_NOT_FOUND\",\n                            httpCode: 400\n                        });\n                    }\n                    tenantRef = rTenantRef;\n                    return cb();\n                }, cb);\n            },\n            (cb) => {\n                db.create(tenantId, marketplaceType, err => {\n                    if (err) {\n                        return cb(err);\n                    }\n                    // disabled\n                    // workers.registerWorkers(tenantId);\n                    tenantRef\n                        .update({\n                        status: 2\n                    })\n                        .then(() => cb(), cb);\n                });\n            },\n            (cb) => {\n                marketplaceModels = db.get(tenantId);\n                marketplaceModels\n                    .appConfig\n                    .bulkCreateOrUpdate(Object.keys(marketplaceConfig)\n                    .map(fieldKey => {\n                    return {\n                        fieldKey,\n                        fieldValue: marketplaceConfig[fieldKey]\n                    };\n                }), true, err => {\n                    if (err) {\n                        return cb(err);\n                    }\n                    cb();\n                });\n            },\n            (cb) => {\n                marketplaceModels = db.get(tenantId);\n                marketplaceModels\n                    .appTaskCategory\n                    .bulkCreateOrUpdate(marketplaceCategories, err => {\n                    if (err) {\n                        return cb(err);\n                    }\n                    cb();\n                });\n            },\n            (cb) => {\n                const userData = {\n                    email: tenantRef.email,\n                    firstName: tenantRef.firstName,\n                    lastName: tenantRef.lastName,\n                    userType: 0,\n                    password: password,\n                    props: {}\n                };\n                authCtrl.createNewAccount(marketplaceModels, userData, (err) => cb(err));\n            },\n            (cb) => {\n                tenantRef\n                    .update({\n                    status: 3\n                })\n                    .then(() => {\n                    console.log(\"Success! Created Marketplace, initial config and user account.\");\n                    return cb();\n                }, cb);\n            }\n        ], cb);\n    });\n};\n\n\n//# sourceURL=webpack:///./src/app-tenant/service.ts?");

/***/ }),

/***/ "./src/app-tenant/tenantModelsProvider.ts":
/*!************************************************!*\
  !*** ./src/app-tenant/tenantModelsProvider.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tenantDb = __webpack_require__(/*! ./models */ \"./src/app-tenant/models/index.js\");\nconst rootDbName = \"vq-marketplace\";\nlet models;\nexports.getModels = (cb) => {\n    if (models) {\n        return cb(null, models);\n    }\n    tenantDb.create(rootDbName, err => {\n        if (err) {\n            return cb(err);\n        }\n        models = tenantDb.get(rootDbName);\n        return cb(null, models);\n    });\n};\nconst getTenant = ({ tenantId, email }, cb) => exports.getModels((err, tenantModels) => {\n    if (err) {\n        return cb(err);\n    }\n    const whereObj = {};\n    if (tenantId) {\n        whereObj.tenantId = tenantId;\n    }\n    if (email) {\n        whereObj.email = email;\n    }\n    tenantModels\n        .tenant\n        .findOne({\n        where: whereObj\n    })\n        .then(tenantRef => {\n        if (!tenantRef) {\n            return cb({\n                code: \"TENANT_NOT_FOUND\",\n                httpCode: 400\n            });\n        }\n        cb(undefined, tenantRef, tenantModels);\n    })\n        .catch(cb);\n});\nmodule.exports = {\n    rootDbName,\n    getModels: exports.getModels,\n    getTenant\n};\n\n\n//# sourceURL=webpack:///./src/app-tenant/tenantModelsProvider.ts?");

/***/ }),

/***/ "./src/app.ts":
/*!********************!*\
  !*** ./src/app.ts ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const server = __webpack_require__(/*! ./server.js */ \"./src/server.js\");\nserver.setupApp();\n\n\n//# sourceURL=webpack:///./src/app.ts?");

/***/ }),

/***/ "./src/app/auth/controllers/LoginCtrl.js":
/*!***********************************************!*\
  !*** ./src/app/auth/controllers/LoginCtrl.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var async = __webpack_require__(/*! async */ \"async\");\nvar AuthService = __webpack_require__(/*! ../services/AuthService.js */ \"./src/app/auth/services/AuthService.js\");\n\nconst loginWithPassword = (models, email, password, callback) => {\n  if (!email || !password) {\n    return callback({\n      code: \"INITIAL_PARAMS\"\n    });\n  }\n\n  var User = {},\n      Token;\n\n  if (password) {\n    User.password = AuthService.generateHashSync(password);\n  }\n\n  async.waterfall([callback => {\n    AuthService.getUserIdFromEmail(models, email, (err, rUser) => {\n      if (err) {\n        return callback(err);\n      }\n\n      if (!rUser) {\n        return callback({\n          status: 400,\n          code: \"EMAIL_NOT_FOUND\"\n        });\n      }\n\n      User = rUser.dataValues;\n\n      return callback();\n    });\n  }, callback => {\n    AuthService.checkPassword(models, User.userId, password, (err, checkResult) => {\n      if (err) {\n        return callback(err);\n      }\n\n      if (!checkResult) {\n        return callback({\n          status: 400,\n          code: \"WRONG_PASSWORD\"\n        });\n      }\n\n      return callback();\n    });\n  }, callback => {\n    AuthService.createNewToken(models, User.userId, (err, rToken) => {\n      if (err) {\n        return callback(err);\n      }\n\n      Token = rToken;\n\n      return callback();\n    });\n  }], err => callback(err, Token));\n};\n\nmodule.exports = {\n  loginWithPassword\n};\n\n//# sourceURL=webpack:///./src/app/auth/controllers/LoginCtrl.js?");

/***/ }),

/***/ "./src/app/auth/controllers/SignupCtrl.ts":
/*!************************************************!*\
  !*** ./src/app/auth/controllers/SignupCtrl.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar async = __webpack_require__(/*! async */ \"async\");\nvar AuthService = __webpack_require__(/*! ../services/AuthService.js */ \"./src/app/auth/services/AuthService.js\");\nexports.createLocalAccount = (models, email, password, callback) => {\n    if (!email) {\n        return callback({\n            httpCode: 400,\n            code: \"INITIAL_EMAIL\"\n        });\n    }\n    if (!password) {\n        return callback({\n            httpCode: 400,\n            code: \"INITIAL_PASSWORD\"\n        });\n    }\n    let newUser;\n    let userToken;\n    async.waterfall([\n        (callback) => AuthService.createNewUser(models, (err, rNewUser) => {\n            if (err) {\n                return callback(err);\n            }\n            newUser = rNewUser;\n            return callback();\n        }),\n        (callback) => AuthService.createNewEmail(models, newUser.id, email, callback),\n        (callback) => AuthService.createNewPassword(models, newUser.id, password, callback),\n        (callback) => AuthService.createNewToken(models, newUser.id, (err, rUserToken) => {\n            if (err) {\n                console.error(err);\n                return callback(err);\n            }\n            userToken = rUserToken;\n            return callback();\n        })\n    ], (err) => {\n        if (err) {\n            console.error(err);\n            return callback(err);\n        }\n        console.log(`[${models.tenantId}] Auth Data created`);\n        return callback(err, userToken);\n    });\n};\n\n\n//# sourceURL=webpack:///./src/app/auth/controllers/SignupCtrl.ts?");

/***/ }),

/***/ "./src/app/auth/controllers/authCtrl.js":
/*!**********************************************!*\
  !*** ./src/app/auth/controllers/authCtrl.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const async = __webpack_require__(/*! async */ \"async\");\nconst AuthService = __webpack_require__(/*! ../services/AuthService.js */ \"./src/app/auth/services/AuthService.js\");\n\nconst checkToken = (models, token, callback) => {\n  if (!token) {\n    return callback({\n      status: 400,\n      code: \"INITIAL_PARAMS\"\n    });\n  }\n\n  async.waterfall([callback => AuthService.checkToken(models, token, (err, rUserToken) => {\n    if (err) {\n      return callback(err);\n    }\n\n    if (!rUserToken) {\n      return callback({\n        status: 400,\n        code: \"WRONG_TOKEN\"\n      });\n    }\n\n    if (rUserToken.deleted) {\n      return callback({\n        status: 400,\n        code: \"INVALID_TOKEN\"\n      });\n    }\n\n    return callback(null, rUserToken);\n  })], (err, rUserToken) => callback(err, rUserToken));\n};\n\nconst changePassword = (models, userId, newPassword) => {\n  models.userPassword.destroy({\n    where: [{ userId }]\n  }).then(() => {\n    AuthService.createNewPassword(models, userId, newPassword, () => {});\n  });\n};\n\nmodule.exports = {\n  changePassword,\n  checkToken\n};\n\n//# sourceURL=webpack:///./src/app/auth/controllers/authCtrl.js?");

/***/ }),

/***/ "./src/app/auth/index.ts":
/*!*******************************!*\
  !*** ./src/app/auth/index.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst async = __webpack_require__(/*! async */ \"async\");\nconst randomToken = __webpack_require__(/*! random-token */ \"random-token\");\nconst AuthService = __webpack_require__(/*! ./services/AuthService */ \"./src/app/auth/services/AuthService.js\");\nconst LoginCtrl = __webpack_require__(/*! ./controllers/LoginCtrl */ \"./src/app/auth/controllers/LoginCtrl.js\");\nconst SignupCtrl = __webpack_require__(/*! ./controllers/SignupCtrl */ \"./src/app/auth/controllers/SignupCtrl.ts\");\nconst AuthCtrl = __webpack_require__(/*! ./controllers/authCtrl */ \"./src/app/auth/controllers/authCtrl.js\");\nexports.localSignup = (models, email, password, cb) => {\n    SignupCtrl.createLocalAccount(models, email, password, (err, authUser) => {\n        return cb(err, authUser);\n    });\n};\nexports.requestPasswordReset = (models, email, cb) => {\n    var userEmail, userId;\n    async.waterfall([\n        cb => models\n            .userEmail\n            .findOne({\n            where: {\n                $and: [\n                    { email }\n                ]\n            }\n        })\n            .then(rUserEmail => {\n            if (!rUserEmail) {\n                return setTimeout(() => {\n                    return cb(\"EMAIL_NOT_FOUND\");\n                }, 100);\n            }\n            userEmail = rUserEmail;\n            userId = userEmail.userId;\n            return cb();\n        }, cb),\n        cb => models.userResetCode\n            .create({\n            userId: userEmail.userId,\n            code: randomToken(64)\n        })\n            .then(rCode => {\n            cb(null, rCode);\n        }, cb)\n    ], (err, resetCode) => cb(err, resetCode));\n};\nexports.resetPassword = (models, resetCode, newPassword, cb) => {\n    const code = resetCode;\n    let userId;\n    async.waterfall([\n        cb => models\n            .userResetCode\n            .findOne({\n            where: {\n                $and: [\n                    { code }\n                ]\n            }\n        })\n            .then(rUserResetCode => {\n            if (!rUserResetCode) {\n                return setTimeout(() => cb(\"WRONG_RESET_CODE\"), 500);\n            }\n            userId = rUserResetCode.userId;\n            return cb();\n        }, cb),\n        cb => {\n            return models.userResetCode\n                .destroy({\n                where: {\n                    $and: [\n                        { userId }\n                    ]\n                }\n            })\n                .then(_ => cb(), cb);\n        },\n        cb => {\n            return models.userResetCode\n                .destroy({\n                where: {\n                    $and: [\n                        { userId }\n                    ]\n                }\n            })\n                .then(_ => cb(), cb);\n        },\n        cb => AuthService.createNewPassword(models, userId, newPassword, cb)\n    ], err => {\n        cb(err);\n    });\n};\nexports.getEmailsFromUserId = (models, userId, cb) => {\n    return AuthService\n        .getEmailsFromUserId(models, userId, (err, vqUser) => {\n        return cb(err, vqUser);\n    });\n};\nexports.getAuthUserIdFromEmail = (models, email, cb) => {\n    return AuthService\n        .getUserIdFromEmail(models, email, (err, vqUser) => {\n        return cb(err, vqUser);\n    });\n};\nexports.localLogin = (models, email, password, cb) => {\n    LoginCtrl\n        .loginWithPassword(models, email, password, (err, rUser) => {\n        return cb(err, rUser);\n    });\n};\nexports.checkToken = (models, authToken, cb) => {\n    AuthCtrl.checkToken(models, authToken, (err, rAuthUser) => {\n        return cb(err, rAuthUser);\n    });\n};\nexports.changePassword = (models, userId, currentPassword, newPassword, cb) => {\n    AuthService\n        .checkPassword(models, userId, currentPassword, (err, isCorrect) => {\n        if (err) {\n            return cb(err);\n        }\n        if (isCorrect) {\n            AuthCtrl.changePassword(models, userId, newPassword);\n            return cb();\n        }\n        return cb({\n            status: 400,\n            code: \"WRONG_PASSWORD\"\n        });\n    });\n};\n\n\n//# sourceURL=webpack:///./src/app/auth/index.ts?");

/***/ }),

/***/ "./src/app/auth/services/AuthService.js":
/*!**********************************************!*\
  !*** ./src/app/auth/services/AuthService.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const bcrypt = __webpack_require__(/*! bcrypt-nodejs */ \"bcrypt-nodejs\");\nconst async = __webpack_require__(/*! async */ \"async\");\nconst randomToken = __webpack_require__(/*! random-token */ \"random-token\");\nconst logIndex = \"[AuthService]\";\n\nconst generateHashSync = password => bcrypt.hashSync(password, bcrypt.genSaltSync(8), null);\n\nconst validPasswordSync = (password, encryptedPassword) => {\n\tif (!password || !encryptedPassword) {\n\t\tconsole.error(logIndex, \"validPasswordSync\", \"initial arguments\");\n\n\t\treturn false;\n\t}\n\n\treturn bcrypt.compareSync(password, encryptedPassword);\n};\n\nconst createNewUser = (models, callback) => {\n\treturn models.userAuth.create({}).then(instance => callback(null, instance), err => callback(err));\n};\n\nconst createNewPassword = (models, userId, password, cb) => {\n\tcb = cb || function () {};\n\n\tif (!userId || !password) {\n\t\treturn cb(\"INIT_PARAMS\");\n\t}\n\n\tmodels.userPassword.destroy({\n\t\twhere: {\n\t\t\t$and: [{ userId }]\n\t\t},\n\t\tpassword: generateHashSync(password)\n\t}).then(() => {\n\t\tmodels.userPassword.create({\n\t\t\tuserId: userId,\n\t\t\tpassword: generateHashSync(password)\n\t\t}).then(() => cb(), cb);\n\t}, cb);\n};\n\nconst createNewEmail = (models, userId, email, callback) => async.series([cb => models.userEmail.findOne({\n\twhere: {\n\t\t$and: [{ email }]\n\t}\n}).then(result => {\n\tif (result) {\n\t\treturn cb({\n\t\t\tcode: \"EMAIL_EXISTS\"\n\t\t});\n\t}\n\n\treturn cb();\n}, cb), cb => {\n\tmodels.userEmail.create({\n\t\tuserId: userId,\n\t\temail: email\n\t}).then(() => cb(), cb);\n}], err => callback(err));\n\nconst getUserIdFromNetwork = (models, network, networkId, callback) => {\n\tvar sql = \"SELECT user.id AS userId FROM user AS user\";\n\n\tsql += \" INNER JOIN userNetwork AS network\";\n\tsql += \" ON network.userId = user.id\";\n\tsql += ` WHERE network.networkId = ${networkId} AND network.network = '${network}'`;\n\n\tmodels.seq.query(sql).then(result => {\n\t\tif (result.length) {\n\t\t\treturn callback(null, result[0]);\n\t\t}\n\n\t\treturn callback(null, false);\n\t}, callback);\n};\n\nconst updateNetworkToken = (models, userId, network, networkId, token) => models.userToken.update({\n\ttoken: token\n}, {\n\twhere: {\n\t\t$and: [{ networkId }, { userId }]\n\t}\n}).then(() => {}, err => console.error(err));\n\nconst createNewNetwork = (models, userId, network, networkId, token, refreshToken, callback) => models.userNetwork.create({\n\tuserId: userId,\n\tnetwork: network,\n\tnetworkId: networkId,\n\ttoken: token,\n\trefreshToken: refreshToken\n}).then(instance => callback(), err => callback(err));\n\nconst createNewToken = (models, userId, cb) => {\n\tconsole.log(`[${models.tenantId}]: Creating new user token for vqUserId ${userId}`);\n\n\tmodels.userToken.create({\n\t\ttoken: randomToken(250),\n\t\tuserId: userId\n\t}).then(instance => {\n\t\tconsole.log(\"Token successfuly created.\");\n\n\t\treturn cb(null, instance.dataValues);\n\t}, cb);\n};\n\nconst checkToken = (models, token, callback) => {\n\tmodels.userToken.findOne({\n\t\twhere: [{ token }]\n\t}).then(instance => {\n\t\tvar response = instance || false;\n\n\t\treturn callback(null, response);\n\t}, err => callback(err));\n};\n\nconst checkPassword = (models, userId, password, callback) => {\n\tmodels.userPassword.findOne({\n\t\twhere: {\n\t\t\t$and: [{ userId }]\n\t\t}\n\t}).then(instance => {\n\t\tvar isCorrect = false;\n\n\t\tif (instance) {\n\t\t\tisCorrect = validPasswordSync(password, instance.password);\n\t\t}\n\n\t\treturn callback(null, isCorrect);\n\t}, err => callback(err));\n};\n\nconst getEmailsFromUserId = (models, userId, callback) => {\n\treturn models.userEmail.findAll({\n\t\twhere: {\n\t\t\t$and: [{ userId }]\n\t\t}\n\t}).then(instances => callback(null, instances || false), err => callback(err));\n};\n\nconst getUserIdFromEmail = (models, email, callback) => {\n\treturn models.userEmail.findOne({\n\t\twhere: {\n\t\t\t$and: [{ email }]\n\t\t}\n\t}).then(instance => callback(null, instance || false), err => callback(err));\n};\n\nconst addUserProp = (models, userId, propKey, propValue, callback) => {\n\tif (!userId || !propKey) {\n\t\treturn callback({\n\t\t\tstatus: 400,\n\t\t\tcode: \"INITIAL_PARAMS\"\n\t\t});\n\t}\n\n\tmodels.userProp.findOne({\n\t\twhere: {\n\t\t\t$and: [{ userId }, { propKey }]\n\t\t}\n\t}).then((err, result) => {\n\t\tif (err) {\n\t\t\tconsole.error(err);\n\n\t\t\treturn callback(err);\n\t\t}\n\n\t\tvar promise;\n\n\t\tif (result) {\n\t\t\tpromise = models.userProp.update({\n\t\t\t\tpropValue\n\t\t\t}, {\n\t\t\t\twhere: [{ propKey }, { userId }]\n\t\t\t});\n\t\t} else {\n\t\t\tpromise = models.userProp.create({\n\t\t\t\tpropValue,\n\t\t\t\tpropKey,\n\t\t\t\tuserId\n\t\t\t}, {\n\t\t\t\twhere: [{ propKey }, { userId }]\n\t\t\t});\n\t\t}\n\n\t\tpromise.then(() => callback(), callback);\n\t});\n};\n\nmodule.exports = {\n\tcreateNewUser,\n\tcreateNewPassword,\n\tcreateNewEmail,\n\tcreateNewToken,\n\tcreateNewNetwork,\n\taddUserProp,\n\tcheckPassword,\n\tcheckToken,\n\tgetUserIdFromEmail,\n\tgetEmailsFromUserId,\n\tgetUserIdFromNetwork,\n\tupdateNetworkToken,\n\tgenerateHashSync,\n\tvalidPasswordSync\n};\n\n//# sourceURL=webpack:///./src/app/auth/services/AuthService.js?");

/***/ }),

/***/ "./src/app/config/bucket.js":
/*!**********************************!*\
  !*** ./src/app/config/bucket.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const AWS = __webpack_require__(/*! aws-sdk */ \"aws-sdk\");\n\nAWS.config.region = process.env.AWS_S3_REGION || \"eu-central-1\";\n\nconst s3 = new AWS.S3();\n\nmodule.exports = s3;\n\n//# sourceURL=webpack:///./src/app/config/bucket.js?");

/***/ }),

/***/ "./src/app/config/custProvider.js":
/*!****************************************!*\
  !*** ./src/app/config/custProvider.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("const appConfig = {};\n\nconst getConfig = models => new Promise((resolve, reject) => {\n    models.appConfig.findAll({ order: [\"fieldKey\"] }).then(configs => {\n        configs.map(config => {\n            appConfig[config.fieldKey] = config.fieldValue;\n        });\n\n        resolve(appConfig);\n    }, err => reject(err));\n});\n\nmodule.exports = {\n    getConfig\n};\n\n//# sourceURL=webpack:///./src/app/config/custProvider.js?");

/***/ }),

/***/ "./src/app/config/customizing.js":
/*!***************************************!*\
  !*** ./src/app/config/customizing.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var errorCodes = __webpack_require__(/*! ./errorCodes */ \"./src/app/config/errorCodes.js\");\n\nmodule.exports = {\n\tmode: \"private\", //private/firms\n\ttimezone: \"Europe/Berlin\",\n\ttimeFormat: \"HH:mm\",\n\tdateFormat: \"DD.MM.YYYY HH:mm\",\n\tdateOnlyFormat: \"DD.MM.YYYY\",\n\terrorCodes: errorCodes\n};\n\n//# sourceURL=webpack:///./src/app/config/customizing.js?");

/***/ }),

/***/ "./src/app/config/errorCodes.js":
/*!**************************************!*\
  !*** ./src/app/config/errorCodes.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var errorCodes = {\n\tNO_RIGHTS: {\n\t\thttpCode: 401,\n\t\tcode: \"NO_RIGHTS\",\n\t\tdesc: \"User has not rights.\"\n\t},\n\tBAD_REQUEST: {\n\t\thttpCode: 400,\n\t\tcode: \"BAD_REQUEST\",\n\t\tdesc: \"Review your request.\"\n\t},\n\tALREADY_APPLIED: {\n\t\thttpCode: 400,\n\t\tcodeNo: 4011,\n\t\tcode: \"ALREADY_APPLIED\",\n\t\tdesc: \"You have already appied for this task.\"\n\t},\n\tPHONE_NUMBER_REQUIRED: {\n\t\thttpCode: 400,\n\t\tcodeNo: 4011,\n\t\tcode: \"PHONE_NUMBER_REQUIRED\",\n\t\tdesc: \"Phone number is required for this action.\"\n\t},\n\tEDUCATION_INFO_REQUIRED: {\n\t\thttpCode: 400,\n\t\tcodeNo: 4011,\n\t\tcode: \"EDUCATION_INFO_REQUIRED\",\n\t\tdesc: \"Education information is needed for this action\"\n\t},\n\tPROFILE_INFO_REQUIRED: {\n\t\thttpCode: 400,\n\t\tcodeNo: 4011,\n\t\tcode: \"PROFILE_INFO_REQUIRED\",\n\t\tdesc: \"Profile information required for this action.\"\n\t},\n\tSUSPECTED_PRICING: {\n\t\thttpCode: 400,\n\t\tcodeNo: 4011,\n\t\tcode: \"SUSPECTED_PRICING\",\n\t\tdesc: \"Pricing could not be recalculated. Possible froud behaviour.\"\n\t},\n\tUSER_BLOCKED: {\n\t\thttpCode: 401,\n\t\tcodeNo: 4012,\n\t\tcode: \"BLOCKED\",\n\t\tdesc: \"Tried to access with blocked account.\"\n\t},\n\tUSER_NOT_VERIFIED: {\n\t\thttpCode: 401,\n\t\tcodeNo: 4011,\n\t\tcode: \"USER_NOT_VERIFIED\",\n\t\tdesc: \"You need to verify your email. Contact administrator.\"\n\t},\n\tUSER_DELETED: {\n\t\thttpCode: 401,\n\t\tcodeNo: 4011,\n\t\tcode: \"USER_DELETED\",\n\t\tdesc: \"This account has been deleted.\"\n\t},\n\tNOT_AUTHENTIFICATIED: {\n\t\thttpCode: 401,\n\t\tcodeNo: 4011,\n\t\tcode: \"NOT_AUTHENTIFICATED\",\n\t\tdesc: \"You are not authenticated. Log in.\"\n\t},\n\tMUST_BE_STRING: {\n\t\thttpCode: 400,\n\t\tcodeNo: 4011,\n\t\tcode: \"MUST_BE_STRING\",\n\t\tdesc: \"Field has to be of type 'string'\"\n\t},\n\tUNIVERSITY_NOT_SUPPORTED: {\n\t\thttpCode: 400,\n\t\tcodeNo: 4011,\n\t\tcode: \"UNIVERSITY_NOT_SUPPORTED\",\n\t\tdesc: \"This university is not supported.\"\n\t},\n\tMUST_BE_FLOAT: {\n\t\thttpCode: 400,\n\t\tcodeNo: 4011,\n\t\tcode: \"MUST_BE_FLOAT\",\n\t\tdesc: \"Field has to be of type 'float'\"\n\t},\n\tINVALID_COUNTRY_CODE: {\n\t\thttpCode: 400,\n\t\tcodeNo: 4201,\n\t\tcode: \"INVALID_COUNTRY_CODE\",\n\t\tdesc: \"Invalid country code.\"\n\t},\n\tINVALID_IBAN: {\n\t\thttpCode: 400,\n\t\tcodeNo: 4001,\n\t\tcode: \"INVALID_IBAN\",\n\t\tdesc: \"IBAN is invalid.\"\n\t},\n\tINVALID_BIC: {\n\t\thttpCode: 400,\n\t\tcodeNo: 4001,\n\t\tcode: \"INVALID_BIC\",\n\t\tdesc: \"BIC is invalid.\"\n\t},\n\tEMAIL_NOT_VERIFIED: {\n\t\thttpCode: 400,\n\t\tcodeNo: 4101,\n\t\tcode: \"EMAIL_NOT_VERIFIED\",\n\t\tdesc: \"Email has not beed verified\"\n\t},\n\tNO_PAYMENT_METHOD: {\n\t\thttpCode: 400,\n\t\tcodeNo: 4101,\n\t\tcode: \"NO_PAYMENT_METHOD\",\n\t\tdesc: \"No payment method.\"\n\t},\n\tINSUFFICIENT_FUNDS: {\n\t\thttpCode: 400,\n\t\tcodeNo: 4102,\n\t\tcode: \"INSUFFICIENT_FUNDS\",\n\t\tdesc: \"The wallet's amount is too low.\"\n\t},\n\t//TASK\n\tINVALID_OFFER_TOKEN: {\n\t\thttpCode: 400,\n\t\tcodeNo: 4001,\n\t\tcode: \"INVALID_OFFER_TOKEN\",\n\t\tdesc: \"Offer token is invalid.\"\n\t},\n\tACTION_NOT_POSSIBLE: {\n\t\thttpCode: 400,\n\t\tcodeNo: 4001,\n\t\tcode: \"ACTION_NOT_POSSIBLE\",\n\t\tdesc: \"Action not possible\"\n\t},\n\tOFFER_ALREADY_USED: {\n\t\thttpCode: 400,\n\t\tcodeNo: 4001,\n\t\tcode: \"OFFER_ALREADY_USED\",\n\t\tdesc: \"Offer already used.\"\n\t},\n\tASSISTANT_CANNOT_BE_ASSIGNED: {\n\t\thttpCode: 400,\n\t\tcodeNo: 4000,\n\t\tcode: \"ASSISTANT_CANNOT_BE_ASSIGNED\",\n\t\tdesc: \"Assistant cannot be assigned.\"\n\t},\n\n\tMOBILE_CODE_NOT_SUPPORTED: {\n\t\thttpCode: 400,\n\t\tcodeNo: 4102,\n\t\tcode: \"MOBILE_CODE_NOT_SUPPORTED\",\n\t\tdesc: \"Mobile code is not permitted. Try 49.\"\n\t},\n\tINVALID_MOBILE_NUMBER: {\n\t\thttpCode: 400,\n\t\tcodeNo: 4102,\n\t\tcode: \"INVALID_MOBILE_NUMBER\",\n\t\tdesc: \"Invalid mobile number.\"\n\t},\n\t// SIGNUP ERRORS\n\tSIGNUP_EMAIL_EXISTS: {\n\t\thttpCode: 400,\n\t\tcodeNo: 4040,\n\t\tcode: \"SIGNUP_EMAIL_EXISTS\",\n\t\tdesc: \"An account is already assigned to this email.\"\n\t},\n\tSIGNUP_EMAIL_INITIAL: {\n\t\thttpCode: 400,\n\t\tcodeNo: 4041,\n\t\tcode: \"SIGNUP_EMAIL_INITIAL\",\n\t\tdesc: \"Provide an email address to sign up.\"\n\t},\n\tSIGNUP_FIRST_NAME_INITIAL: {\n\t\thttpCode: 400,\n\t\tcodeNo: 4042,\n\t\tcode: \"SIGNUP_FIRST_NAME_INITIAL\",\n\t\tdesc: \"Provide first name to sign up.\"\n\t},\n\tSIGNUP_LAST_NAME_INITIAL: {\n\t\thttpCode: 400,\n\t\tcodeNo: 4043,\n\t\tcode: \"SIGNUP_LAST_NAME_INITIAL\",\n\t\tdesc: \"Provide last name to sign up.\"\n\t},\n\tSIGNUP_PASSWORD_INITIAL: {\n\t\thttpCode: 400,\n\t\tcodeNo: 4044,\n\t\tcode: \"SIGNUP_PASSWORD_INITIAL\",\n\t\tdesc: \"Provide password to sign up.\"\n\t},\n\tSIGNUP_MOBILE_INITIAL: {\n\t\thttpCode: 400,\n\t\tcodeNo: 4045,\n\t\tcode: \"SIGNUP_PASSWORD_INITIAL\",\n\t\tdesc: \"Provide mobile to sign up.\"\n\t},\n\tSIGNUP_MOBILE_CODE_INITIAL: {\n\t\thttpCode: 400,\n\t\tcodeNo: 4046,\n\t\tcode: \"SIGNUP_MOBILE_CODE_INITIAL\",\n\t\tdesc: \"Provide mobile code to sign up.\"\n\t},\n\tSIGNUP_MOBILE_NUMBER_INITIAL: {\n\t\thttpCode: 400,\n\t\tcodeNo: 4047,\n\t\tcode: \"SIGNUP_MOBILE_NUMBER_INITIAL\",\n\t\tdesc: \"Provide mobile number to sign up.\"\n\t},\n\tSIGNUP_ACCOUNT_TYPE_INITIAL: {\n\t\thttpCode: 400,\n\t\tcodeNo: 4048,\n\t\tcode: \"SIGNUP_ACCOUNT_TYPE_INITIAL\",\n\t\tdesc: \"Account Type is initial.\"\n\t},\n\tSIGNUP_ACCOUNT_TYPE_UNKNOWN: {\n\t\thttpCode: 400,\n\t\tcodeNo: 4049,\n\t\tcode: \"SIGNUP_ACCOUNT_TYPE_UNKNOWN\",\n\t\tdesc: \"Account Type is unknown.\"\n\t},\n\t// SOME SOME\n\tMALFORMATTED_PARAMETERS: {\n\t\thttpCode: 400,\n\t\tcodeNo: 4103,\n\t\tcode: \"MALFORMATTED_PARAMETERS\",\n\t\tdesc: \"Wrong formatting of request parameters.\"\n\t},\n\n\tWALLET_NOT_ASSIGNED: {\n\t\thttpCode: 400,\n\t\tcodeNo: 4000,\n\t\tcode: \"WALLET_NOT_ASSIGNED\",\n\t\tdesc: \"No wallet has been assigned to user.\"\n\t},\n\n\tWALLET_NOT_FOUND: {\n\t\thttpCode: 400,\n\t\tcodeNo: 5000,\n\t\tcode: \"WALLET_NOT_FOUND\",\n\t\tdesc: \"User's wallet has not been found.\"\n\t},\n\n\tUSER_NOT_FOUND: {\n\t\thttpCode: 400,\n\t\tcodeNo: 4000,\n\t\tcode: \"USER_NOT_FOUND\",\n\t\tdesc: \"User not found.\"\n\t},\n\tTASK_NOT_FOUND: {\n\t\thttpCode: 400,\n\t\tcodeNo: 4201,\n\t\tcode: \"TASK_NOT_FOUND\",\n\t\tdesc: \"Task with this ID could not be found in the database.\"\n\t},\n\tINVOICE_KEY_NOT_FOUND: {\n\t\thttpCode: 400,\n\t\tcodeNo: 4201,\n\t\tcode: \"INVOICE_KEY_NOT_FOUND\",\n\t\tdesc: \"Invoice key has not been found.\"\n\t},\n\tNOT_AUTHORIZED: {\n\t\thttpCode: 401,\n\t\tcodeNo: 4001,\n\t\tcode: \"NOT_AUTHORIZED\",\n\t\tdesc: \"You are not authorized for this action.\"\n\t},\n\tDATABASE_ERROR: {\n\t\thttpCode: 500,\n\t\tcodeNo: 5021,\n\t\tcode: \"DATABASE_ERROR\",\n\t\tdesc: \"Request to database resulted in an error.\"\n\t},\n\tINITIAL_PARAMETERS: {\n\t\thttpCode: 400,\n\t\tcodeNo: 5400,\n\t\tcode: \"INITIAL_PARAMETERS\",\n\t\tdesc: \"Initial parameters in function implementation.\"\n\t},\n\tTASK_OWNER_NOT_FOUND: {\n\t\thttpCode: 500,\n\t\tcodeNo: 5400,\n\t\tcode: \"TASK_OWNER_NOT_FOUND\",\n\t\tdesc: \"Task owner has not been found.\"\n\t},\n\tASSIGNED_USER_NOT_FOUND: {\n\t\thttpCode: 500,\n\t\tcodeNo: 5400,\n\t\tcode: \"ASSIGNED_USER_NOT_FOUND\",\n\t\tdesc: \"Task owner has not been found.\"\n\t},\n\tUNKNOWN_ERROR: {\n\t\thttpCode: 500,\n\t\tcodeNo: 5031,\n\t\tcode: \"UNKNOWN_ERROR\",\n\t\tdesc: \"Unknown Internal Server Error.\"\n\t},\n\tINVALID_VERIFICATION_TOKEN: {\n\t\thttpCode: 400,\n\t\tcodeNo: 4001,\n\t\tcode: \"INVALID_VERIFICATION_TOKEN\",\n\t\tdesc: \"Invalid verification token\"\n\t},\n\t//TASK\n\tPAYMENT_PROVIDER_ERROR: {\n\t\thttpCode: 502,\n\t\tcodeNo: 5021,\n\t\tcode: \"PAYMENT_PROVIDER_ERROR\",\n\t\tdesc: \"Unknown Payment Provider Error.\"\n\t},\n\tDEPOSIT_AMOUNT_NOT_ALLOWED: {\n\t\thttpCode: 400,\n\t\tcodeNo: 4021,\n\t\tcode: \"DEPOSIT_AMOUNT_NOT_ALLOWED\",\n\t\tdesc: \"Deposit Amount not allowed.\"\n\t},\n\t//MANGOPAY\n\tMANGOPAY_USER_NOT_FOUND: {\n\t\thttpCode: 500,\n\t\tcodeNo: 5021,\n\t\tcode: \"MANGOPAY_USER_NOT_FOUND\",\n\t\tdesc: \"Mangopay user not found.\"\n\t},\n\tNO_BILLING_ADDRESS: {\n\t\thttpCode: 400,\n\t\tcodeNo: 4021,\n\t\tcode: \"NO_BILLING_ADDRESS\",\n\t\tdesc: \"Billing address is missing.\"\n\t},\n\tNO_TAX_NUMBER_ASSISTANT: {\n\t\thttpCode: 400,\n\t\tcodeNo: 4031,\n\t\tcode: \"NO_TAX_NUMBER_ASSISTANT\",\n\t\tdesc: \"Enter your tax number to accept tasks.\"\n\t}\n};\n\nmodule.exports = errorCodes;\n\n//# sourceURL=webpack:///./src/app/config/errorCodes.js?");

/***/ }),

/***/ "./src/app/controllers/authCtrl.ts":
/*!*****************************************!*\
  !*** ./src/app/controllers/authCtrl.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst async = __webpack_require__(/*! async */ \"async\");\nconst randomstring = __webpack_require__(/*! randomstring */ \"randomstring\");\nconst vqAuth = __webpack_require__(/*! ../auth */ \"./src/app/auth/index.ts\");\nconst userEmitter = __webpack_require__(/*! ../events/user */ \"./src/app/events/user.js\");\nconst validateEmail = (email) => {\n    const re = /^(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\n    return re.test(email);\n};\nexports.createNewAccount = (models, data, cb) => {\n    const email = data.email;\n    // if no password is generated, we generate a random one. User will have to restart it in order to log-in.\n    const password = data.password || randomstring.generate(10);\n    data.props = data.props || {};\n    if (!validateEmail(email)) {\n        return cb({\n            httpCode: 400,\n            code: \"EMAIL_WRONGLY_FORMATTED\",\n            desc: \"Email wrongly formatted\"\n        });\n    }\n    let vqUserId, vqAuthUser, user;\n    let shouldBeAdmin = false;\n    async.waterfall([\n        (cb) => {\n            return vqAuth.localSignup(models, email, password, (err, rUser) => {\n                if (err) {\n                    return cb(err);\n                }\n                vqAuthUser = rUser;\n                vqUserId = rUser.userId;\n                return cb();\n            });\n        },\n        (cb) => models.user\n            .count({})\n            .then((count) => {\n            shouldBeAdmin = !count;\n            return cb();\n        }, cb),\n        (cb) => {\n            models\n                .user\n                .create({\n                accountType: \"PRIVATE\",\n                vqUserId,\n                status: shouldBeAdmin ? models.user.USER_STATUS.VERIFIED : models.user.USER_STATUS.UNVERIFIED,\n                isAdmin: shouldBeAdmin,\n                firstName: data.firstName,\n                lastName: data.lastName,\n                userType: data.userType || 0\n            })\n                .then((rUser) => {\n                user = rUser;\n                if (shouldBeAdmin) {\n                    console.log(`Admin user created for ${data.email}`);\n                }\n                return cb();\n            }, cb);\n        },\n        (cb) => async\n            .eachSeries(Object.keys(data.props), (propKey, cb) => models.userProperty\n            .create({\n            propKey,\n            propValue: data.props[propKey],\n            userId: user.id\n        })\n            .then(() => cb(), cb), cb),\n        (cb) => {\n            models\n                .user\n                .findById(user.id, {\n                include: [{ all: true }]\n            })\n                .then((rUser) => {\n                user = rUser;\n                return cb();\n            }, cb);\n        }\n    ], (err) => {\n        if (err) {\n            console.log(\"Error creating user\");\n            return cb(err);\n        }\n        const responseData = vqAuthUser;\n        responseData.user = user;\n        if (!shouldBeAdmin) {\n            const emittedUser = JSON.parse(JSON.stringify(user));\n            emittedUser.emails = [\n                email\n            ];\n            userEmitter.emit(\"created\", models, emittedUser);\n        }\n        return cb(err, vqAuthUser);\n    });\n};\n\n\n//# sourceURL=webpack:///./src/app/controllers/authCtrl.ts?");

/***/ }),

/***/ "./src/app/controllers/orderCtrl.js":
/*!******************************************!*\
  !*** ./src/app/controllers/orderCtrl.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const async = __webpack_require__(/*! async */ \"async\");\nconst stripeProvider = __webpack_require__(/*! ../../shared-providers/stripe */ \"./src/shared-providers/stripe.ts\");\nconst orderEmitter = __webpack_require__(/*! ../events/order */ \"./src/app/events/order.js\");\nconst requestEmitter = __webpack_require__(/*! ../events/request */ \"./src/app/events/request.js\");\nconst taskEmitter = __webpack_require__(/*! ../events/task */ \"./src/app/events/task.js\");\nconst utils = __webpack_require__(/*! ../utils */ \"./src/app/utils/index.js\");\n\nconst tryGetPaymentConfigs = (models, cb) => {\n    let paymentsEnabledConfig;\n    let stripePrivateKeyConfig;\n    let provisionConfig;\n\n    async.waterfall([cb => {\n        models.appConfig.findAll({\n            $where: {\n                $or: [{ fieldKey: \"PAYMENTS_ENABLED\" }, { fieldKey: \"MARKETPLACE_PROVISION\" }, { fieldKey: \"STRIPE_PRIVATE_KEY\" }]\n            }\n        }).then(rPaymentConfigs => {\n            paymentsEnabledConfig = rPaymentConfigs.find(_ => _.fieldKey === \"PAYMENTS_ENABLED\");\n\n            stripePrivateKeyConfig = rPaymentConfigs.find(_ => _.fieldKey === \"STRIPE_PRIVATE_KEY\");\n\n            provisionConfig = rPaymentConfigs.find(_ => _.fieldKey === \"MARKETPLACE_PROVISION\");\n\n            cb();\n        }, cb);\n    }, cb => {\n        if (!paymentsEnabledConfig || paymentsEnabledConfig.fieldValue !== \"1\") {\n            return cb();\n        }\n\n        if (!stripePrivateKeyConfig || !stripePrivateKeyConfig.fieldValue) {\n            cb({\n                code: \"PAYMENTS_ERROR\"\n            });\n\n            return;\n        }\n    }], err => {\n        cb(err, {\n            paymentsEnabledConfig,\n            stripePrivateKeyConfig,\n            provisionConfig\n        });\n    });\n};\n\nconst settleOrder = (models, orderId, userId, cb) => {\n    let requestId;\n    let order;\n    let stripePrivateKey;\n    let paymentsEnabledConfig;\n\n    userId = Number(userId);\n    orderId = Number(orderId);\n\n    async.waterfall([cb => models.order.findById(orderId).then(rOrder => {\n        if (!rOrder) {\n            return cb(\"NOT_FOUND\");\n        }\n\n        if (rOrder.userId !== userId) {\n            return cb(\"NOT_AUTHORIZED_TO_SETTLE\");\n        }\n\n        const possibleStatusForUpdate = [models.order.ORDER_STATUS.MARKED_DONE, models.order.ORDER_STATUS.PENDING];\n\n        if (possibleStatusForUpdate.indexOf(rOrder.status) === -1) {\n            return cb(\"WRONG_STATUS\");\n        }\n\n        order = rOrder;\n        requestId = order.requestId;\n\n        return cb();\n    }, cb), cb => tryGetPaymentConfigs(models, (err, paymentConfigs) => {\n        if (err) {\n            return cb(err);\n        }\n\n        paymentsEnabledConfig = paymentConfigs.paymentsEnabledConfig;\n        stripePrivateKey = paymentConfigs.stripePrivateKeyConfig;\n\n        cb();\n    }), cb => {\n        if (!paymentsEnabledConfig || paymentsEnabledConfig.fieldValue !== \"1\") {\n            return cb();\n        }\n\n        if (!stripePrivateKey || !stripePrivateKey.fieldValue) {\n            cb({\n                code: \"PAYMENTS_ERROR\"\n            });\n\n            return;\n        }\n    },\n    /**\n     * WE CAPTURE THE CHARGE!\n     */\n    cb => {\n        if (!paymentsEnabledConfig || paymentsEnabledConfig.fieldValue !== \"1\") {\n            cb();\n\n            return;\n        }\n\n        const stripe = stripeProvider.getTenantStripe(stripePrivateKey.fieldValue);\n\n        models.paymentObject.findOne({\n            where: {\n                $and: [{ type: \"charge\" }, { orderId: order.id }]\n            }\n        }).then(rCharge => {\n            if (!rCharge) {\n                cb({\n                    code: \"NO_ORDER_CHARGE\",\n                    desc: \"No charge has been created for this booking.\"\n                });\n\n                return;\n            }\n\n            stripe.charges.capture(rCharge.obj.id, err => {\n                cb(err);\n            });\n        }, cb);\n    }, cb => models.order.update({\n        status: models.order.ORDER_STATUS.SETTLED,\n        settledAt: utils.getUtcUnixTimeNow()\n    }, {\n        where: {\n            id: orderId\n        }\n    }).then(() => cb(), cb), cb => {\n        models.request.update({\n            status: models.request.REQUEST_STATUS.SETTLED\n        }, {\n            where: {\n                id: requestId\n            }\n        }).then(() => cb(), cb);\n    }], err => {\n        if (err) {\n            return cb(err);\n        }\n\n        requestEmitter.emit(\"request-completed\", models, requestId);\n\n        orderEmitter.emit(\"order-completed\", models, orderId);\n\n        cb(null, order);\n    });\n};\n\nmodule.exports = {\n    settleOrder,\n    tryGetPaymentConfigs\n};\n\n//# sourceURL=webpack:///./src/app/controllers/orderCtrl.js?");

/***/ }),

/***/ "./src/app/controllers/requestCtrl.ts":
/*!********************************************!*\
  !*** ./src/app/controllers/requestCtrl.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const async = __webpack_require__(/*! async */ \"async\");\nconst requestEmitter = __webpack_require__(/*! ../events/request */ \"./src/app/events/request.js\");\nconst orderEmitter = __webpack_require__(/*! ../events/order */ \"./src/app/events/order.js\");\nconst taskEmitter = __webpack_require__(/*! ../events/task */ \"./src/app/events/task.js\");\nconst utils = __webpack_require__(/*! ../utils */ \"./src/app/utils/index.js\");\nconst declineRequest = (models, requestId, cb) => {\n    models\n        .request\n        .findById(requestId)\n        .then((request) => {\n        request\n            .update({\n            status: models.request.REQUEST_STATUS.DECLINED\n        });\n        if (cb) {\n            cb();\n        }\n        requestEmitter.emit(\"request-declined\", models, request.id);\n    }, cb);\n};\nconst declineAllPendingRequestsForTask = (models, taskId, cb) => {\n    models.request.findAll({\n        where: {\n            $and: [\n                { taskId: taskId },\n                { status: models.request.REQUEST_STATUS.PENDING }\n            ]\n        }\n    }).then((pendingRequests) => {\n        async.eachSeries(pendingRequests, (request, cb) => {\n            return declineRequest(models, request.id, cb);\n        }, cb);\n    });\n};\nconst changeRequestStatus = (models, requestId, newStatus, userId, cb) => {\n    newStatus = String(newStatus);\n    userId = Number(userId);\n    requestId = Number(requestId);\n    var order, oldRequest;\n    async.waterfall([\n        (cb) => {\n            models\n                .request\n                .findById(requestId)\n                .then((requestRef) => {\n                if (!requestRef) {\n                    return cb({\n                        code: \"REQUEST_NOT_FOUND\"\n                    });\n                }\n                oldRequest = requestRef;\n                if (requestRef.status === newStatus) {\n                    return cb({\n                        code: \"NO_ACTION_REQUIRED\"\n                    });\n                }\n                return cb(null, requestRef);\n            });\n        },\n        (requestRef, cb) => {\n            if (requestRef.fromUserId !== userId && requestRef.toUserId !== userId) {\n                return cb({\n                    code: \"NOT_YOUR_REQUEST\"\n                });\n            }\n            requestRef.update({\n                status: newStatus\n            })\n                .then(() => cb(), cb);\n        },\n        (cb) => {\n            if (newStatus !== models.request.REQUEST_STATUS.MARKED_DONE) {\n                return cb();\n            }\n            if (newStatus === models.request.REQUEST_STATUS.MARKED_DONE) {\n                const autoSettlementStartedAt = utils.getUtcUnixTimeNow();\n                // @TODO - support for 1 request - 1 order relation. Need for more pricing models.\n                models.order\n                    .findOne({\n                    where: {\n                        requestId\n                    }\n                })\n                    .then((rOrder) => {\n                    order = rOrder;\n                    order\n                        .updateAttributes({\n                        autoSettlementStartedAt,\n                        status: models.order.ORDER_STATUS.MARKED_DONE\n                    })\n                        .then(() => cb(), cb);\n                }, cb);\n            }\n        }\n    ], (err) => {\n        if (err) {\n            return cb(err);\n        }\n        if (newStatus === models.request.REQUEST_STATUS.MARKED_DONE) {\n            orderEmitter\n                .emit(\"order-marked-as-done\", models, order.id);\n        }\n        if (newStatus === models.request.REQUEST_STATUS.CANCELED) {\n            models\n                .task\n                .findById(oldRequest.taskId)\n                .then((rTask) => {\n                taskEmitter\n                    .emit(\"task-request-cancelled\", models, rTask);\n                requestEmitter\n                    .emit(\"request-cancelled\", models, requestId);\n            });\n        }\n        return cb(null, oldRequest);\n    });\n};\nmodule.exports = {\n    declineAllPendingRequestsForTask,\n    changeRequestStatus,\n    declineRequest\n};\n\n\n//# sourceURL=webpack:///./src/app/controllers/requestCtrl.ts?");

/***/ }),

/***/ "./src/app/controllers/responseController.js":
/*!***************************************************!*\
  !*** ./src/app/controllers/responseController.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const jwt = __webpack_require__(/*! jsonwebtoken */ \"jsonwebtoken\");\nconst cust = __webpack_require__(/*! ../config/customizing */ \"./src/app/config/customizing.js\");\nconst randomstring = __webpack_require__(/*! randomstring */ \"randomstring\");\nconst models = __webpack_require__(/*! ../models/models */ \"./src/app/models/models.ts\");\nconst vqAuth = __webpack_require__(/*! ../auth */ \"./src/app/auth/index.ts\");\n\nfunction isAuth(req) {\n\tif (req.headers[\"x-auth-token\"]) {\n\t\ttry {\n\t\t\tvar secret = process.env.SECRET || randomstring.generate(64);\n\t\t\tvar decoded = jwt.verify(req.headers[\"x-auth-token\"], secret);\n\n\t\t\treturn decoded;\n\t\t} catch (err) {\n\t\t\tconsole.log(err);\n\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\treturn false;\n\t}\n}\n\nfunction parseUserFactory(loginRequired, adminRequired, requiredStatus) {\n\treturn (req, res, next) => {\n\t\tconst authToken = req.headers[\"x-auth-token\"];\n\n\t\tvqAuth.checkToken(req.models, authToken, (err, rAuthUser) => {\n\t\t\tif (err) {\n\t\t\t\tif (loginRequired || adminRequired) {\n\t\t\t\t\treturn res.status(cust.errorCodes.NOT_AUTHENTIFICATIED.httpCode).send(cust.errorCodes.NOT_AUTHENTIFICATIED);\n\t\t\t\t}\n\n\t\t\t\treturn next();\n\t\t\t}\n\n\t\t\tif (rAuthUser) {\n\t\t\t\treq.models.user.findOne({\n\t\t\t\t\twhere: {\n\t\t\t\t\t\tvqUserId: rAuthUser.userId\n\t\t\t\t\t},\n\t\t\t\t\tinclude: [{ model: req.models.userProperty }, { model: req.models.userPreference }]\n\t\t\t\t}).then(user => {\n\t\t\t\t\tif (!user) {\n\t\t\t\t\t\treturn res.status(cust.errorCodes.NOT_AUTHENTIFICATIED.httpCode).send(cust.errorCodes.NOT_AUTHENTIFICATIED);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (user.status == \"20\") {\n\t\t\t\t\t\treturn res.status(cust.errorCodes.USER_BLOCKED.httpCode).send(cust.errorCodes.USER_BLOCKED);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (requiredStatus && user.status !== requiredStatus) {\n\t\t\t\t\t\treturn res.status(cust.errorCodes.NO_RIGHTS.httpCode).send(cust.errorCodes.NO_RIGHTS);\n\t\t\t\t\t}\n\n\t\t\t\t\treq.user = user.dataValues;\n\n\t\t\t\t\tif (adminRequired && !req.user.isAdmin) {\n\t\t\t\t\t\treturn res.status(cust.errorCodes.NOT_AUTHENTIFICATIED.httpCode).send(cust.errorCodes.NOT_AUTHENTIFICATIED);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn next();\n\t\t\t\t}, err => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treturn res.status(cust.errorCodes.DATABASE_ERROR.httpCode).send(cust.errorCodes.DATABASE_ERROR);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tif (loginRequired || adminRequired) {\n\t\t\t\t\treturn res.status(cust.errorCodes.NOT_AUTHENTIFICATIED.httpCode).send(cust.errorCodes.NOT_AUTHENTIFICATIED);\n\t\t\t\t}\n\n\t\t\t\treturn next();\n\t\t\t}\n\t\t});\n\t};\n}\n\nconst isLoggedIn = parseUserFactory(true, false);\nconst isLoggedInAndVerified = parseUserFactory(true, false, \"10\");\nconst isAdmin = parseUserFactory(true, true);\nconst identifyUser = parseUserFactory(false, false);\n\nconst subscriptions = {};\n\nconst hasValidSubscription = (req, res, next) => {\n\treturn next();\n\t/**\n \tif (!subscriptions[req.tenantId]) {\n \t\treturn res.status(400).send({\n \t\t\tcode: \"INVALID_SUBSCRIPTION\"\n \t\t});\n \t}\n \t\treturn next();\n */\n};\n\nmodule.exports = {\n\thasValidSubscription,\n\tisAdmin,\n\tisLoggedIn,\n\tisLoggedInAndVerified,\n\tidentifyUser,\n\tsendResponse: (res, err, data) => {\n\t\tif (err) {\n\t\t\tconsole.error(err);\n\n\t\t\tif (typeof err === \"string\") {\n\t\t\t\treturn res.status(400).send(err);\n\t\t\t}\n\n\t\t\tif (err.httpCode) {\n\t\t\t\treturn res.status(err.httpCode).send(err);\n\t\t\t}\n\n\t\t\tif (err.code) {\n\t\t\t\treturn res.status(400).send(err);\n\t\t\t}\n\n\t\t\tif (err.status) {\n\t\t\t\terr.data = data;\n\n\t\t\t\treturn res.status(err.status).send(err);\n\t\t\t}\n\n\t\t\treturn res.status(500).send(err);\n\t\t}\n\n\t\treturn res.status(200).send(data);\n\t},\n\tsendError: (res, errCode, error) => {\n\t\tvar err = cust.errorCodes[errCode];\n\n\t\tif (err) {\n\t\t\terr.data = error;\n\t\t\treturn res.status(err.httpCode).send(err);\n\t\t}\n\n\t\tconsole.log(\"[UNKNOWN ERROR CODE]\", errCode);\n\t\treturn res.status(500).send(cust.errorCodes.UNKNOWN_ERROR);\n\t},\n\tgenerateError: (errCode, data) => {\n\t\tvar errorObj = cust.errorCodes[errCode];\n\t\tif (errorObj) {\n\t\t\treturn { status: errorObj.httpCode, code: errorObj.code, message: errorObj.desc, data: data };\n\t\t}\n\n\t\terrorObj = cust.errorCodes.UNKNOWN_ERROR;\n\n\t\treturn { status: errorObj.httpCode, code: errorObj.code, message: errorObj.desc, data: data };\n\t},\n\tisAuth: isAuth\n};\n\n//# sourceURL=webpack:///./src/app/controllers/responseController.js?");

/***/ }),

/***/ "./src/app/controllers/taskCtrl.ts":
/*!*****************************************!*\
  !*** ./src/app/controllers/taskCtrl.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const async = __webpack_require__(/*! async */ \"async\");\nconst requestEmitter = __webpack_require__(/*! ../events/request */ \"./src/app/events/request.js\");\nconst orderEmitter = __webpack_require__(/*! ../events/order */ \"./src/app/events/order.js\");\nconst taskEmitter = __webpack_require__(/*! ../events/task */ \"./src/app/events/task.js\");\nconst utils = __webpack_require__(/*! ../utils */ \"./src/app/utils/index.js\");\nconst requestCtrl = __webpack_require__(/*! ../controllers/requestCtrl */ \"./src/app/controllers/requestCtrl.ts\");\nconst cancelAllUnbookedTasks = (models, categoryCode, cb) => {\n    const taskIds = [];\n    let unBookedTasks;\n    return async.waterfall([\n        (cb) => {\n            models.taskCategory\n                .findAll({\n                where: {\n                    code: categoryCode\n                }\n            })\n                .then((taskCategories) => {\n                taskCategories.forEach((taskCategory) => {\n                    taskIds.push(taskCategory.dataValues.taskId);\n                });\n                cb();\n            }, cb);\n        },\n        (cb) => {\n            models.task\n                .findAll({\n                where: {\n                    $and: [\n                        {\n                            id: {\n                                $in: taskIds\n                            }\n                        },\n                        {\n                            status: models.task.TASK_STATUS.ACTIVE\n                        }\n                    ]\n                }\n            })\n                .then((tasksToCancel) => {\n                unBookedTasks = tasksToCancel;\n                cb();\n            }, cb);\n        },\n        (cb) => {\n            async.eachSeries(unBookedTasks, (task, cb) => {\n                return models\n                    .task\n                    .update({\n                    status: models.task.TASK_STATUS.INACTIVE\n                }, {\n                    where: {\n                        id: task.id\n                    }\n                })\n                    .then(() => cb(), cb);\n            }, cb);\n        },\n        (cb) => {\n            async.eachSeries(unBookedTasks, (task, cb) => {\n                return requestCtrl.cancelAllPendingRequestsForTask(models, task.id, cb);\n            }, cb);\n        }\n    ], cb);\n};\nmodule.exports = {\n    cancelAllUnbookedTasks,\n};\n\n\n//# sourceURL=webpack:///./src/app/controllers/taskCtrl.ts?");

/***/ }),

/***/ "./src/app/events/order.js":
/*!*********************************!*\
  !*** ./src/app/events/order.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const EventEmitter = __webpack_require__(/*! events */ \"events\");\nconst async = __webpack_require__(/*! async */ \"async\");\nconst emailService = __webpack_require__(/*! ../services/emailService.js */ \"./src/app/services/emailService.js\");\nconst vqAuth = __webpack_require__(/*! ../auth */ \"./src/app/auth/index.ts\");\n\nclass DefaultEmitter extends EventEmitter {}\n\nvar orderEmitter = new DefaultEmitter();\n\nconst getOrderOwnerEmails = (models, orderId, cb) => {\n    let emails, supplyEmails, supplyUserId, demandUserId, order, task, request;\n\n    return async.waterfall([cb => models.order.findOne({\n        where: {\n            id: orderId\n        },\n        include: [{ model: models.task }, { model: models.user }, {\n            model: models.request,\n            include: [{ model: models.user, as: \"fromUser\" }, { model: models.user, as: \"toUser\" }]\n        }]\n    }).then(rOrder => {\n        if (!rOrder) {\n            return cb({\n                code: \"ORDER_NOT_FOUND\"\n            });\n        }\n\n        order = rOrder;\n        task = rOrder.task;\n        request = rOrder.request;\n\n        supplyUserId = request.fromUser.id === order.user.id ? request.toUser.id : request.fromUser.id;\n\n        demandUserId = order.user.id;\n\n        return cb();\n    }, cb),\n\n    // get demand user emails\n    cb => vqAuth.getEmailsFromUserId(models, order.user.vqUserId, (err, rUserEmails) => {\n        if (err) {\n            return cb(err);\n        }\n\n        emails = rUserEmails.map(_ => _.email);\n\n        return cb();\n    }),\n\n    // get supplier emails\n    cb => {\n        const vqSupplyUserId = request.fromUser.vqUserId === order.user.vqUserId ? request.toUser.vqUserId : request.fromUser.vqUserId;\n\n        vqAuth.getEmailsFromUserId(models, vqSupplyUserId, (err, rUserEmails) => {\n            if (err) {\n                return cb(err);\n            }\n\n            supplyEmails = rUserEmails.map(_ => _.email);\n\n            return cb();\n        });\n    }], err => {\n        return cb(err, {\n            demandUserId,\n            supplyUserId,\n            task,\n            order,\n            emails,\n            supplyEmails\n        });\n    });\n};\n\nconst orderEventHandlerFactory = (emailCode, actionUrlFn) => {\n    return (models, orderId) => {\n        var order, task;\n        var domain;\n        var demandEmails, supplyEmails, demandUserId, supplyUserId;\n\n        async.waterfall([cb => getOrderOwnerEmails(models, orderId, (err, data) => {\n            if (err) {\n                return cb(err);\n            }\n\n            demandUserId = data.demandUserId;\n            supplyUserId = data.supplyUserId;\n            supplyEmails = data.supplyEmails;\n            demandEmails = data.emails;\n            order = data.order;\n            task = data.task;\n\n            cb();\n        }), cb => models.appConfig.findOne({\n            where: {\n                fieldKey: \"DOMAIN\"\n            }\n        }).then(configField => {\n            configField = configField || {};\n\n            domain = configField.fieldValue || \"http://localhost:3000\";\n\n            cb();\n        }, cb)], err => {\n            if (err) {\n                return console.error(err);\n            }\n\n            const ACTION_URL = actionUrlFn(domain, order.requestId, order.id, 1);\n            const SUPPLY_ACTION_URL = actionUrlFn(domain, order.requestId, order.id, 2);\n            const emailData = {\n                ACTION_URL,\n                SUPPLY_ACTION_URL,\n                LISTING_TITLE: task.title,\n                ORDER_ID: order.id,\n                ORDER_CURRENCY: order.currency,\n                ORDER_AMOUNT: order.amount,\n                ORDER_CREATED_AT: order.createdAt\n            };\n\n            // new more general email handling\n            if (emailCode === \"new-order\" || emailCode === \"order-closed\" || emailCode === \"order-completed\" || emailCode === \"order-marked-as-done\") {\n                emailService.sendEmailsOnEvent(models, emailCode, demandEmails, supplyEmails, emailData);\n            } else {\n                // old email handling\n                emailService.checkIfShouldSendEmail(models, emailCode, order.userId, () => emailService.getEmailAndSend(models, emailCode, demandEmails, emailData));\n            }\n        });\n    };\n};\n\norderEmitter.on(\"closed\", orderEventHandlerFactory(\"order-closed\", (domain, requestId, orderId, userType) => `${domain}/app/${userType === 1 ? \"order\" : \"request\"}/${userType === 1 ? orderId : requestId}/review`));\n\norderEmitter.on(\"order-completed\", orderEventHandlerFactory(\"order-completed\", (domain, requestId, orderId, userType) => `${domain}/app/${userType === 1 ? \"order\" : \"request\"}/${userType === 1 ? orderId : requestId}/review`));\n\norderEmitter.on(\"new-order\", orderEventHandlerFactory(\"new-order\", (domain, requestId) => `${domain}/app/chat/${requestId}`));\n\norderEmitter.on(\"order-marked-as-done\", orderEventHandlerFactory(\"order-marked-as-done\", (domain, requestId, orderId, userType) => userType === 1 ? `${domain}/app/chat/${requestId}` : `${domain}/app/dashboard`));\n\nmodule.exports = orderEmitter;\n\n//# sourceURL=webpack:///./src/app/events/order.js?");

/***/ }),

/***/ "./src/app/events/request.js":
/*!***********************************!*\
  !*** ./src/app/events/request.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\nconst async = __webpack_require__(/*! async */ \"async\");\nconst emailService = __webpack_require__(/*! ../services/emailService.js */ \"./src/app/services/emailService.js\");\nconst vqAuth = __webpack_require__(/*! ../auth */ \"./src/app/auth/index.ts\");\n\nclass DefaultEmitter extends EventEmitter {}\n\nconst requestEmitter = new DefaultEmitter();\n\nconst getOrderFromRequest = (models, requestId, cb) => {\n\tmodels.order.findOne({\n\t\twhere: {\n\t\t\trequestId\n\t\t}\n\t}).then(order => {\n\t\treturn cb(null, order);\n\t}, cb);\n};\n\nconst getRequestOwnerEmails = (models, requestId, cb) => {\n\tlet demandEmails, supplyEmails, supplyUserId, demandUserId, request, order, task;\n\n\tconst setEmails = (user, emails) => {\n\t\tif (user.userType === 1) {\n\t\t\tdemandUserId = user.id;\n\t\t\tdemandEmails = emails;\n\t\t}\n\n\t\tif (user.userType === 2) {\n\t\t\tsupplyUserId = user.id;\n\t\t\tsupplyEmails = emails;\n\t\t}\n\t};\n\n\treturn async.waterfall([cb => models.request.findOne({\n\t\twhere: {\n\t\t\tid: requestId\n\t\t},\n\t\tinclude: [{ model: models.user, as: \"fromUser\" }, { model: models.user, as: \"toUser\" }, { model: models.task, as: \"task\" }]\n\t}).then(rRequest => {\n\t\tif (!rRequest) {\n\t\t\treturn cb({ code: \"REQUEST_NOT_FOUND\", requestId });\n\t\t}\n\n\t\trequest = rRequest;\n\t\ttask = rRequest.task;\n\n\t\treturn cb();\n\t}, cb), cb => {\n\t\tgetOrderFromRequest(models, requestId, (err, rOrder) => {\n\t\t\tif (err) {\n\t\t\t\treturn cb(err);\n\t\t\t}\n\n\t\t\torder = rOrder;\n\n\t\t\treturn cb();\n\t\t});\n\t}, cb => vqAuth.getEmailsFromUserId(models, request.fromUser.vqUserId, (err, rUserEmails) => {\n\t\tif (err) {\n\t\t\treturn cb(err);\n\t\t}\n\n\t\tconst emails = rUserEmails.map(_ => _.email);\n\n\t\tsetEmails(request.fromUser, emails);\n\n\t\tcb();\n\t}), cb => vqAuth.getEmailsFromUserId(models, request.toUser.vqUserId, (err, rUserEmails) => {\n\t\tif (err) {\n\t\t\treturn cb(err);\n\t\t}\n\n\t\tconst emails = rUserEmails.map(_ => _.email);\n\n\t\tsetEmails(request.toUser, emails);\n\n\t\tcb();\n\t})], err => {\n\t\tcb(err, {\n\t\t\trequest,\n\t\t\torder,\n\t\t\ttask,\n\t\t\tsupplyEmails,\n\t\t\tdemandEmails,\n\t\t\tsupplyUserId,\n\t\t\tdemandUserId\n\t\t});\n\t});\n};\n\nconst requestEventHandlerFactory = (emailCode, actionUrlFn) => {\n\treturn (models, requestId) => {\n\t\tlet request, order, task;\n\t\tlet demandEmails, supplyEmails, supplyUserId, demandUserId;\n\t\tlet emailData = {};\n\n\t\tasync.waterfall([cb => getRequestOwnerEmails(models, requestId, (err, data) => {\n\t\t\tif (err) {\n\t\t\t\treturn cb(err);\n\t\t\t}\n\n\t\t\tsupplyUserId = data.supplyUserId;\n\t\t\tdemandUserId = data.demandUserId;\n\t\t\tdemandEmails = data.demandEmails;\n\t\t\tsupplyEmails = data.supplyEmails;\n\t\t\torder = data.order;\n\t\t\trequest = data.request;\n\t\t\ttask = data.task;\n\n\t\t\treturn cb();\n\t\t}), cb => models.appConfig.findOne({\n\t\t\twhere: {\n\t\t\t\tfieldKey: \"DOMAIN\"\n\t\t\t}\n\t\t}).then(configField => {\n\t\t\tconfigField = configField || {};\n\n\t\t\tconst domain = configField.fieldValue || \"http://localhost:3000\";\n\n\t\t\tconst ACTION_URL = actionUrlFn(domain, requestId, order ? order.id : undefined, 1);\n\t\t\tconst SUPPLY_ACTION_URL = actionUrlFn(domain, requestId, order ? order.id : undefined, 2);\n\n\t\t\temailData.ACTION_URL = ACTION_URL;\n\t\t\temailData.SUPPLY_ACTION_URL = SUPPLY_ACTION_URL;\n\n\t\t\temailData.LISTING_TITLE = task.title;\n\n\t\t\tcb();\n\t\t}, cb)], err => {\n\t\t\tif (err) {\n\t\t\t\treturn console.error(err);\n\t\t\t}\n\n\t\t\t// its handled by other events already\n\t\t\tif (emailCode === \"request-marked-as-done\") {\n\t\t\t\tif (supplyEmails) {\n\t\t\t\t\temailService.checkIfShouldSendEmail(models, emailCode, supplyUserId, () => emailService.sendEmailsOnEvent(models, emailCode, [], supplyEmails, emailData));\n\t\t\t\t}\n\n\t\t\t\tif (demandEmails) {\n\t\t\t\t\temailService.checkIfShouldSendEmail(models, emailCode, demandUserId, () => emailService.sendEmailsOnEvent(models, emailCode, demandEmails, [], emailData));\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// its handled by other events already\n\t\t\tif (emailCode === \"request-completed\") {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// supply listings, we ignore it, clean it up with the new approach!\n\t\t\tif ((emailCode === \"request-closed\" || emailCode === \"request-declined\" || emailCode === \"request-cancelled\" || emailCode === \"task-request-cancelled\") && Number(task.taskType) === 2) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\temailService.checkIfShouldSendEmail(models, emailCode, request.userId, () => emailService.getEmailAndSend(models, emailCode, supplyEmails, emailData));\n\t\t});\n\t};\n};\n\nrequestEmitter.on(\"message-received\", (models, messageId) => {\n\tlet message;\n\n\tconst emailData = {};\n\n\tasync.waterfall([cb => models.message.findOne({\n\t\twhere: {\n\t\t\tid: messageId\n\t\t},\n\t\tinclude: [{ model: models.task }, { model: models.user, as: \"toUser\" }, { model: models.user, as: \"fromUser\" }]\n\t}).then(rMessage => {\n\t\tmessage = rMessage;\n\n\t\temailData.SENDER_FIRST_NAME = message.fromUser.firstName;\n\t\temailData.SENDER_LAST_NAME = message.fromUser.lastName;\n\t\temailData.LISTING_TITLE = message.task.title;\n\n\t\tcb();\n\t}, cb), cb => {\n\t\tvqAuth.getEmailsFromUserId(models, message.toUser.vqUserId, (err, rUserEmails) => {\n\t\t\tif (err) {\n\t\t\t\treturn cb(err);\n\t\t\t}\n\n\t\t\tconst emails = rUserEmails.map(_ => _.email);\n\n\t\t\tmodels.appConfig.findOne({\n\t\t\t\twhere: {\n\t\t\t\t\tfieldKey: \"DOMAIN\"\n\t\t\t\t}\n\t\t\t}).then(configField => {\n\t\t\t\tconfigField = configField || {};\n\n\t\t\t\tconst domain = configField.fieldValue || \"http://localhost:3000\";\n\n\t\t\t\tconst ACTION_URL = `${domain}/app/chat/${message.requestId}`;\n\n\t\t\t\temailData.ACTION_URL = ACTION_URL;\n\n\t\t\t\temailService.checkIfShouldSendEmail(models, \"message-received\", message.toUser.id, () => emailService.getEmailAndSend(models, \"message-received\", emails[0], emailData));\n\t\t\t}, cb);\n\t\t});\n\t}], err => {\n\t\tif (err) {\n\t\t\tconsole.error(err);\n\t\t}\n\t});\n});\n\nrequestEmitter.on(\"request-accepted\", requestEventHandlerFactory(\"request-accepted\", (domain, requestId) => `${domain}/app/chat/${requestId}`));\n\nrequestEmitter.on(\"request-completed\", requestEventHandlerFactory(\"request-completed\", (domain, requestId) => `${domain}/app/request/${requestId}/review`));\n\nrequestEmitter.on(\"closed\", requestEventHandlerFactory(\"request-closed\", (domain, requestId) => `${domain}/app/request/${requestId}/review`));\n\nrequestEmitter.on(\"request-declined\", requestEventHandlerFactory(\"request-declined\", domain => `${domain}/app`));\n\nrequestEmitter.on(\"request-cancelled\", requestEventHandlerFactory(\"request-cancelled\", domain => `${domain}/app`));\n\nrequestEmitter.on(\"request-marked-as-done\", requestEventHandlerFactory(\"request-marked-as-done\", domain => `${domain}/app/dashboard`));\n\nrequestEmitter.on(\"new-request\", (models, requestId) => {\n\tvar request;\n\tvar requestSentEmails;\n\tvar requestReceivedEmails;\n\tvar ACTION_URL;\n\n\tasync.waterfall([cb => models.request.findOne({\n\t\twhere: {\n\t\t\tid: requestId\n\t\t},\n\t\tinclude: [{ model: models.task }, { model: models.user, as: \"fromUser\" }, { model: models.user, as: \"toUser\" }]\n\t}).then(rRequest => {\n\t\trequest = rRequest;\n\n\t\t/**\n   * We do not send emails for supply listings.\n   */\n\t\tif (Number(request.task.taskType) === 2) {\n\t\t\treturn cb({\n\t\t\t\tskip: true\n\t\t\t});\n\t\t}\n\n\t\treturn cb();\n\t}, cb), cb => vqAuth.getEmailsFromUserId(models, request.fromUser.vqUserId, (err, rUserEmails) => {\n\t\tif (err) {\n\t\t\treturn cb(err);\n\t\t}\n\n\t\trequestSentEmails = rUserEmails.map(_ => _.email);\n\n\t\tcb();\n\t}), cb => vqAuth.getEmailsFromUserId(models, request.toUser.vqUserId, (err, rUserEmails) => {\n\t\tif (err) {\n\t\t\treturn cb(err);\n\t\t}\n\n\t\trequestReceivedEmails = rUserEmails.map(_ => _.email);\n\n\t\tcb();\n\t}), cb => models.appConfig.findOne({\n\t\twhere: {\n\t\t\tfieldKey: \"DOMAIN\"\n\t\t}\n\t}).then(configField => {\n\t\tconfigField = configField || {};\n\n\t\tconst domain = configField.fieldValue || \"http://localhost:3000\";\n\n\t\tACTION_URL = `${domain}/app/chat/${requestId}`;\n\n\t\tcb();\n\t}, cb)], err => {\n\t\tif (err) {\n\t\t\tif (err.skip) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\treturn console.error(err);\n\t\t}\n\n\t\tif (requestReceivedEmails) {\n\t\t\temailService.checkIfShouldSendEmail(models, emailService.EMAILS.REQUEST_RECEIVED, request.toUser.id, () => emailService.getEmailAndSend(models, emailService.EMAILS.REQUEST_RECEIVED, requestReceivedEmails, {\n\t\t\t\tACTION_URL,\n\t\t\t\tLISTING_TITLE: request.task.title\n\t\t\t}));\n\t\t}\n\n\t\tif (requestSentEmails) {\n\t\t\temailService.checkIfShouldSendEmail(models, emailService.EMAILS.REQUEST_SENT, request.fromUser.id, () => emailService.getEmailAndSend(models, emailService.EMAILS.REQUEST_SENT, requestSentEmails, {\n\t\t\t\tACTION_URL,\n\t\t\t\tLISTING_TITLE: request.task.title\n\t\t\t}));\n\t\t}\n\t});\n});\n\nmodule.exports = requestEmitter;\n\n//# sourceURL=webpack:///./src/app/events/request.js?");

/***/ }),

/***/ "./src/app/events/review.js":
/*!**********************************!*\
  !*** ./src/app/events/review.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\nconst async = __webpack_require__(/*! async */ \"async\");\nconst models = __webpack_require__(/*! ../models/models */ \"./src/app/models/models.ts\");\nconst emailService = __webpack_require__(/*! ../services/emailService.js */ \"./src/app/services/emailService.js\");\nconst vqAuth = __webpack_require__(/*! ../auth */ \"./src/app/auth/index.ts\");\n\nclass DefaultEmitter extends EventEmitter {}\n\nconst reviewEmitter = new DefaultEmitter();\n\nconst getReviewOwnerEmails = (models, reviewId, cb) => {\n    let fromUserEmails, toUserEmails, review;\n\n    return async.waterfall([cb => models.review.findOne({\n        where: {\n            id: reviewId\n        },\n        include: [{ model: models.user, as: \"fromUser\" }, { model: models.user, as: \"toUser\" }]\n    }).then(rReview => {\n        review = rReview;\n\n        return cb();\n    }, cb), cb => vqAuth.getEmailsFromUserId(models, review.fromUser.vqUserId, (err, rUserEmails) => {\n        if (err) {\n            return cb(err);\n        }\n\n        fromUserEmails = rUserEmails.map(_ => _.email);\n\n        cb();\n    }), cb => vqAuth.getEmailsFromUserId(models, review.toUser.vqUserId, (err, rUserEmails) => {\n        if (err) {\n            return cb(err);\n        }\n\n        toUserEmails = rUserEmails.map(_ => _.email);\n\n        cb();\n    })], err => {\n        cb(err, {\n            review,\n            toUserEmails,\n            fromUserEmails\n        });\n    });\n};\n\nconst reviewEventHandlerFactory = (emailCode, actionUrlFn) => {\n    return (models, reviewId) => {\n        var review;\n        var fromUserEmails, toUserEmails;\n        var ACTION_URL;\n\n        async.waterfall([cb => getReviewOwnerEmails(models, reviewId, (err, data) => {\n            if (err) {\n                return cb(err);\n            }\n\n            fromUserEmails = data.fromUserEmails;\n            toUserEmails = data.toUserEmails;\n            review = data.review;\n\n            return cb();\n        }), cb => {\n            cb();\n\n            models.review.findAll({\n                where: {\n                    toUserId: review.toUserId\n                }\n            }).then(userReviews => {\n                const reviewsNo = userReviews.length;\n                const avgReviewRate = userReviews.reduce((sum, review) => {\n                    return sum += Number(review.rate);\n                }, 0) / reviewsNo;\n\n                models.user.update({\n                    avgReviewRate\n                }, {\n                    where: {\n                        id: review.toUserId\n                    }\n                }).then(() => {}, err => console.error(err));\n            }, err => console.error(err));\n        }, cb => models.appConfig.findOne({\n            where: {\n                fieldKey: \"DOMAIN\"\n            }\n        }).then(configField => {\n            configField = configField || {};\n\n            const domain = configField.fieldValue || \"http://localhost:3000\";\n\n            ACTION_URL = actionUrlFn(domain, review.toUser.id);\n\n            cb();\n        }, cb)], err => {\n            if (err) {\n                return console.error(err);\n            }\n\n            emailService.checkIfShouldSendEmail(models, emailCode, review.toUser.id, () => emailService.getEmailAndSend(models, emailCode, toUserEmails, {\n                ACTION_URL\n            }));\n        });\n    };\n};\n\nreviewEmitter.on(\"review-left\", reviewEventHandlerFactory(\"review-left\", (domain, userId) => `${domain}/app/profile/${userId}`));\n\nmodule.exports = reviewEmitter;\n\n//# sourceURL=webpack:///./src/app/events/review.js?");

/***/ }),

/***/ "./src/app/events/task.js":
/*!********************************!*\
  !*** ./src/app/events/task.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const EventEmitter = __webpack_require__(/*! events */ \"events\");\nconst async = __webpack_require__(/*! async */ \"async\");\nconst emailService = __webpack_require__(/*! ../services/emailService */ \"./src/app/services/emailService.js\");\nconst randomstring = __webpack_require__(/*! randomstring */ \"randomstring\");\nconst vqAuth = __webpack_require__(/*! ../auth */ \"./src/app/auth/index.ts\");\n\nclass DefaultEmitter extends EventEmitter {}\nconst taskEmitter = new DefaultEmitter();\n\nconst getDomainName = (models, cb) => {\n    models.appConfig.findOne({\n        where: {\n            fieldKey: \"DOMAIN\"\n        }\n    }).then(configField => {\n        configField = configField || {};\n\n        const domain = configField.fieldValue || \"http://localhost:3000\";\n\n        return cb(null, domain);\n    }, cb);\n};\n\nconst handlerFactory = emailCode => (models, task) => {\n    emailService.checkIfShouldSendEmail(models, emailCode, task.userId, () => {\n        models.user.findById(task.userId).then(user => {\n            if (!user) {\n                return console.error(\"USER_NOT_FOUND\");\n            }\n\n            vqAuth.getEmailsFromUserId(models, user.vqUserId, (err, rUserEmails) => {\n                if (err) {\n                    return console.error(err);\n                }\n\n                const emails = rUserEmails.map(_ => _.email);\n\n                getDomainName(models, (err, domain) => {\n                    if (err) {\n                        return console.error(err);\n                    }\n\n                    let ACTION_URL;\n\n                    if (emailCode === \"task-request-cancelled\") {\n                        ACTION_URL = `${domain}/app/task/${task.id}`;\n                    } else {\n                        ACTION_URL = `${domain}/app/new-listing`;\n                    }\n\n                    emailService.getEmailAndSend(models, emailCode, emails, {\n                        ACTION_URL,\n                        LISTING_TITLE: task.title\n                    });\n                });\n            });\n        }, err => console.error(err));\n    });\n};\n\ntaskEmitter.on(\"marked-spam\", handlerFactory(\"task-marked-spam\"));\n\ntaskEmitter.on(\"task-request-cancelled\", handlerFactory(\"task-request-cancelled\"));\n\ntaskEmitter.on(\"new-task\", (models, taskId) => {\n    if (!taskId) {\n        return console.error(\"TASK_NOT_FOUND\");\n    }\n\n    var taskCategory, userPreferences;\n    var emailData = {};\n    const userEmails = [];\n\n    async.waterfall([cb => {\n        models.taskCategory.findOne({\n            where: {\n                taskId\n            }\n        }).then(rTaskCategory => {\n            taskCategory = rTaskCategory;\n\n            cb();\n        }, cb);\n    }, cb => {\n        models.userPreference.findAll({\n            where: {\n                value: taskCategory.code\n            }\n        }).then(rUserPreferences => {\n            userPreferences = rUserPreferences;\n\n            cb();\n        }, cb);\n    }, cb => {\n        getDomainName(models, (err, domain) => {\n            if (err) {\n                return cb(err);\n            }\n\n            emailData.ACTION_URL = `${domain}/app/task/${taskId}`;\n\n            cb();\n        });\n    }, cb => {\n        async.eachSeries(userPreferences, (userPreference, cb) => {\n            const userId = userPreference.userId;\n\n            models.user.findById(userId).then(user => {\n                // in case of data inconsensities\n                if (!user) {\n                    console.error(`user ${userId} could not be found but there is a preference to him`);\n\n                    return cb();\n                }\n\n                emailService.checkIfShouldSendEmail(models, emailService.EMAILS.NEW_LISTING, userId, () => vqAuth.getEmailsFromUserId(models, user.vqUserId, (err, rUserEmails) => {\n                    if (err) {\n                        console.error(err);\n\n                        return cb();\n                    }\n\n                    const emails = rUserEmails.forEach(_ => {\n                        userEmails.push(_.email);\n                    });\n\n                    cb();\n                }), () => {\n                    cb();\n                });\n            }, err => {\n                console.error(err);\n\n                cb();\n            });\n        }, () => {\n            emailService.getEmailAndSend(models, emailService.EMAILS.NEW_LISTING, userEmails, emailData);\n\n            console.log(\"New task emails have been sent!\");\n        });\n    }]);\n});\n\ntaskEmitter.on(\"cancelled\", handlerFactory(\"listing-cancelled\"));\n\nmodule.exports = taskEmitter;\n\n//# sourceURL=webpack:///./src/app/events/task.js?");

/***/ }),

/***/ "./src/app/events/user.js":
/*!********************************!*\
  !*** ./src/app/events/user.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\nconst randtoken = __webpack_require__(/*! rand-token */ \"rand-token\");\nconst emailService = __webpack_require__(/*! ../services/emailService */ \"./src/app/services/emailService.js\");\nconst cryptoService = __webpack_require__(/*! ../services/cryptoService */ \"./src/app/services/cryptoService.js\");\nclass DefaultEmitter extends EventEmitter {}\nconst userEmitter = new DefaultEmitter();\nconst vqAuth = __webpack_require__(/*! ../auth */ \"./src/app/auth/index.ts\");\n\nmodule.exports = userEmitter;\nuserEmitter.on(\"created\", (models, user) => {\n    const VERIFICATION_LINK = cryptoService.buildVerificationUrl(models.tenantId, user);\n\n    return emailService.getEmailAndSend(models, emailService.EMAILS.WELCOME, user.emails[0], {\n        VERIFICATION_LINK\n    });\n});\n\nuserEmitter.on(\"blocked\", (models, user) => {\n    vqAuth.getEmailsFromUserId(models, user.vqUserId, (err, rUserEmails) => {\n        if (err) {\n            return console.error(err);\n        }\n\n        const emails = rUserEmails.map(_ => _.email);\n\n        emailService.getEmailAndSend(models, \"user-blocked\", emails, {});\n    });\n});\n\n//# sourceURL=webpack:///./src/app/events/user.js?");

/***/ }),

/***/ "./src/app/models/models.ts":
/*!**********************************!*\
  !*** ./src/app/models/models.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(__dirname) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst async = __webpack_require__(/*! async */ \"async\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst mysql = __webpack_require__(/*! mysql2 */ \"mysql2\");\nconst Sequelize = __webpack_require__(/*! sequelize */ \"sequelize\");\n__webpack_require__(/*! dotenv */ \"dotenv\").config();\nconst tenantRegister = {};\nconst tenantConnections = {};\nconst getTenantIds = () => Object.keys(tenantConnections);\nconst createSeqConnection = (tenantId) => {\n    const db = {};\n    const sequelize = new Sequelize(tenantId, process.env.VQ_DB_USER, process.env.VQ_DB_PASSWORD, {\n        host: process.env.VQ_DB_HOST,\n        logging: false,\n        dialect: \"mysql\",\n        pool: {\n            max: 1,\n            min: 0,\n            idle: 10000\n        }\n    });\n    fs.readdirSync(__dirname)\n        .filter((file) => {\n        return (file.indexOf(\".\") !== 0) && (file !== \"models.js\");\n    })\n        .forEach((file) => {\n        var model = sequelize.import(path.join(__dirname, file));\n        db[model.name] = model;\n    });\n    Object.keys(db).forEach(modelName => {\n        if (\"associate\" in db[modelName]) {\n            db[modelName].associate(db);\n        }\n    });\n    db.tenantId = tenantId;\n    db.seq = sequelize;\n    db.Sequelize = Sequelize;\n    return db;\n};\nconst refreshTenantRegister = tenantId => {\n    tenantRegister[tenantId] = {\n        established: Date.now() / 1000\n    };\n};\nconst create = (tenantId, marketplaceType, cb) => {\n    console.log(`[models] Creating tenant model: ${tenantId}`);\n    if (tenantConnections[tenantId]) {\n        return cb({\n            httpCode: 400,\n            code: \"TENANT_ALREADY_DEPLOYED\"\n        });\n    }\n    var isNewDatabase = false;\n    async.waterfall([\n        cb => {\n            const connection = mysql.createConnection({\n                host: process.env.VQ_DB_HOST,\n                user: process.env.VQ_DB_USER,\n                password: process.env.VQ_DB_PASSWORD\n            });\n            connection.connect();\n            connection.query(\"CREATE DATABASE ?? CHARACTER SET utf8 COLLATE utf8_general_ci;\", [tenantId], (err) => {\n                if (err) {\n                    if (err.code === \"ER_DB_CREATE_EXISTS\") {\n                        return cb();\n                    }\n                    return cb(err);\n                }\n                isNewDatabase = true;\n                cb();\n            });\n            connection.end();\n        },\n        cb => {\n            tenantConnections[tenantId] = createSeqConnection(tenantId);\n            refreshTenantRegister(tenantId);\n            cb();\n        },\n        cb => {\n            const models = tenantConnections[tenantId];\n            models.seq.sync().then(() => {\n                cb();\n            }, cb);\n        },\n        cb => {\n            if (!isNewDatabase) {\n                return cb();\n            }\n            console.log(\"INITIALIZING...\");\n            const models = tenantConnections[tenantId];\n            async.waterfall([\n                cb => {\n                    models.appConfig.insertSeed(marketplaceType, err => {\n                        if (err) {\n                            console.error(err);\n                        }\n                        cb();\n                    });\n                },\n                cb => {\n                    models.appLabel.insertSeed(marketplaceType, \"en\", err => {\n                        if (err) {\n                            console.error(err);\n                        }\n                        cb();\n                    });\n                },\n                cb => {\n                    models.post.insertSeed(marketplaceType, err => {\n                        if (err) {\n                            console.error(err);\n                        }\n                        cb();\n                    });\n                },\n                cb => {\n                    models.appUserProperty.insertSeed(marketplaceType, err => {\n                        if (err) {\n                            console.error(err);\n                        }\n                        cb();\n                    });\n                },\n            ], (err) => {\n                // we delete the object not to waste the sql connection\n                tenantConnections[tenantId].seq.close();\n                delete tenantConnections[tenantId];\n                console.log(`Completed for ${tenantId}`);\n                cb(err);\n            });\n        }\n    ], cb);\n};\nconst get = tenantId => {\n    if (!tenantRegister[tenantId]) {\n        return undefined;\n    }\n    refreshTenantRegister(tenantId);\n    if (tenantConnections[tenantId]) {\n        return tenantConnections[tenantId];\n    }\n    tenantConnections[tenantId] = createSeqConnection(tenantId);\n    return tenantConnections[tenantId];\n};\nmodule.exports = {\n    tenantRegister,\n    tenantConnections,\n    refreshTenantRegister,\n    create,\n    get,\n    getTenantIds\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, \"/\"))\n\n//# sourceURL=webpack:///./src/app/models/models.ts?");

/***/ }),

/***/ "./src/app/routes.js":
/*!***************************!*\
  !*** ./src/app/routes.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = app => {\n\tapp.get(\"/\", (req, res) => res.send(\"VQ is up and running\"));\n\n\t// admin\n\t__webpack_require__(/*! ./routes/admin */ \"./src/app/routes/admin.js\")(app);\n\t__webpack_require__(/*! ./routes/post.js */ \"./src/app/routes/post.js\")(app);\n\n\t// config\n\t__webpack_require__(/*! ./routes/app_label */ \"./src/app/routes/app_label.js\")(app);\n\t__webpack_require__(/*! ./routes/app_config */ \"./src/app/routes/app_config.js\")(app);\n\t__webpack_require__(/*! ./routes/app_task_category */ \"./src/app/routes/app_task_category.js\")(app);\n\t__webpack_require__(/*! ./routes/app_user_property */ \"./src/app/routes/app_user_property.js\")(app);\n\n\t// end-user\n\t__webpack_require__(/*! ./routes/message */ \"./src/app/routes/message.js\")(app);\n\t__webpack_require__(/*! ./routes/policy */ \"./src/app/routes/policy.ts\")(app);\n\t__webpack_require__(/*! ./routes/payment */ \"./src/app/routes/payment.ts\")(app);\n\t__webpack_require__(/*! ./routes/user */ \"./src/app/routes/user.js\")(app);\n\t__webpack_require__(/*! ./routes/user-preference */ \"./src/app/routes/user-preference.js\")(app);\n\t__webpack_require__(/*! ./routes/user-property */ \"./src/app/routes/user-property.js\")(app);\n\t__webpack_require__(/*! ./routes/upload */ \"./src/app/routes/upload.js\")(app);\n\t__webpack_require__(/*! ./routes/task */ \"./src/app/routes/task.js\")(app);\n\t__webpack_require__(/*! ./routes/request */ \"./src/app/routes/request.js\")(app);\n\t__webpack_require__(/*! ./routes/billing_address */ \"./src/app/routes/billing_address.js\")(app);\n\t__webpack_require__(/*! ./routes/order */ \"./src/app/routes/order.js\")(app);\n\t__webpack_require__(/*! ./routes/review */ \"./src/app/routes/review.js\")(app);\n\t__webpack_require__(/*! ./routes/vq-services */ \"./src/app/routes/vq-services.js\")(app);\n};\n\n//# sourceURL=webpack:///./src/app/routes.js?");

/***/ }),

/***/ "./src/app/routes/admin.js":
/*!*********************************!*\
  !*** ./src/app/routes/admin.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const resCtrl = __webpack_require__(/*! ../controllers/responseController.js */ \"./src/app/controllers/responseController.js\");\nconst async = __webpack_require__(/*! async */ \"async\");\nconst vqAuth = __webpack_require__(/*! ../auth */ \"./src/app/auth/index.ts\");\nconst isLoggedIn = resCtrl.isLoggedIn;\nconst isAdmin = resCtrl.isAdmin;\nconst hasValidSubscription = resCtrl.hasValidSubscription;\nconst sendResponse = resCtrl.sendResponse;\nconst requestCtrl = __webpack_require__(/*! ../controllers/requestCtrl */ \"./src/app/controllers/requestCtrl.ts\");\nconst userEmitter = __webpack_require__(/*! ../events/user */ \"./src/app/events/user.js\");\nconst taskEmitter = __webpack_require__(/*! ../events/task */ \"./src/app/events/task.js\");\nconst tenantModelsProvider = __webpack_require__(/*! ../../app-tenant/tenantModelsProvider */ \"./src/app-tenant/tenantModelsProvider.ts\");\nconst subscriptionService = __webpack_require__(/*! ../services/subscriptionService */ \"./src/app/services/subscriptionService.js\");\n\nmodule.exports = app => {\n\tapp.get(\"/api/subscription/plans\", (req, res) => {\n\t\tsubscriptionService.listPlans((err, plans) => {\n\t\t\tif (err) {\n\t\t\t\treturn res.status(400).send(err);\n\t\t\t}\n\n\t\t\treturn res.status(200).send(plans);\n\t\t});\n\t});\n\n\tapp.post(\"/api/admin/new-subscription/:subId\", isLoggedIn, isAdmin, (req, res) => {\n\t\ttenantModelsProvider.getTenant({ tenantId: req.models.tenantId }, (err, tenantRef) => {\n\t\t\tif (err) {\n\t\t\t\treturn res.status(400).send(err);\n\t\t\t}\n\n\t\t\tsubscriptionService.chargebeeNewSubCheckout(req.params.subId, tenantRef, (err, result) => {\n\t\t\t\tif (err) {\n\t\t\t\t\treturn res.status(400).send(result);\n\t\t\t\t}\n\n\t\t\t\tres.send(result);\n\t\t\t});\n\t\t});\n\t});\n\n\tapp.post(\"/api/admin/subscription-portal\", isLoggedIn, isAdmin, (req, res) => {\n\t\ttenantModelsProvider.getTenant({ tenantId: req.models.tenantId }, (err, tenantRef) => {\n\t\t\tif (err) {\n\t\t\t\treturn res.status(400).send(err);\n\t\t\t}\n\n\t\t\tsubscriptionService.chargebeeCustomerPortalSignIn(tenantRef, (err, result) => {\n\t\t\t\tif (err) {\n\t\t\t\t\treturn res.status(400).send(result);\n\t\t\t\t}\n\n\t\t\t\tres.send(result);\n\t\t\t});\n\t\t});\n\t});\n\n\tapp.get(\"/api/admin/tenant\", isLoggedIn, isAdmin, (req, res) => {\n\t\ttenantModelsProvider.getTenant({ tenantId: req.models.tenantId }, (err, tenant) => {\n\t\t\tif (err) {\n\t\t\t\treturn res.status(400).send(err);\n\t\t\t}\n\n\t\t\treturn res.send({\n\t\t\t\ttenant\n\t\t\t});\n\t\t});\n\t});\n\n\tapp.get(\"/api/admin/report\", isLoggedIn, isAdmin, hasValidSubscription, (req, res) => req.models.report.findAll({\n\t\tdistinct: \"reportName\",\n\t\torder: [[\"createdAt\", \"DESC\"]]\n\t}).then(data => res.send(data)));\n\n\tapp.get(\"/api/admin/user\", isLoggedIn, isAdmin, hasValidSubscription, (req, res) => req.models.user.findAll({\n\t\tparanoid: false,\n\t\torder: [[\"createdAt\", \"DESC\"]],\n\t\tlimit: Number(req.query.limit) || 20,\n\t\toffset: Number(req.query.offset) || 0,\n\t\tinclude: [{ model: req.models.userProperty }, { model: req.models.userPreference }]\n\t}).then(data => res.send(data), err => {\n\t\tconsole.error(err);\n\n\t\tres.status(400).send(err);\n\t}));\n\n\tapp.get(\"/api/admin/user/:userId/emails\", isLoggedIn, isAdmin, hasValidSubscription, (req, res) => {\n\t\tconst userId = req.params.userId;\n\n\t\treq.models.user.findOne({\n\t\t\twhere: {\n\t\t\t\tid: userId\n\t\t\t},\n\t\t\tparanoid: false\n\t\t}).then(user => {\n\t\t\tif (!user) {\n\t\t\t\treturn res.status(404).send(\"NOT_FOUND\");\n\t\t\t}\n\n\t\t\tvqAuth.getEmailsFromUserId(req.models, user.vqUserId, (err, rUserEmails) => {\n\t\t\t\tif (err) {\n\t\t\t\t\treturn res.status(400).send(err);\n\t\t\t\t}\n\n\t\t\t\tconst emails = rUserEmails.map(_ => _.email);\n\n\t\t\t\tres.status(200).send(emails);\n\t\t\t});\n\t\t}, err => res.status(500).send(err));\n\t});\n\n\tapp.get(\"/api/admin/request\", isLoggedIn, isAdmin, hasValidSubscription, (req, res) => req.models.request.findAll({\n\t\torder: [[\"createdAt\", \"DESC\"]],\n\t\tinclude: [{ model: req.models.task }, { model: req.models.user, as: \"fromUser\" }, { model: req.models.review }, {\n\t\t\tmodel: req.models.order,\n\t\t\tas: \"order\",\n\t\t\tinclude: [{\n\t\t\t\tmodel: req.models.review\n\t\t\t}, {\n\t\t\t\tmodel: req.models.billingAddress\n\t\t\t}]\n\t\t}]\n\t}).then(data => res.send(data)));\n\n\tapp.get(\"/api/admin/request/:requestId/messages\", isLoggedIn, isAdmin, hasValidSubscription, (req, res) => req.models.message.findAll({\n\t\torder: [[\"createdAt\", \"DESC\"]],\n\t\tinclude: [\n\t\t// { model: req.models.task },\n\t\t{ model: req.models.user, as: \"fromUser\" }],\n\t\twhere: {\n\t\t\trequestId: req.params.requestId\n\t\t}\n\t}).then(data => {\n\t\treturn res.send(data);\n\t}, err => {\n\t\treturn res.status(400).send(err);\n\t}));\n\n\tapp.get(\"/api/admin/task\", isLoggedIn, isAdmin, hasValidSubscription, (req, res) => req.models.task.findAll({\n\t\torder: [[\"createdAt\", \"DESC\"]],\n\t\tinclude: [{\n\t\t\tmodel: req.models.request,\n\t\t\tinclude: [{\n\t\t\t\tmodel: req.models.order\n\t\t\t}]\n\t\t}]\n\t}).then(data => res.send(data)));\n\n\tapp.put(\"/api/admin/task/:taskId/spam\", isLoggedIn, isAdmin, hasValidSubscription, (req, res) => {\n\t\treq.models.task.findById(req.params.taskId).then(task => {\n\t\t\tif (!task) {\n\t\t\t\treturn sendResponse(res, \"NOT_FOUND\");\n\t\t\t}\n\n\t\t\tif (task.status !== req.models.task.TASK_STATUS.ACTIVE) {\n\t\t\t\treturn sendResponse(res, {\n\t\t\t\t\tcode: \"TASK_IS_NOT_ACTIVE\"\n\t\t\t\t});\n\t\t\t}\n\n\t\t\ttask.update({\n\t\t\t\tstatus: req.models.task.TASK_STATUS.SPAM\n\t\t\t});\n\n\t\t\ttaskEmitter.emit(\"marked-spam\", req.models, task);\n\n\t\t\ttask.getRequests().then(requests => {\n\t\t\t\trequests.forEach(request => {\n\t\t\t\t\trequestCtrl.declineRequest(req.models, request.id, err => console.error(err));\n\t\t\t\t});\n\n\t\t\t\tsendResponse(res, null, task);\n\t\t\t}, err => console.error(err));\n\t\t}, err => sendResponse(res, err));\n\t});\n\n\tapp.delete(\"/api/admin/user/:userId/verifications\", isLoggedIn, isAdmin, hasValidSubscription, (req, res) => {\n\t\treq.models.userProperty.destroy({\n\t\t\twhere: {\n\t\t\t\t$and: [{ userId: req.params.userId }, {\n\t\t\t\t\t$or: [{ propKey: \"studentIdUrl\" }, { propKey: \"studentIdBackUrl\" }]\n\t\t\t\t}]\n\t\t\t}\n\t\t}).then(() => {\n\t\t\tsendResponse(res, null, { ok: 200 });\n\t\t}, err => sendResponse(res, err));\n\t});\n\n\tapp.get(\"/api/admin/order\", isLoggedIn, isAdmin, hasValidSubscription, (req, res) => req.models.order.findAll({\n\t\torder: [[\"createdAt\", \"DESC\"]],\n\t\tinclude: [{ model: req.models.task }, { model: req.models.user }, { model: req.models.request }]\n\t}).then(data => res.send(data)));\n\n\tapp.put(\"/api/admin/user/:userId/block\", isLoggedIn, isAdmin, hasValidSubscription, (req, res) => {\n\t\tconst userId = req.params.userId;\n\n\t\treq.models.user.findById(req.params.userId).then(user => {\n\t\t\tif (!user) {\n\t\t\t\treturn sendResponse(res, \"NOT_FOUND\");\n\t\t\t}\n\n\t\t\treq.models.request.findOne({\n\t\t\t\twhere: {\n\t\t\t\t\t$and: [{\n\t\t\t\t\t\t$or: [{ fromUserId: userId }, { toUserId: userId }]\n\t\t\t\t\t}, {\n\t\t\t\t\t\t$or: [{ status: req.models.request.REQUEST_STATUS.ACCEPTED }, { status: req.models.request.REQUEST_STATUS.MARKED_DONE }]\n\t\t\t\t\t}]\n\t\t\t\t}\n\t\t\t}).then(outstandingRequest => {\n\t\t\t\tif (outstandingRequest) {\n\t\t\t\t\treturn sendResponse(res, {\n\t\t\t\t\t\tcode: \"CANNOT_BLOCK_USER_HAS_OUTSTANDING_REQUESTS\"\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tconsole.log(\"[ADMIN] Blocking user.\");\n\n\t\t\t\tuser.update({\n\t\t\t\t\tstatus: req.models.user.USER_STATUS.BLOCKED\n\t\t\t\t});\n\n\t\t\t\tconsole.log(\"[ADMIN] Setting active tasks of the blocked user to INACTIVE.\");\n\t\t\t\treq.models.task.findAll({\n\t\t\t\t\twhere: {\n\t\t\t\t\t\t$and: [{\n\t\t\t\t\t\t\tuserId\n\t\t\t\t\t\t}, {\n\t\t\t\t\t\t\t$or: [{\n\t\t\t\t\t\t\t\tstatus: req.models.task.TASK_STATUS.CREATION_IN_PROGRESS\n\t\t\t\t\t\t\t}, {\n\t\t\t\t\t\t\t\tstatus: req.models.task.TASK_STATUS.ACTIVE\n\t\t\t\t\t\t\t}]\n\t\t\t\t\t\t}]\n\t\t\t\t\t}\n\t\t\t\t}).then(activeTasks => {\n\t\t\t\t\tasync.eachSeries(activeTasks, (activeTask, cb) => {\n\t\t\t\t\t\tactiveTask.update({\n\t\t\t\t\t\t\tstatus: req.models.task.TASK_STATUS.INACTIVE\n\t\t\t\t\t\t}).then(_ => {\n\t\t\t\t\t\t\trequestCtrl.declineAllPendingRequestsForTask(req.models, activeTask.id, err => {\n\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\treturn cb(err);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tconsole.log(`[SUCCESS] All pending requests for task ${activeTask.id} have been declined!`);\n\n\t\t\t\t\t\t\t\tcb();\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}, cb);\n\t\t\t\t\t}, err => {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\treturn console.error(err);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\n\t\t\t\tconsole.log(\"[ADMIN] Setting pending request to the blocked user to DECLINED.\");\n\t\t\t\treq.models.request.update({\n\t\t\t\t\tstatus: req.models.request.REQUEST_STATUS.DECLINED\n\t\t\t\t}, {\n\t\t\t\t\twhere: {\n\t\t\t\t\t\t$and: [{\n\t\t\t\t\t\t\ttoUserId: userId\n\t\t\t\t\t\t}, {\n\t\t\t\t\t\t\t$or: [{\n\t\t\t\t\t\t\t\tstatus: req.models.request.REQUEST_STATUS.PENDING\n\t\t\t\t\t\t\t}]\n\t\t\t\t\t\t}]\n\t\t\t\t\t}\n\t\t\t\t}).then(_ => _, err => {\n\t\t\t\t\tconsole.error(err);\n\t\t\t\t});\n\n\t\t\t\tconsole.log(\"[ADMIN] Setting pending request to the blocked user to CANCELED.\");\n\t\t\t\treq.models.request.update({\n\t\t\t\t\tstatus: req.models.request.REQUEST_STATUS.CANCELED\n\t\t\t\t}, {\n\t\t\t\t\twhere: {\n\t\t\t\t\t\t$and: [{\n\t\t\t\t\t\t\tfromUserId: userId\n\t\t\t\t\t\t}, {\n\t\t\t\t\t\t\t$or: [{\n\t\t\t\t\t\t\t\tstatus: req.models.request.REQUEST_STATUS.PENDING\n\t\t\t\t\t\t\t}]\n\t\t\t\t\t\t}]\n\t\t\t\t\t}\n\t\t\t\t}).then(_ => _, err => {\n\t\t\t\t\tconsole.error(err);\n\t\t\t\t});\n\n\t\t\t\tsendResponse(res, null, user);\n\n\t\t\t\tuserEmitter.emit(\"blocked\", req.models, user);\n\t\t\t});\n\t\t}, err => sendResponse(res, err));\n\t});\n\n\tapp.put(\"/api/admin/user/:userId/unblock\", isLoggedIn, isAdmin, hasValidSubscription, (req, res) => {\n\t\treq.models.user.update({\n\t\t\tstatus: req.models.user.USER_STATUS.VERIFIED\n\t\t}, {\n\t\t\twhere: {\n\t\t\t\tid: req.params.userId\n\t\t\t}\n\t\t}).then(data => sendResponse(res, null, data), err => sendResponse(res, err));\n\t});\n};\n\n//# sourceURL=webpack:///./src/app/routes/admin.js?");

/***/ }),

/***/ "./src/app/routes/app_config.js":
/*!**************************************!*\
  !*** ./src/app/routes/app_config.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const responseController = __webpack_require__(/*! ../controllers/responseController.js */ \"./src/app/controllers/responseController.js\");\nconst isAdmin = responseController.isAdmin;\n\nmodule.exports = app => {\n    app.get(\"/api/app_config\", (req, res) => req.models.appConfig.findAll({\n        order: [\"fieldKey\"]\n    }).then(configs => {\n        const resConfigs = JSON.parse(JSON.stringify(configs));\n\n        // Never ever send it down.\n        let STRIPE_PRIVATE_KEY = resConfigs.find(_ => _.fieldKey === \"STRIPE_PRIVATE_KEY\");\n\n        if (STRIPE_PRIVATE_KEY) STRIPE_PRIVATE_KEY.fieldValue = \"XXXXXXXXXXXXXXXXXXXXXXXX\";\n\n        res.send(resConfigs);\n    }, err => res.status(400).send(err)));\n\n    app.post(\"/api/app_config\", isAdmin, (req, res) => {\n        const labels = req.body || [];\n\n        req.models.appConfig.bulkCreateOrUpdate(labels, true, err => {\n            if (err) {\n                return res.status(400).send(err);\n            }\n\n            res.send({\n                ok: true\n            });\n        });\n    });\n};\n\n//# sourceURL=webpack:///./src/app/routes/app_config.js?");

/***/ }),

/***/ "./src/app/routes/app_label.js":
/*!*************************************!*\
  !*** ./src/app/routes/app_label.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const async = __webpack_require__(/*! async */ \"async\");\nconst models = __webpack_require__(/*! ../models/models */ \"./src/app/models/models.ts\");\nconst responseController = __webpack_require__(/*! ../controllers/responseController.js */ \"./src/app/controllers/responseController.js\");\nconst isAdmin = responseController.isAdmin;\n\nmodule.exports = app => {\n    app.get(\"/api/app_label\", (req, res) => {\n        const lang = req.query.lang;\n\n        if (lang) {\n            return req.models.appLabel.findAll({\n                where: {\n                    lang\n                }, order: [\"labelKey\"]\n            }).then(labels => res.send(labels), err => res.status(400).send(err));\n        }\n\n        res.status(400).send(\"Specify language\");\n    });\n\n    app.post(\"/api/app_label\", isAdmin, (req, res) => {\n        const labels = req.body || [];\n\n        const forceUpdate = true;\n\n        req.models.appLabel.bulkCreateOrUpdate(labels, forceUpdate, err => {\n            if (err) {\n                return res.status(400).send(err);\n            }\n\n            res.send({\n                ok: true\n            });\n        });\n    });\n};\n\n//# sourceURL=webpack:///./src/app/routes/app_label.js?");

/***/ }),

/***/ "./src/app/routes/app_task_category.js":
/*!*********************************************!*\
  !*** ./src/app/routes/app_task_category.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const async = __webpack_require__(/*! async */ \"async\");\nconst responseController = __webpack_require__(/*! ../controllers/responseController */ \"./src/app/controllers/responseController.js\");\nconst taskCtrl = __webpack_require__(/*! ../controllers/taskCtrl */ \"./src/app/controllers/taskCtrl.ts\");\n\nconst isAdmin = responseController.isAdmin;\n\nmodule.exports = app => {\n    app.get(\"/api/app_task_categories\", (req, res) => req.models.appTaskCategory.findAll({\n        order: [\"label\"]\n    }).then(data => res.status(200).send(data)).catch(err => res.status(400).send(err)));\n\n    app.post(\"/api/app_task_categories\", isAdmin, (req, res) => {\n        const category = {\n            code: req.body.code,\n            label: req.body.label,\n            desc: req.body.desc || undefined,\n            minPriceHour: req.body.minPriceHour || 0,\n            bigImageUrl: req.body.bigImageUrl || undefined,\n            imageUrl: req.body.imageUrl || undefined,\n            unitOfMeasure: req.body.unitOfMeasure || undefined,\n            minQuantity: req.body.minQuantity || undefined,\n            maxQuantity: req.body.maxQuantity || undefined,\n            quantityStep: req.body.quantityStep || undefined\n        };\n\n        req.models.appTaskCategory.create(category).then(data => res.status(200).send(data)).catch(err => res.status(400).send(err));\n    });\n\n    app.put(\"/api/app_task_categories/:id\", isAdmin, (req, res) => {\n        const id = req.params.id;\n        const category = {\n            code: req.body.code,\n            status: req.body.status,\n            label: req.body.label,\n            desc: req.body.desc,\n            minPriceHour: req.body.minPriceHour,\n            bigImageUrl: req.body.bigImageUrl,\n            imageUrl: req.body.imageUrl\n        };\n\n        if (category.status && category.status === req.models.appTaskCategory.TASK_CATEGORY_STATUS.INACTIVE) {\n            let appTaskCategory;\n            const tasksOfCategory = [];\n\n            return async.waterfall([cb => {\n                req.models.appTaskCategory.findOne({\n                    where: {\n                        id\n                    }\n                }).then(rAppTaskCategory => {\n                    appTaskCategory = rAppTaskCategory;\n\n                    cb();\n                }, cb);\n            }, cb => {\n                taskCtrl.cancelAllUnbookedTasks(req.models, appTaskCategory.code, err => {\n                    if (err) {\n                        console.error(err);\n                        cb(err);\n                    }\n\n                    console.log(`[SUCCESS] All tasks for category '${appTaskCategory.code}' have been cancelled along with their requests!`);\n                    cb();\n                });\n            }, cb => {\n                req.models.appTaskCategory.update(category, {\n                    where: { id }\n                }).then(data => cb(undefined, data), cb);\n            }], (err, result) => {\n                if (err) {\n                    return res.status(400).send(err);\n                }\n\n                return res.status(200).send(result);\n            });\n        }\n\n        return req.models.appTaskCategory.update(category, {\n            where: { id }\n        }).then(data => res.status(200).send(data)).catch(err => res.status(400).send(err));\n    });\n\n    app.delete(\"/api/app_task_categories/:id\", isAdmin, (req, res) => {\n        res.status(200).send({});\n\n        req.models.appTaskCategory.destroy({\n            where: {\n                id: req.params.id\n            }\n        });\n    });\n};\n\n//# sourceURL=webpack:///./src/app/routes/app_task_category.js?");

/***/ }),

/***/ "./src/app/routes/app_user_property.js":
/*!*********************************************!*\
  !*** ./src/app/routes/app_user_property.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const models = __webpack_require__(/*! ../models/models */ \"./src/app/models/models.ts\");\n\nmodule.exports = app => {\n    app.get(\"/api/app_user_property\", (req, res) => req.models.appUserProperty.findAll({ order: [\"propKey\"] }).then(data => res.status(200).send(data)).catch(err => res.status(400).send(err)));\n};\n\n//# sourceURL=webpack:///./src/app/routes/app_user_property.js?");

/***/ }),

/***/ "./src/app/routes/billing_address.js":
/*!*******************************************!*\
  !*** ./src/app/routes/billing_address.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const responseController = __webpack_require__(/*! ../controllers/responseController */ \"./src/app/controllers/responseController.js\");\nconst isLoggedIn = responseController.isLoggedIn;\nconst sendResponse = responseController.sendResponse;\nconst RESOURCE = \"billing_address\";\n\nmodule.exports = app => {\n    app.post(`/api/${RESOURCE}`, isLoggedIn, (req, res) => {\n        const userId = req.user.id;\n        const billingAddress = req.body;\n\n        billingAddress.userId = userId;\n\n        req.models.billingAddress.findOne({\n            where: {\n                $and: [{ userId }, { default: true }]\n            }\n        }).then(defaultBillingAddress => {\n            if (!defaultBillingAddress) {\n                billingAddress.default = true;\n            }\n\n            return req.models.billingAddress.create(billingAddress).then(data => sendResponse(res, null, data));\n        }, err => sendResponse(res, err));\n    });\n\n    app.put(`/api/${RESOURCE}/:${RESOURCE}_id`, isLoggedIn, (req, res) => {\n        const userId = req.user.id;\n        const billingAddressId = req.params.billing_address_id;\n        const billingAddress = req.body;\n\n        billingAddress.userId = userId;\n\n        req.models.billingAddress.findOne({\n            where: {\n                $and: [{ id: billingAddressId }, { userId }]\n            }\n        }).then(rBillingAddress => {\n            delete billingAddress.userId;\n            delete billingAddress.id;\n            delete billingAddress.createdAt;\n            delete billingAddress.updatedAt;\n\n            rBillingAddress.update(billingAddress).then(data => sendResponse(res, null, data), err => sendResponse(res, err));\n        }, err => sendResponse(res, err));\n    });\n\n    app.get(`/api/${RESOURCE}`, isLoggedIn, (req, res) => {\n        const userId = req.user.id;\n\n        const andCondition = [{ userId }];\n\n        if (req.query.default) {\n            andCondition.push({ default: true });\n        }\n\n        req.models.billingAddress.findAll({\n            where: {\n                $and: andCondition\n            }\n        }).then(billingAddresses => sendResponse(res, null, billingAddresses)).catch(err => sendResponse(res, err));\n    });\n};\n\n//# sourceURL=webpack:///./src/app/routes/billing_address.js?");

/***/ }),

/***/ "./src/app/routes/message.js":
/*!***********************************!*\
  !*** ./src/app/routes/message.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var async = __webpack_require__(/*! async */ \"async\");\nvar responseController = __webpack_require__(/*! ../controllers/responseController */ \"./src/app/controllers/responseController.js\");\nvar EmailService = __webpack_require__(/*! ../services/emailService */ \"./src/app/services/emailService.js\");\nconst _ = __webpack_require__(/*! underscore */ \"underscore\");\n\nvar isLoggedIn = responseController.isLoggedIn;\n\nconst requestEmitter = __webpack_require__(/*! ../events/request.js */ \"./src/app/events/request.js\");\nconst models = __webpack_require__(/*! ../models/models */ \"./src/app/models/models.ts\");\n\nmodule.exports = app => {\n\n    /**\n     * Send message\n     */\n    app.post(\"/api/request/:requestId/message\", isLoggedIn, (req, res) => {\n        let message = String(req.body.message);\n\n        try {\n            message = message.split(\"<p><br></p>\").filter(_ => _ !== \"<p><br></p>\").join(\"\").replace(/(\\r\\n|\\n|\\r)/gm, \"\");\n        } catch (err) {\n            console.error(err);\n\n            message = \"\";\n        }\n\n        if (!message || message.length === 0) {\n            return res.status(400).send(\"EMPTY_MESSAGE\");\n        }\n\n        req.models.message.create({\n            requestId: req.params.requestId,\n            taskId: req.body.taskId,\n            fromUserId: req.user.id,\n            toUserId: req.body.toUserId,\n            message\n        }).then(rMessage => {\n\n            requestEmitter.emit(\"message-received\", req.models, rMessage.id);\n\n            return res.send(rMessage);\n        }, err => res.status(400).send(err));\n    });\n\n    const getMessages = (models, userId, requestId, groupBy) => new Promise((resolve, reject) => {\n        const $orArr = [{ fromUserId: userId }, { toUserId: userId }];\n        const $andArr = [{ $or: $orArr }];\n\n        if (requestId) {\n            $andArr.push({\n                requestId: Number(requestId)\n            });\n        }\n\n        const where = {\n            $and: $andArr\n        };\n\n        if (requestId) {\n            $andArr.push({\n                $and: [{ requestId: Number(requestId) }]\n            });\n        }\n\n        models.message.findAll({\n            where,\n            order: [[\"createdAt\", \"DESC\"]]\n        }).then(messages => {\n            if (groupBy) {\n                messages = _.groupBy(messages, groupBy);\n            }\n\n            return resolve(messages);\n        }, reject);\n    });\n\n    app.get(\"/api/message\", isLoggedIn, (req, res) => getMessages(req.models, req.user.id, req.query.request_id, req.query.group_by).then(data => res.send(data), err => res.status(400).send(err)));\n\n    /**\n     * Gets message exchange for an application\n     */\n    app.get(\"/api/request/:requestId\", isLoggedIn, (req, res) => {\n        const requestId = Number(req.params.requestId);\n        const result = {\n            users: {}\n        };\n        var request;\n\n        async.waterfall([callback => req.models.request.findOne({\n            where: {\n                id: requestId\n            },\n            include: [{\n                model: req.models.order,\n                include: [{\n                    model: req.models.review\n                }]\n            }, {\n                model: req.models.review\n            }, {\n                model: req.models.user,\n                as: \"fromUser\"\n            }, {\n                model: req.models.user,\n                as: \"toUser\"\n            }]\n        }).then(rRequest => {\n            if (!rRequest) {\n                return callback({\n                    code: \"REQUEST_NOT_FOUND\",\n                    httpCode: 400,\n                    desc: \"Request not found\"\n                });\n            }\n\n            request = rRequest;\n\n            result.request = request;\n\n            callback();\n        }, callback), callback => getMessages(req.models, req.user.id, requestId).then(messages => {\n            result.messages = messages;\n\n            return callback();\n        }), callback => req.models.user.findOne({\n            where: {\n                id: result.request.fromUserId\n            }\n        }).then(user => {\n            result.users[result.request.fromUser.id] = user;\n\n            return callback();\n        }), callback => req.models.user.findOne({\n            where: {\n                id: result.request.toUserId\n            }\n        }).then(user => {\n            result.users[result.request.toUserId] = user;\n\n            return callback();\n        }), callback => {\n            req.models.task.findOne({\n                where: {\n                    id: request.taskId\n                },\n                include: [{ model: req.models.taskTiming }, { model: req.models.taskLocation }]\n            }).then(task => {\n                result.task = task;\n\n                return callback();\n            }, err => callback(err));\n        }, callback => getMessages(req.models, req.user.id, requestId).then(messages => {\n            result.messages = messages;\n\n            return callback();\n        })], err => responseController.sendResponse(res, err, result));\n    });\n};\n\n//# sourceURL=webpack:///./src/app/routes/message.js?");

/***/ }),

/***/ "./src/app/routes/order.js":
/*!*********************************!*\
  !*** ./src/app/routes/order.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const async = __webpack_require__(/*! async */ \"async\");\nconst responseController = __webpack_require__(/*! ../controllers/responseController */ \"./src/app/controllers/responseController.js\");\nconst stripeProvider = __webpack_require__(/*! ../../shared-providers/stripe */ \"./src/shared-providers/stripe.ts\");\nconst isLoggedIn = responseController.isLoggedIn;\nconst sendResponse = responseController.sendResponse;\nconst orderEmitter = __webpack_require__(/*! ../events/order */ \"./src/app/events/order.js\");\nconst requestEmitter = __webpack_require__(/*! ../events/request */ \"./src/app/events/request.js\");\nconst orderCtrl = __webpack_require__(/*! ../controllers/orderCtrl */ \"./src/app/controllers/orderCtrl.js\");\nconst requestCtrl = __webpack_require__(/*! ../controllers/requestCtrl */ \"./src/app/controllers/requestCtrl.ts\");\nconst RESOURCE = \"order\";\n\nmodule.exports = app => {\n\n    /**\n     * Order can only be created from a request sent to supply or demand listing.\n     * Orders can only by created by Demand Users.\n     * A request can only be booked once!\n     */\n    app.post(`/api/${RESOURCE}`, isLoggedIn, (req, res) => {\n        let createdOrder, requestRef, taskRef, userPaymentAccount, stripePrivateKey, paymentsEnabledConfig;\n        const order = req.body;\n\n        order.userId = req.user.id;\n        order.status = req.models.order.ORDER_STATUS.PENDING;\n\n        async.waterfall([\n        // gets the request\n        cb => orderCtrl.tryGetPaymentConfigs(req.models, (err, paymentConfigs) => {\n            if (err) {\n                return cb(err);\n            }\n\n            paymentsEnabledConfig = paymentConfigs.paymentsEnabledConfig;\n            stripePrivateKey = paymentConfigs.stripePrivateKeyConfig;\n\n            cb();\n        }), cb => req.models.task.findById(order.taskId).then(rTask => {\n            taskRef = rTask;\n\n            cb();\n        }, cb),\n\n        // gets the request\n        cb => req.models.request.findById(order.requestId).then(rRequest => {\n            requestRef = rRequest;\n\n            if (requestRef.status !== req.models.request.REQUEST_STATUS.PENDING) {\n                return cb({\n                    httpCode: 400,\n                    code: \"WRONG_REQUEST_STATUS\"\n                });\n            }\n\n            cb();\n        }, cb),\n\n        // gets payment account of the supplier\n        cb => {\n            if (!paymentsEnabledConfig || paymentsEnabledConfig.fieldValue !== \"1\") {\n                return cb();\n            }\n\n            const DEMAND_TASK_TYPE_CODE = 1;\n\n            const supplyUserId = taskRef.taskType === DEMAND_TASK_TYPE_CODE ? requestRef.fromUserId : requestRef.toUserId;\n\n            req.models.userPaymentAccount.findOne({\n                where: {\n                    $and: [{ userId: supplyUserId }, { networkId: \"stripe\" }]\n                }\n            }).then(rUserPaymentAccount => {\n                if (!rUserPaymentAccount) {\n                    return cb({\n                        httpCode: 400,\n                        code: \"NO_SUPPLY_PAYMENT_ACCOUNT\"\n                    });\n                }\n\n                userPaymentAccount = rUserPaymentAccount;\n\n                cb();\n            }, cb);\n        },\n\n        // creating initial order\n        cb => req.models.order.create(order).then(rCreatedOrder => {\n            createdOrder = rCreatedOrder;\n\n            cb();\n        }, cb), cb => {\n            if (!paymentsEnabledConfig || paymentsEnabledConfig.fieldValue !== \"1\") {\n                return cb();\n            }\n\n            let provisionConfig, paymentObjectCard, charge;\n\n            async.waterfall([cb => {\n                req.models.paymentObject.findOne({\n                    where: {\n                        $and: [{ userId: req.user.id }, { provider: \"stripe\" }, { type: \"card\" }]\n                    }\n                }).then(rPaymentObjectCard => {\n                    if (!rPaymentObjectCard) {\n                        return cb({\n                            httpCode: 400,\n                            code: \"NO_PAYMENT_METHOD\"\n                        });\n                    }\n\n                    paymentObjectCard = rPaymentObjectCard;\n\n                    cb();\n                }, cb);\n            }, cb => {\n                const platformFeeRelative = Number(provisionConfig.fieldValue) / 100 || 0;\n                const totalAmount = createdOrder.currency === \"HUF\" ? createdOrder.amount : createdOrder.amount * 100;\n\n                const platformFees = Math.floor(totalAmount * platformFeeRelative);\n\n                let amountToBeTransferred = totalAmount - platformFees;\n\n                const chargeData = {\n                    capture: false,\n                    amount: totalAmount,\n                    currency: createdOrder.currency,\n                    description: `\"${taskRef.title}\" - BookingId: ${createdOrder.id}, UserId: ${req.user.id}, RequestId: ${createdOrder.requestId}`,\n                    source: paymentObjectCard.obj.id,\n                    destination: {\n                        amount: amountToBeTransferred,\n                        account: userPaymentAccount.accountId\n                    },\n                    metadata: {\n                        orderId: createdOrder.id,\n                        requestId: createdOrder.requestId,\n                        userId: req.user.id\n                    }\n                };\n\n                console.log(\"Creating StripeCharge\");\n                console.log(chargeData);\n\n                stripeProvider.getTenantStripe(stripePrivateKey.fieldValue).charges.create(chargeData, (err, rCharge) => {\n                    if (err) {\n                        return cb({\n                            code: \"PAYMENT_ERROR\",\n                            err\n                        });\n                    }\n\n                    charge = rCharge;\n\n                    cb();\n                });\n            }, cb => {\n                req.models.paymentObject.create({\n                    userId: req.user.id,\n                    orderId: createdOrder.id,\n                    provider: \"stripe\",\n                    type: \"charge\",\n                    obj: charge\n                }).then(() => {\n                    return cb();\n                }, cb);\n            }], cb);\n        }, cb => requestRef.update({\n            status: req.models.request.REQUEST_STATUS.ACCEPTED\n        }).then(() => cb(), cb),\n\n        /**\n         * @configure-it start\n         * THIS FUNCTIONALITY NEEDS TO BE REVIEWED AND MADE CONFIGURABLE WHEN WE SUPPORT NEW USECASES\n         * Right now we cover:\n         * A) applications (taskrabbit, click4work)\n         * B) instant rental bookings (airbnb, rentkitchen)\n         */\n\n        cb => {\n            // @todo: this needs to be made configurable!\n\n            /**\n             * Request handling for DEMAND (1) Listings\n             * All other requests are declined.\n             */\n            if (Number(taskRef.taskType) === 1) {\n                requestCtrl.declineAllPendingRequestsForTask(req.models, order.taskId, cb);\n            }\n\n            /**\n              * Request handling for SUPPLY (2) Listings\n              * All other requests remain until declined manually or listing deactived.\n              */\n            if (Number(taskRef.taskType) === 2) {\n                cb();\n            }\n        }, cb => {\n            /**\n              * Task handling for DEMAND (1) Listings\n              * Task is marked as booked and removed from the pool of active listings.\n              */\n            if (Number(taskRef.taskType) === 1) {\n                return req.models.task.update({\n                    status: req.models.task.TASK_STATUS.BOOKED\n                }, {\n                    where: {\n                        id: order.taskId\n                    }\n                }).then(() => cb(), cb);\n            }\n\n            /**\n              * Task handling for SUPPLY (1) Listings\n              * Task remains in the pool of active listings\n              */\n            if (Number(taskRef.taskType) === 2) {\n                return cb();\n            }\n        }\n        /**\n         * @configure-it end\n         */\n        ], err => {\n            if (err) {\n                return sendResponse(res, err);\n            }\n\n            sendResponse(res, null, createdOrder);\n\n            // this goes to demand user\n            orderEmitter.emit(\"new-order\", req.models, createdOrder.id);\n\n            // this goes to supplier\n            if (Number(taskRef.taskType) === 1) {\n                requestEmitter.emit(\"request-accepted\", req.models, createdOrder.requestId);\n            }\n        });\n    });\n\n    app.get(`/api/${RESOURCE}/:${RESOURCE}Id`, isLoggedIn, (req, res) => {\n        const orderId = req.params.orderId;\n        const userId = req.user.id;\n        const where = {\n            $and: [{ userId }, { id: orderId }]\n        };\n\n        req.models.order.findOne({\n            where,\n            include: [{\n                model: req.models.user\n            }, {\n                model: req.models.request,\n                include: [{ model: req.models.user, as: \"fromUser\" }, { model: req.models.user, as: \"toUser\" }]\n            }, {\n                model: req.models.task\n            }, {\n                model: req.models.review\n            }]\n        }).then(order => {\n            if (!order) {\n                return sendResponse(res, {\n                    code: \"ORDER_NOT_FOUND\"\n                });\n            }\n\n            return sendResponse(res, null, order);\n        }, err => {\n            sendResponse(res, err);\n        });\n    });\n\n    app.get(`/api/${RESOURCE}`, isLoggedIn, (req, res) => {\n        const userId = req.user.id;\n        const where = {\n            $and: [{ userId }]\n        };\n\n        if (req.query.view === \"in_progress\") {\n            where.$and.push({\n                $or: [{ status: req.models.order.ORDER_STATUS.PENDING }, { status: req.models.order.ORDER_STATUS.MARKED_DONE }]\n            });\n        }\n\n        if (req.query.view === \"completed\") {\n            where.$and.push({\n                $or: [{\n                    status: req.models.order.ORDER_STATUS.SETTLED\n                }, {\n                    status: req.models.order.ORDER_STATUS.CLOSED\n                }]\n            });\n        }\n\n        req.models.order.findAll({\n            where,\n            include: [{\n                model: req.models.user\n            }, {\n                model: req.models.request\n            }, {\n                model: req.models.task,\n                include: [{\n                    model: req.models.taskLocation\n                }, {\n                    model: req.models.taskTiming\n                }]\n            }, {\n                model: req.models.review\n            }]\n        }).then(orders => {\n            orders = orders.filter(order => order.request);\n\n            async.eachLimit(orders, 3, (order, cb) => {\n                const fromUserId = order.request.fromUserId;\n                const task = order.task;\n\n                async.parallel([cb => req.models.taskCategory.findAll({\n                    where: {\n                        taskId: task.id\n                    }\n                }).then(categories => {\n                    task.dataValues.categories = categories;\n\n                    return cb();\n                }, cb), cb => req.models.user.findOne({\n                    where: {\n                        id: fromUserId\n                    },\n                    include: [{\n                        model: req.models.userProperty\n                    }]\n                }).then(user => {\n                    order = order.dataValues;\n                    order.fromUser = user.dataValues;\n\n                    return cb();\n                }, cb)], err => {\n                    if (err) {\n                        return cb(err);\n                    }\n\n                    return cb();\n                });\n            }, err => {\n                sendResponse(res, err, orders);\n            });\n        }).catch(err => sendResponse(res, err));\n    });\n\n    app.put(\"/api/order/:orderId/actions/close\", isLoggedIn, (req, res) => {\n        const orderId = req.params.orderId;\n        const userId = req.user.id;\n\n        req.models.order.findOne({\n            where: {\n                $and: [{\n                    id: orderId\n                }, {\n                    userId\n                }, {\n                    $or: [{\n                        status: req.models.order.ORDER_STATUS.MARKED_DONE\n                    }, {\n                        status: req.models.order.ORDER_STATUS.PENDING\n                    }]\n                }]\n            }\n        }).then(order => {\n            if (!order) {\n                return sendResponse(res, {\n                    code: \"NOT_FOUND\"\n                });\n            }\n\n            req.models.request.update({\n                autoSettlementStartedAt: null,\n                status: req.models.request.REQUEST_STATUS.CLOSED\n            }, {\n                where: {\n                    id: order.requestId\n                }\n            }).then(() => {\n                requestEmitter.emit(\"closed\", req.models, order.requestId);\n\n                order.update({\n                    status: req.models.order.ORDER_STATUS.CLOSED\n                }).then(() => {\n                    orderEmitter.emit(\"closed\", req.models, order.id);\n\n                    sendResponse(res, null, {\n                        ok: \"ok\"\n                    });\n                }, err => sendResponse(res, err));\n            }, err => sendResponse(res, err));\n        });\n    });\n\n    app.put(\"/api/order/:orderId/actions/cancel-autosettlement\", isLoggedIn, (req, res) => {\n        const orderId = req.params.orderId;\n        const userId = req.user.id;\n\n        req.models.order.update({\n            autoSettlementStartedAt: null\n        }, {\n            where: {\n                $and: [{\n                    id: orderId\n                }, {\n                    userId\n                }]\n            }\n        }).then(() => {\n            sendResponse(res, null, { ok: \"ok\" });\n        }, err => sendResponse(res, err));\n    });\n\n    /**\n     * Settles the order and the underlying request\n     */\n    app.put(\"/api/order/:orderId\", isLoggedIn, (req, res) => {\n        const orderId = req.params.orderId;\n\n        orderCtrl.settleOrder(req.models, orderId, req.user.id, (err, order) => sendResponse(res, err, order));\n    });\n};\n\n//# sourceURL=webpack:///./src/app/routes/order.js?");

/***/ }),

/***/ "./src/app/routes/payment.ts":
/*!***********************************!*\
  !*** ./src/app/routes/payment.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/// <reference types=\"express-serve-static-core\" />\n/// <reference types=\"serve-static\" />\nconst async = __webpack_require__(/*! async */ \"async\");\nconst stripeProvider = __webpack_require__(/*! ../../shared-providers/stripe */ \"./src/shared-providers/stripe.ts\");\nconst responseController = __webpack_require__(/*! ../controllers/responseController.js */ \"./src/app/controllers/responseController.js\");\nconst isLoggedIn = responseController.isLoggedIn;\nconst isAdmin = responseController.isAdmin;\nconst tenantDb = __webpack_require__(/*! ../../app-tenant/models */ \"./src/app-tenant/models/index.js\");\nlet STRIPE_OAUTH_URL = \"https://connect.stripe.com/oauth/authorize\";\nSTRIPE_OAUTH_URL += \"?response_type=code&scope=read_write&stripe_landing=register&state=*\";\nconst createAccount = (stripePrivateKey, type, country, email, cb) => {\n    stripeProvider\n        .getTenantStripe(stripePrivateKey)\n        .accounts\n        .create({\n        type,\n        country,\n        email\n    })\n        .then((rAccount) => {\n        console.log(rAccount);\n        cb(null, rAccount);\n    }, (err) => {\n        console.log(err);\n        cb(err);\n    });\n};\nmodule.exports = (app) => {\n    app.get(\"/api/payment-object/:provider/:objType/:objId\", isLoggedIn, (req, res) => {\n        /**\n         * Here we pass the call to the payment gateway to retrive details\n         */\n        switch (req.params.provider) {\n            case \"stripe\":\n                // @todo\n                break;\n            case \"barion\":\n                // @todo\n                break;\n            default:\n        }\n        res.send(\"NOT IMPLEMENTED YET\");\n    });\n    app.get(\"/api/payment-object/:paymentProvider/:objType\", isLoggedIn, (req, res) => {\n        req\n            .models\n            .paymentObject\n            .findAll({\n            where: {\n                $and: [\n                    { userId: req.user.id },\n                    { provider: req.params.paymentProvider },\n                    { type: req.params.objType }\n                ]\n            }\n        })\n            .then((data) => res.send(data), (err) => res.status(400).send(err));\n    });\n    app.post(\"/api/payment-object/:provider/:type\", isLoggedIn, (req, res) => {\n        async.waterfall([\n            (cb) => {\n                if (req.params.type !== \"card\") {\n                    return cb();\n                }\n                // for security reasons we destroy all previous card tokens, so they cannot be used anymore\n                req\n                    .models\n                    .paymentObject\n                    .destroy({\n                    where: {\n                        $and: [\n                            { type: \"card\" },\n                            { userId: req.user.id }\n                        ]\n                    }\n                })\n                    .then(() => {\n                    cb();\n                }, cb);\n            },\n            (cb) => {\n                req\n                    .models\n                    .paymentObject\n                    .create({\n                    orderId: req.body.orderId,\n                    userId: req.user.id,\n                    provider: req.params.provider,\n                    type: req.params.type,\n                    objId: req.body.objId,\n                    obj: req.body.obj\n                })\n                    .then((data) => cb(undefined, data), cb);\n            }\n        ], (err, data) => {\n            if (err) {\n                res.status(400).send(err);\n                return;\n            }\n            res.send(data);\n        });\n    });\n    app.get(\"/api/user/payment/account/:networkId\", isLoggedIn, (req, res) => {\n        const whereAndObj = [];\n        whereAndObj.push({\n            userId: req.user.id\n        });\n        if (req.params.networkId) {\n            whereAndObj.push({ networkId: req.params.networkId });\n        }\n        req\n            .models\n            .userPaymentAccount\n            .findOne({\n            where: {\n                $and: whereAndObj\n            }\n        })\n            .then((paymentAccount) => {\n            if (!paymentAccount) {\n                return res\n                    .status(400)\n                    .send({\n                    code: \"STRIPE_NOT_CONNECTED\"\n                });\n            }\n            // we map it and drop many attributes for security reasons!\n            const account = {\n                id: paymentAccount.id,\n                networkId: paymentAccount.networkId,\n                accountId: paymentAccount.accountId,\n            };\n            return res.send(account);\n        }, (err) => res.status(400).send(err));\n    });\n    /**\n     * Creates a Stripe account for Supply users.\n     */\n    app.post(\"/api/user/payment/account/:networkId\", isLoggedIn, (req, res) => {\n        const models = req.models;\n        let userRef;\n        let redirectUrl = STRIPE_OAUTH_URL.replace(\"*\", `${models.tenantId}@${req.user.id}`);\n        async.waterfall([\n            (cb) => {\n                models\n                    .user\n                    .findOne({\n                    where: {\n                        id: req.user.id\n                    },\n                    include: [\n                        {\n                            model: models.billingAddress\n                        }, {\n                            as: \"vqUser\",\n                            model: models.userAuth,\n                            include: [\n                                { model: models.userEmail }\n                            ]\n                        }\n                    ]\n                })\n                    .then((rUser) => {\n                    if (!rUser.billingAddresses.length) {\n                        return cb({\n                            code: \"MISSING_BILLING_INFORMATION\"\n                        });\n                    }\n                    userRef = rUser;\n                    cb();\n                }, cb);\n            },\n            (cb) => {\n                req\n                    .models\n                    .appConfig\n                    .findAll({\n                    where: {\n                        $or: [\n                            { fieldKey: \"STRIPE_CLIENT_ID\" },\n                            { fieldKey: \"STRIPE_PRIVATE_KEY\" },\n                            { fieldKey: \"STRIPE_PUBLIC_KEY\" }\n                        ]\n                    }\n                })\n                    .then((stripeConfigs) => {\n                    const stripePrivateKeyObj = stripeConfigs\n                        .find((_) => _.fieldKey === \"STRIPE_PRIVATE_KEY\");\n                    const stripeClientIdObj = stripeConfigs\n                        .find((_) => _.fieldKey === \"STRIPE_CLIENT_ID\");\n                    if ((!stripeClientIdObj || !stripeClientIdObj.fieldValue) ||\n                        (!stripePrivateKeyObj || !stripePrivateKeyObj.fieldValue)) {\n                        return cb({\n                            code: \"PAYMENTS_NOT_CONFIGURED\"\n                        });\n                    }\n                    redirectUrl += `&client_id=${stripeClientIdObj.fieldValue}`;\n                    cb(undefined, stripePrivateKeyObj.fieldValue);\n                }, cb);\n            },\n            (stripePrivateKey, cb) => {\n                createAccount(stripePrivateKey, \"standard\", userRef.billingAddresses[0].countryCode, userRef.vqUser.userEmails[0].email, (err, rAccount) => {\n                    if (err) {\n                        console.log(err);\n                        const resError = {\n                            code: \"STRIPE_ERROR\",\n                            desc: err.message,\n                            redirectUrl\n                        };\n                        if (err.type === \"StripeInvalidRequestError\") {\n                            return cb(resError);\n                        }\n                        return cb(resError);\n                    }\n                    cb(undefined, rAccount);\n                });\n            },\n            (rAccount, cb) => {\n                models\n                    .userPaymentAccount\n                    .create({\n                    userId: req.user.id,\n                    networkId: \"stripe\",\n                    accountId: rAccount.id,\n                    publicKey: rAccount.keys.publishable,\n                    secretKey: rAccount.keys.secret,\n                    data: rAccount // json object\n                })\n                    .then((createdAccount) => {\n                    const resAccount = {\n                        id: createdAccount.id,\n                        networkId: createdAccount.networkId,\n                        accountId: createdAccount.accountId\n                    };\n                    return cb(undefined, resAccount);\n                }, cb);\n            }\n        ], (err, resAccount) => {\n            if (err) {\n                return res.status(400).send(err);\n            }\n            return res.send(resAccount);\n        });\n    });\n};\n\n\n//# sourceURL=webpack:///./src/app/routes/payment.ts?");

/***/ }),

/***/ "./src/app/routes/policy.ts":
/*!**********************************!*\
  !*** ./src/app/routes/policy.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst async = __webpack_require__(/*! async */ \"async\");\nconst cust = __webpack_require__(/*! ../config/customizing.js */ \"./src/app/config/customizing.js\");\nconst emailService = __webpack_require__(/*! ../services/emailService.js */ \"./src/app/services/emailService.js\");\nconst cryptoService = __webpack_require__(/*! ../services/cryptoService */ \"./src/app/services/cryptoService.js\");\nconst responseController = __webpack_require__(/*! ../controllers/responseController.js */ \"./src/app/controllers/responseController.js\");\nconst sendResponse = responseController.sendResponse;\nconst vqAuth = __webpack_require__(/*! ../auth */ \"./src/app/auth/index.ts\");\nconst userEmitter = __webpack_require__(/*! ../events/user */ \"./src/app/events/user.js\");\nconst authCtrl = __webpack_require__(/*! ../controllers/authCtrl */ \"./src/app/controllers/authCtrl.ts\");\nmodule.exports = app => {\n    var isLoggedIn = responseController.isLoggedIn;\n    /**\n     * @api {get} /api/signup/email Create new account with e-mail\n     * @apiName Signup\n     * @apiGroup User\n     *\n     * @apiParam {String} email Users unique email.\n     * @apiParam {String} password User password\n     * @apiParam {String} repeatPassword Repeated user password for verification\n     * @apiParam {String} firstName First name of the User.\n     * @apiParam {String} firstName Last name of the User.\n     * @apiParam {String=\"0\", \"1\", \"2\"} userType User type (any, customer, supplier).\n     * @apiParam {Object} props User properties, fully extensible, [key: string]: string\n     *\n     * @apiSuccess {number} id Account ID (is not the same as the ID of the user!)\n     * @apiSuccess {String} token Authentification token can be saved for next requests\n     * @apiSuccess {User} user User object\n     */\n    app.post(\"/api/signup/email\", (req, res) => authCtrl.createNewAccount(req.models, req.body, (err, responseData) => responseController.sendResponse(res, err, responseData)));\n    app.post(\"/api/auth/reset-password\", (req, res) => {\n        const code = req.body.code;\n        const newPassword = req.body.newPassword;\n        const repeatNewPassword = req.body.repeatNewPassword;\n        if (newPassword !== repeatNewPassword) {\n            return sendResponse(res, { code: \"PASSWORDS_DO_NOT_MATCH\" });\n        }\n        vqAuth\n            .resetPassword(req.models, code, newPassword, err => sendResponse(res, err, { ok: true }));\n    });\n    app.post(\"/api/auth/request-password-reset\", (req, res) => {\n        const email = req.body.email;\n        vqAuth\n            .requestPasswordReset(req.models, email, (err, rUserResetCode) => {\n            if (err) {\n                console.error(err);\n                return sendResponse(res, err);\n            }\n            const resetCode = rUserResetCode.code;\n            req.models.appConfig\n                .findOne({\n                where: {\n                    fieldKey: \"DOMAIN\"\n                }\n            })\n                .then(configField => {\n                configField = configField || {};\n                const urlBase = configField.fieldValue || \"http://localhost:3000\";\n                const ACTION_URL = `${urlBase}/app/change-password?code=${resetCode}`;\n                emailService\n                    .getEmailAndSend(req.models, emailService.EMAILS.PASSWORD_RESET, [email], ACTION_URL);\n            }, err => console.error(err));\n            sendResponse(res, err, {});\n        });\n    });\n    app.post(\"/api/verify/resend-email\", isLoggedIn, (req, res) => {\n        var email = req.body.email;\n        var userId = req.body.userId;\n        var user;\n        var emails;\n        var vqUserId;\n        async.waterfall([\n            cb => {\n                if (userId) {\n                    return req.models.user\n                        .findById(userId)\n                        .then(rUser => {\n                        user = rUser;\n                        vqUserId = user.vqUserId;\n                        cb();\n                    }, cb);\n                }\n                vqAuth\n                    .getAuthUserIdFromEmail(req.models, email, (err, rUserEmail) => {\n                    if (err) {\n                        return cb(err);\n                    }\n                    vqUserId = rUserEmail.userId;\n                });\n            },\n            cb => {\n                if (email) {\n                    return cb();\n                }\n                vqAuth\n                    .getEmailsFromUserId(req.models, vqUserId, (err, rUserEmails) => {\n                    if (err) {\n                        return cb(err);\n                    }\n                    vqUserId = rUserEmails[0].userId;\n                    emails = rUserEmails.map(_ => _.email);\n                    req.models.user\n                        .findOne({\n                        vqUserId: vqUserId\n                    })\n                        .then(rUser => {\n                        user = rUser;\n                        cb();\n                    }, cb);\n                });\n            }\n        ], () => {\n            const VERIFICATION_LINK = cryptoService\n                .buildVerificationUrl(req.models.tenantId, { id: userId });\n            emailService\n                .getEmailAndSend(req.models, emailService.EMAILS.WELCOME, emails, {\n                VERIFICATION_LINK\n            });\n            res.send({\n                code: \"EMAIL_SENT\"\n            });\n        });\n    });\n    app.get(\"/api/verify/email\", (req, res) => {\n        var encryptedToken = req.query.code;\n        var user, userRef;\n        try {\n            encryptedToken = encryptedToken.split(\" \").join(\"+\");\n            user = cryptoService.decodeObj(encryptedToken);\n        }\n        catch (err) {\n            res.set(\"Content-Type\", \"text/html\");\n            res.status(400);\n            res.send(new Buffer(\"<p>Could not verify</p>\"));\n            return;\n        }\n        async.waterfall([\n            cb => {\n                req.models\n                    .user\n                    .findById(user.id)\n                    .then(rUser => {\n                    if (rUser.status === req.models.user.USER_STATUS.USER_BLOCKED) {\n                        return cb({\n                            httpCode: 401,\n                            code: \"USER_BLOCKED\"\n                        });\n                    }\n                    userRef = rUser;\n                    cb(null, rUser);\n                });\n            },\n            (rUser, cb) => {\n                if (rUser.status && rUser.status !== req.models.user.USER_STATUS.UNVERIFIED) {\n                    return cb({\n                        httpCode: 400,\n                        code: \"WRONG_USER_STATUS\"\n                    });\n                }\n                rUser\n                    .update({\n                    status: req.models.user.USER_STATUS.VERIFIED\n                })\n                    .then(_ => cb(), err => {\n                    return {\n                        err: err,\n                        httpCode: 400\n                    };\n                });\n            },\n            cb => {\n                req.models\n                    .appConfig\n                    .findOne({\n                    where: {\n                        fieldKey: \"DOMAIN\"\n                    }\n                })\n                    .then(configField => {\n                    cb(null, configField);\n                }, err => {\n                    return {\n                        err: err,\n                        httpCode: 400\n                    };\n                });\n            }\n        ], (err, configField) => {\n            if (err) {\n                res.set(\"Content-Type\", \"text/html\");\n                return res.send(new Buffer(`<p>This verification link is no longer valid.<span style=\"display:none;\">${err.code}</span></p>`));\n            }\n            if (!configField) {\n                res.set(\"Content-Type\", \"text/html\");\n                return res.send(new Buffer(\"<p>Missing configuration. Configure DOMAIN.</p>\"));\n            }\n            if (process.env.ENV.toLowerCase() !== 'production') {\n                return res.send({\n                    ok: true\n                });\n            }\n            if (userRef.userType === 1) {\n                return res.redirect(configField.fieldValue + \"/app/new-listing\");\n            }\n            return res.redirect(configField.fieldValue + \"/app/dashboard\");\n        });\n    });\n    app.post(\"/api/login\", (req, res) => {\n        var User;\n        var email = req.body.email;\n        var password = req.body.password;\n        async.waterfall([\n            cb => {\n                vqAuth\n                    .localLogin(req.models, email, password, (err, rUserToken) => {\n                    if (err) {\n                        return cb(err);\n                    }\n                    User = rUserToken;\n                    return cb();\n                });\n            },\n            cb => req.models.user\n                .findOne({\n                where: {\n                    vqUserId: User.userId\n                },\n                include: [\n                    {\n                        model: req.models.userProperty\n                    }, {\n                        model: req.models.userPreference\n                    }\n                ]\n            })\n                .then(rUser => {\n                if (!rUser) {\n                    return cb(cust.errorCodes.USER_NOT_FOUND);\n                }\n                User.user = rUser ? rUser.dataValues : null;\n                if (rUser.status == \"20\") {\n                    return cb(cust.errorCodes.USER_BLOCKED);\n                }\n                if (rUser.status !== req.models.user.USER_STATUS.VERIFIED) {\n                    return cb({\n                        token: User.token,\n                        user: User.user,\n                        err: cust.errorCodes.USER_NOT_VERIFIED\n                    });\n                }\n                return cb();\n            }, cb)\n        ], err => responseController\n            .sendResponse(res, err, User));\n    });\n    app.post(\"/api/auth/password\", isLoggedIn, (req, res) => {\n        var currentPassword = req.body.currentPassword;\n        var newPassword = req.body.newPassword;\n        vqAuth\n            .changePassword(req.models, req.user.vqUserId, currentPassword, newPassword, err => {\n            return responseController.sendResponse(res, err, { ok: true });\n        });\n    });\n    app.post(\"/api/logout\", (req, res) => {\n        // @todo destroy token!\n        res.status(200).send();\n    });\n};\n\n\n//# sourceURL=webpack:///./src/app/routes/policy.ts?");

/***/ }),

/***/ "./src/app/routes/post.js":
/*!********************************!*\
  !*** ./src/app/routes/post.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const resCtrl = __webpack_require__(/*! ../controllers/responseController.js */ \"./src/app/controllers/responseController.js\");\nconst isLoggedIn = resCtrl.isLoggedIn;\nconst isAdmin = resCtrl.isAdmin;\n\nmodule.exports = app => {\n    app.get(\"/api/post\", /* isLoggedIn, isAdmin, */(req, res) => req.models.post.findAll({\n        where: req.query\n    }).then(data => res.send(data)));\n\n    app.get(\"/api/post/:code/code\", /* isLoggedIn, isAdmin, */(req, res) => req.models.post.findOne({\n        where: {\n            code: req.params.code\n        }\n    }).then(data => data ? res.send(data) : res.status(404).send({ code: \"NOT_FOUND\" })));\n\n    app.get(\"/api/post/:postId/id\", /* isLoggedIn, isAdmin, */(req, res) => req.models.post.findById(req.params.postId).then(data => data ? res.send(data) : res.status(404).send({ code: \"NOT_FOUND\" })));\n\n    app.post(\"/api/post\", isLoggedIn, isAdmin, (req, res) => req.models.post.create(req.body).then(data => res.send(data)));\n\n    app.put(\"/api/post/:postId\", isLoggedIn, isAdmin, (req, res) => req.models.post.update({\n        title: req.body.title,\n        body: req.body.body\n    }, {\n        where: {\n            id: req.params.postId\n        }\n    }).then(data => res.send(data), err => res.status(500).send(err)));\n};\n\n//# sourceURL=webpack:///./src/app/routes/post.js?");

/***/ }),

/***/ "./src/app/routes/request.js":
/*!***********************************!*\
  !*** ./src/app/routes/request.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const async = __webpack_require__(/*! async */ \"async\");\nconst resCtrl = __webpack_require__(/*! ../controllers/responseController.js */ \"./src/app/controllers/responseController.js\");\nconst isLoggedIn = resCtrl.isLoggedIn;\nconst sendResponse = resCtrl.sendResponse;\nconst isLoggedInAndVerified = resCtrl.isLoggedInAndVerified;\nconst requestCtrl = __webpack_require__(/*! ../controllers/requestCtrl */ \"./src/app/controllers/requestCtrl.ts\");\nconst requestEmitter = __webpack_require__(/*! ../events/request */ \"./src/app/events/request.js\");\n\nmodule.exports = app => {\n    /**\n     * Creates a request for a demand or supply listings\n     * 1. Can only submit requests for active listings.\n     */\n    app.post(\"/api/request\", isLoggedIn, isLoggedInAndVerified, (req, res) => {\n        const message = req.body.message;\n        const taskId = req.body.taskId;\n        const fromUserId = req.user.id;\n        var task, toUserId, request;\n\n        async.waterfall([cb => req.models.task.findById(taskId).then(rTask => {\n            task = rTask;\n            toUserId = rTask.userId;\n\n            if (!task) {\n                return cb({\n                    code: 400\n                });\n            }\n\n            if (task.status !== req.models.task.TASK_STATUS.ACTIVE) {\n                return cb({\n                    code: \"TASK_WRONG_STATUS\",\n                    desc: \"It cannot send requests to tasks that do not have an ACTIVE status.\"\n                });\n            }\n\n            return cb();\n        }, cb), cb => req.models.request.findOne({\n            where: {\n                $and: [{\n                    taskId\n                }, {\n                    fromUserId\n                }]\n            }\n        }).then(rRequest => {\n            /**\n            if (\n                req.tenantConfig.LISTING_TASK_WORKFLOW_FOR_DEMAND_LISTINGS_REQUEST_STEP_MULTIPLE_REQUESTS_ENABLED !== \"1\" &&\n                rRequest\n            ) {\n                return cb({\n                    code: \"REQUEST_ALREADY_CREATED\",\n                    desc: \"You cannot send multiple requests for this listing.\"                            \n                });\n            }\n            */\n\n            if (req.tenantConfig[task.taskType === 1 ? \"LISTING_TASK_WORKFLOW_FOR_DEMAND_LISTINGS_REQUEST_STEP_MULTIPLE_REQUESTS_ENABLED\" : \"LISTING_TASK_WORKFLOW_FOR_SUPPLY_LISTINGS_REQUEST_STEP_MULTIPLE_REQUESTS_ENABLED\"] !== \"1\" && rRequest) {\n                return cb({\n                    code: \"REQUEST_ALREADY_CREATED\",\n                    desc: \"You cannot send multiple requests for this listing.\"\n                });\n            }\n\n            cb();\n        }, cb), cb => req.models.request.create({\n            status: req.models.request.REQUEST_STATUS.PENDING,\n            taskId,\n            fromUserId,\n            toUserId\n        }).then(rRequest => {\n            request = rRequest;\n\n            cb();\n        }, cb), cb => req.models.message.create({\n            requestId: request.id,\n            taskId,\n            fromUserId,\n            toUserId,\n            message\n        }).then(rMessage => cb(null, rMessage), cb)], (err, rMessage) => {\n            if (err) {\n                return res.status(400).send(err);\n            }\n\n            res.send(rMessage);\n\n            requestEmitter.emit(\"new-request\", req.models, request.id);\n        });\n    });\n\n    app.get(\"/api/request\", isLoggedIn, (req, res) => {\n        const userId = req.user.id;\n\n        const where = {\n            $and: [{\n                $and: [{\n                    $or: [{ status: req.models.request.REQUEST_STATUS.PENDING }, { status: req.models.request.REQUEST_STATUS.ACCEPTED }, { status: req.models.request.REQUEST_STATUS.MARKED_DONE }, { status: req.models.request.REQUEST_STATUS.SETTLED }, { status: req.models.request.REQUEST_STATUS.CLOSED }]\n                }, {\n                    $or: [{\n                        fromUserId: userId\n                    }, {\n                        toUserId: userId\n                    }]\n                }]\n            }]\n        };\n\n        if (req.query.view === \"in_progress\") {\n            where.$and.push({ $or: [{ status: req.models.request.REQUEST_STATUS.ACCEPTED }, { status: req.models.request.REQUEST_STATUS.MARKED_DONE }] });\n        }\n\n        if (req.query.view === \"pending\") {\n            where.$and.push({\n                $or: [{ status: req.models.request.REQUEST_STATUS.PENDING }]\n            });\n        }\n\n        if (req.query.view === \"completed\") {\n            where.$and.push({\n                $or: [{\n                    status: req.models.request.REQUEST_STATUS.SETTLED\n                }, {\n                    status: req.models.request.REQUEST_STATUS.CLOSED\n                }]\n            });\n        }\n\n        if (req.query.userId) {\n            where.$and.push({\n                fromUserId: req.query.userId\n            });\n        }\n\n        req.models.request.findAll({\n            where,\n            order: [[\"createdAt\", \"DESC\"]],\n            include: [{ model: req.models.user, as: \"fromUser\" }, { model: req.models.user, as: \"toUser\" }, { model: req.models.review }, { model: req.models.order }]\n        }).then(data => async.forEachLimit(data, 5, (item, cb) => {\n            async.waterfall([cb => req.models.message.findOne({\n                where: {\n                    requestId: item.id\n                },\n                order: [[\"createdAt\", \"DESC\"]]\n            }).then(msg => {\n                try {\n                    item.dataValues.lastMsg = msg;\n                } catch (err) {\n                    // @todo\n                }\n\n                cb();\n            }, cb), cb => {\n                if (!item.dataValues.lastMsg) {\n                    item.dataValues.with = null;\n\n                    return cb();\n                }\n\n                const fromUserId = item.dataValues.lastMsg.fromUserId;\n                const toUserId = item.dataValues.lastMsg.toUserId;\n\n                req.models.user.findOne({\n                    where: {\n                        id: fromUserId === req.user.id ? toUserId : fromUserId\n                    },\n                    include: [{\n                        model: req.models.userProperty\n                    }]\n                }).then(user => {\n                    item.dataValues.with = user;\n\n                    cb();\n                });\n            }, cb => {\n                const data = {};\n\n                async.parallel([cb => {\n                    req.models.task.findOne({\n                        where: {\n                            id: item.taskId\n                        },\n                        include: [{ model: req.models.taskTiming }, { model: req.models.taskLocation }]\n                    }).then(task => {\n                        data.task = task;\n\n                        return cb();\n                    }, cb);\n                }, cb => req.models.taskCategory.findAll({\n                    where: {\n                        taskId: item.taskId\n                    }\n                }).then(categories => {\n                    data.categories = categories;\n\n                    return cb(null, categories);\n                }, cb)], err => {\n                    if (err) {\n                        return cb(err);\n                    }\n\n                    data.task.dataValues.categories = data.categories;\n\n                    item.dataValues.task = data.task;\n\n                    return cb();\n                });\n            }], cb);\n        }, err => err ? res.status(500).send(err) : res.send(data))).catch(err => {\n            res.status(500).send(err);\n        });\n    });\n\n    app.put(\"/api/request/:requestId\", isLoggedIn, (req, res) => {\n        const newStatus = String(req.body.status);\n        const userId = req.user.id;\n        const requestId = req.params.requestId;\n\n        requestCtrl.changeRequestStatus(req.models, requestId, newStatus, userId, (err, request) => {\n            return sendResponse(res, err, request);\n        });\n    });\n\n    app.get(\"/api/request/:requestId/order\", isLoggedIn, (req, res) => {\n        const requestId = req.params.requestId;\n\n        req.models.order.findOne({\n            where: {\n                requestId: requestId\n            }\n        }).then(order => {\n            if (!order) {\n                return sendResponse(res, {\n                    code: \"ORDER_NOT_FOUND\"\n                });\n            }\n\n            return sendResponse(res, null, order);\n        }, err => sendResponse(res, err));\n    });\n\n    app.get(\"/api/order/:orderId/request\", isLoggedIn, (req, res) => {\n        const orderId = req.params.orderId;\n\n        req.models.order.findById(orderId).then(order => {\n            if (!order) {\n                return sendResponse(res, {\n                    code: \"ORDER_NOT_FOUND\"\n                });\n            }\n\n            req.models.request.findOne({\n                where: {\n                    id: order.requestId\n                },\n                include: [{ model: req.models.user, as: \"fromUser\" }, { model: req.models.user, as: \"toUser\" }]\n            }).then(request => {\n                if (!request) {\n                    return sendResponse(res, {\n                        code: \"REQUEST_NOT_FOUND\"\n                    });\n                }\n\n                return sendResponse(res, null, request);\n            }, err => sendResponse(res, err));\n        }, err => sendResponse(res, err));\n    });\n};\n\n//# sourceURL=webpack:///./src/app/routes/request.js?");

/***/ }),

/***/ "./src/app/routes/review.js":
/*!**********************************!*\
  !*** ./src/app/routes/review.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const async = __webpack_require__(/*! async */ \"async\");\nconst resCtrl = __webpack_require__(/*! ../controllers/responseController.js */ \"./src/app/controllers/responseController.js\");\nconst cust = __webpack_require__(/*! ../config/customizing.js */ \"./src/app/config/customizing.js\");\nconst isLoggedIn = resCtrl.isLoggedIn;\nconst sendResponse = resCtrl.sendResponse;\nconst isLoggedInAndVerified = resCtrl.isLoggedInAndVerified;\nconst identifyUser = resCtrl.identifyUser;\nconst isAdmin = resCtrl.isAdmin;\nconst models = __webpack_require__(/*! ../models/models */ \"./src/app/models/models.ts\");\nconst reviewEmitter = __webpack_require__(/*! ../events/review */ \"./src/app/events/review.js\");\n\nconst RESOURCE = \"review\";\n\nconst REVIEW_TYPES = {\n    ORDER: 1,\n    REQUEST: 2\n};\n\nmodule.exports = app => {\n    /**\n     * @bodyParam taskId\n     * @bodyParam body\n     * @bodyParam rate\n     */\n    app.post(`/api/${RESOURCE}`, isLoggedIn, isLoggedInAndVerified, (req, res) => {\n        const userId = req.user.id;\n\n        const rate = String(req.body.rate);\n        const body = req.body.body;\n\n        var orderId, requestId, reviewType;\n        const whereObj = {};\n\n        if (req.body.orderId) {\n            orderId = req.body.orderId;\n            whereObj.orderId = orderId;\n            reviewType = REVIEW_TYPES.ORDER;\n        } else {\n            requestId = req.body.requestId;\n            whereObj.requestId = requestId;\n            reviewType = REVIEW_TYPES.REQUEST;\n        }\n\n        if ([\"0\", \"1\", \"2\", \"3\", \"4\", \"5\"].indexOf(rate) === -1) {\n            return res.status(400).send({\n                code: \"WRONG_RATE\",\n                desc: \"Rate must be between 0 and 5\"\n            });\n        }\n\n        var order, request, task;\n\n        async.waterfall([cb => {\n            return req.models.review.findOne({\n                where: {\n                    $and: [{\n                        fromUserId: userId\n                    }, whereObj]\n                }\n            }).then(review => {\n                if (review) {\n                    return cb({\n                        code: \"ALREADY_REVIEWED\",\n                        httpCode: 400,\n                        desc: \"You have already rated this order / request\"\n                    });\n                }\n\n                cb();\n            }, cb);\n        }, cb => {\n            if (reviewType === REVIEW_TYPES.REQUEST) {\n                return cb();\n            }\n\n            req.models.order.findOne({\n                where: {\n                    id: orderId\n                },\n                include: [{ model: req.models.user }, { model: req.models.request }, { model: req.models.task }]\n            }).then(rOrder => {\n                if (!rOrder) {\n                    return cb({\n                        code: \"ORDER_NOT_FOUND\",\n                        desc: \"Order has not been found\",\n                        httpCode: 400\n                    });\n                }\n\n                order = rOrder;\n                request = rOrder.request;\n                task = rOrder.task;\n\n                if (order.status !== req.models.order.ORDER_STATUS.SETTLED && order.status !== req.models.order.ORDER_STATUS.CLOSED) {\n                    return cb({\n                        httpCode: 400,\n                        code: \"WRONG_ORDER_STATUS_FOR_REVIEW\",\n                        desc: \"Order needs to be completed to review it.\"\n                    });\n                }\n\n                return cb();\n            }, cb);\n        }, cb => {\n            if (reviewType === REVIEW_TYPES.ORDER) {\n                return cb();\n            }\n\n            req.models.request.findOne({\n                where: {\n                    id: requestId\n                },\n                include: [{ model: req.models.order }, { model: req.models.task }]\n            }).then(rRequest => {\n                if (!rRequest) {\n                    return cb({\n                        code: \"REQUEST_NOT_FOUND\",\n                        desc: \"Request has not been found\",\n                        httpCode: 400\n                    });\n                }\n\n                request = rRequest;\n                order = rRequest.order;\n                task = rRequest.task;\n\n                if (request.status !== req.models.request.REQUEST_STATUS.SETTLED && request.status !== req.models.request.REQUEST_STATUS.CLOSED) {\n                    return cb({\n                        httpCode: 400,\n                        code: \"WRONG_REQUEST_STATUS_FOR_REVIEW\",\n                        desc: \"Request needs to be completed to review it.\"\n                    });\n                }\n\n                return cb();\n            }, cb);\n        }, cb => {\n\n            const toUserId = reviewType === REVIEW_TYPES.ORDER ? Number(task.taskType) === 1 ? request.fromUserId : request.toUserId : Number(task.taskType) === 1 ? request.toUserId : request.fromUserId;\n\n            if (toUserId === userId) {\n                return cb({\n                    code: \"WRONG_REVIEW_SIDE\",\n                    desc: \"You cannot leave review to yourself\"\n                });\n            }\n\n            const newReview = {\n                body,\n                rate,\n                fromUserId: userId,\n                toUserId: toUserId,\n                taskId: order.taskId\n            };\n\n            if (reviewType === REVIEW_TYPES.ORDER) {\n                newReview.orderId = orderId;\n            }\n\n            if (reviewType === REVIEW_TYPES.REQUEST) {\n                newReview.requestId = request.id;\n            }\n\n            return req.models.review.create(newReview).then(rReview => {\n                return cb(null, rReview);\n            }, cb);\n        }], (err, rReview) => {\n            if (err) {\n                console.error(err);\n\n                return res.status(400).send(err);\n            }\n\n            res.send(rReview);\n\n            reviewEmitter.emit(\"review-left\", req.models, rReview.id);\n        });\n    });\n\n    app.get(\"/api/review\", identifyUser, (req, res) => {\n        const toUserId = Number(req.query.toUserId);\n\n        if (!toUserId) {\n            return res.status(400).send({\n                code: \"MISSING_QUERY\",\n                desc: \"Specify query param \\\"toUserId\\\"\"\n            });\n        }\n\n        req.models.review.findAll({\n            order: [[\"createdAt\", \"DESC\"]],\n            where: {\n                toUserId\n            },\n            include: [{\n                model: req.models.user,\n                as: \"fromUser\"\n            }, { model: req.models.task }]\n        }).then(reviews => {\n            async.eachSeries(reviews, (review, cb) => {\n                req.models.review.findOne({\n                    where: {\n                        $and: [{ taskId: review.taskId }, { fromUserId: review.toUserId }]\n                    }\n                }).then(oppositeReview => {\n\n                    req.models.appConfig.findAll({\n                        $where: {\n                            $or: [{ fieldKey: \"LISTING_TASK_WORKFLOW_FOR_SUPPLY_LISTINGS\" }, { fieldKey: \"LISTING_TASK_WORKFLOW_FOR_DEMAND_LISTINGS\" }, { fieldKey: \"LISTING_TASK_WORKFLOW_FOR_SUPPLY_LISTINGS_REVIEW_STEP_ENABLED\" }, { fieldKey: \"LISTING_TASK_WORKFLOW_FOR_DEMAND_LISTINGS_REVIEW_STEP_ENABLED\" }, { fieldKey: \"LISTING_TASK_WORKFLOW_FOR_SUPPLY_LISTINGS_REVIEW_STEP_REQUIRE_BOTH_REVIEWS\" }, { fieldKey: \"LISTING_TASK_WORKFLOW_FOR_DEMAND_LISTINGS_REVIEW_STEP_REQUIRE_BOTH_REVIEWS\" }]\n                        }\n                    }).then(rWorkflowConfigs => {\n\n                        const supplyWorkflow = rWorkflowConfigs.find(_ => _.fieldKey === \"LISTING_TASK_WORKFLOW_FOR_SUPPLY_LISTINGS\");\n\n                        const demandWorkflow = rWorkflowConfigs.find(_ => _.fieldKey === \"LISTING_TASK_WORKFLOW_FOR_DEMAND_LISTINGS\");\n\n                        const supplyWorkflowRequestsEnabled = rWorkflowConfigs.find(_ => _.fieldKey === \"LISTING_TASK_WORKFLOW_FOR_SUPPLY_LISTINGS_REVIEW_STEP_ENABLED\");\n\n                        const demandWorkflowRequestsEnabled = rWorkflowConfigs.find(_ => _.fieldKey === \"LISTING_TASK_WORKFLOW_FOR_DEMAND_LISTINGS_REVIEW_STEP_ENABLED\");\n\n                        const supplyWorkflowRequestsRequireBothSides = rWorkflowConfigs.find(_ => _.fieldKey === \"LISTING_TASK_WORKFLOW_FOR_SUPPLY_LISTINGS_REVIEW_STEP_REQUIRE_BOTH_REVIEWS\");\n\n                        const demandWorkflowRequestsRequireBothSides = rWorkflowConfigs.find(_ => _.fieldKey === \"LISTING_TASK_WORKFLOW_FOR_DEMAND_LISTINGS_REVIEW_STEP_REQUIRE_BOTH_REVIEWS\");\n\n                        if (oppositeReview || req.user && review.fromUserId === req.user.id || supplyWorkflow && String(supplyWorkflow.fieldValue) === \"1\" || demandWorkflow && String(demandWorkflow.fieldValue) === \"1\") {\n                            if (oppositeReview) {\n                                review.dataValues.hasOppositeReview = true;\n                            }\n                            if (req.user && review.fromUserId === req.user.id) {\n                                review.dataValues.isOwnReview = true;\n                            }\n\n                            if ((supplyWorkflowRequestsEnabled && String(review.task.taskType) === \"2\" && String(supplyWorkflowRequestsEnabled.fieldValue) === \"1\" && String(supplyWorkflowRequestsRequireBothSides.fieldValue) === \"1\" || demandWorkflowRequestsEnabled && String(review.task.taskType) === \"1\" && String(demandWorkflowRequestsEnabled.fieldValue) === \"1\" && String(demandWorkflowRequestsRequireBothSides.fieldValue) === \"1\") && !oppositeReview) {\n                                review.dataValues.hiddenByWorkflow = true;\n                            }\n\n                            return cb();\n                        }\n\n                        return cb();\n                    }, cb);\n                });\n            }, () => {\n                res.send(reviews);\n            }, err => {\n                res.status(400).send(err);\n            });\n        }, err => {\n            console.log(err);\n\n            res.status(400).send(err);\n        });\n    });\n};\n\n//# sourceURL=webpack:///./src/app/routes/review.js?");

/***/ }),

/***/ "./src/app/routes/task.js":
/*!********************************!*\
  !*** ./src/app/routes/task.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const async = __webpack_require__(/*! async */ \"async\");\nconst sendResponse = __webpack_require__(/*! ../controllers/responseController */ \"./src/app/controllers/responseController.js\").sendResponse;\nconst identifyUser = __webpack_require__(/*! ../controllers/responseController */ \"./src/app/controllers/responseController.js\").identifyUser;\nconst isLoggedIn = __webpack_require__(/*! ../controllers/responseController */ \"./src/app/controllers/responseController.js\").isLoggedIn;\nconst isLoggedInAndVerified = __webpack_require__(/*! ../controllers/responseController */ \"./src/app/controllers/responseController.js\").isLoggedInAndVerified;\nconst taskEmitter = __webpack_require__(/*! ../events/task */ \"./src/app/events/task.js\");\nconst requestCtrl = __webpack_require__(/*! ../controllers/requestCtrl */ \"./src/app/controllers/requestCtrl.ts\");\n\nconst isMyTask = (models, taskId, myUserId) => {\n    return models.task.findOne({\n        where: [{ id: taskId }]\n    }).then(task => new Promise((resolve, reject) => {\n        if (!task) {\n            return reject({\n                status: 400,\n                code: \"TASK_DOES_NOT_EXIST\"\n            });\n        }\n\n        if (Number(task.userId) !== Number(myUserId)) {\n            return reject({\n                status: 401,\n                code: \"NOT_YOUR_TASK\"\n            });\n        }\n\n        return resolve(task);\n    }));\n};\n\nconst getTaskAdditionalInfo = (models, taskId) => new Promise((resolve, reject) => async.parallel([cb => models.taskCategory.findAll({\n    where: { taskId: taskId }\n}).then(categories => cb(null, categories), err => cb(err)), cb => models.taskImage.findAll({\n    where: { taskId: taskId }\n}).then(images => cb(null, images), err => cb(err)), cb => models.taskLocation.findOne({\n    where: { taskId: taskId }\n}).then(location => cb(null, location), err => cb(err))], (err, data) => {\n    if (err) {\n        return reject(err);\n    }\n\n    const task = {};\n\n    task.categories = JSON.parse(JSON.stringify(data[0]));\n    task.images = JSON.parse(JSON.stringify(data[1]));\n    task.location = JSON.parse(JSON.stringify(data[2]));\n\n    return resolve(task);\n}));\n\nmodule.exports = app => {\n    app.get(\"/api/task\", identifyUser, (req, res) => {\n        const query = {};\n\n        query.order = [[\"createdAt\", \"DESC\"]];\n\n        query.include = [];\n\n        query.include.push({\n            model: req.models.request,\n            include: [{\n                model: req.models.user,\n                as: \"fromUser\"\n            }, {\n                model: req.models.order\n            }]\n        }, {\n            model: req.models.review\n        });\n\n        const timingInclude = {\n            model: req.models.taskTiming\n        };\n\n        if (req.query.untilNow) {\n            const now = new Date();\n            const nowUtc = new Date(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate(), now.getUTCHours(), now.getUTCMinutes(), now.getUTCSeconds());\n\n            timingInclude.where = {\n                endDate: {\n                    $gte: nowUtc.getTime() / 1000\n                }\n            };\n        }\n\n        query.include.push(timingInclude);\n\n        if (req.query && req.query.category) {\n            query.include.push({\n                model: req.models.taskCategory,\n                where: {\n                    code: req.query.category\n                }\n            });\n\n            delete req.query.category;\n        }\n\n        if (req.query) {\n            query.where = {};\n            query.where.$and = [];\n\n            const lat = req.query.lat;\n            const lng = req.query.lng;\n            const rad = req.query.rad || 2000;\n\n            if (lat && lng) {\n                const location = req.models.seq.literal(`ST_GeomFromText('POINT(${lat} ${lng})')`);\n\n                const distance = req.models.seq.fn(\"ST_Distance_Sphere\", req.models.seq.literal(\"geo\"), location);\n\n                /*\n                const attributes = Object\n                    .keys(req.models.taskLocation.attributes);\n                  attributes.push([\n                    distance,\n                    'distance'\n                ]);\n                */\n\n                const seqWhereCond = req.models.seq.where(distance, {\n                    $lte: rad\n                });\n\n                query.include.push({\n                    model: req.models.taskLocation,\n                    where: seqWhereCond\n                });\n            } else {\n                query.include.push({\n                    model: req.models.taskLocation\n                });\n            }\n\n            if (req.query.status) {\n                const statusQuery = [];\n\n                if (Array.isArray(req.query.status)) {\n                    req.query.status.forEach(status => statusQuery.push({ status: String(status) }));\n                } else {\n                    statusQuery.push({ status: String(req.query.status) });\n                }\n\n                query.where.$and.push({\n                    $or: statusQuery\n                });\n            }\n\n            if (req.query.userId) {\n                query.where.$and.push({\n                    userId: req.query.userId\n                });\n            }\n\n            if (req.query.taskType) {\n                query.where.$and.push({\n                    taskType: req.query.taskType\n                });\n            }\n\n            if (req.query.minPrice || req.query.maxPrice) {\n                const minPrice = Number(req.query.minPrice);\n                const maxPrice = Number(req.query.maxPrice);\n\n                if (minPrice) {\n                    query.where.$and.push({\n                        price: {\n                            $gte: minPrice\n                        }\n                    });\n                }\n\n                if (maxPrice) {\n                    query.where.$and.push({\n                        price: {\n                            $lte: maxPrice\n                        }\n                    });\n                }\n            }\n        }\n\n        return req.models.task.findAll(query).then(rTasks => new Promise((resolve, reject) => {\n            const tasks = JSON.parse(JSON.stringify(rTasks));\n\n            req.models.appTaskCategory.findAll().then(categories => {\n                async.eachLimit(tasks, 5, (task, cb) => {\n                    getTaskAdditionalInfo(req.models, task.id).then(taskAdditionalInfo => {\n                        task.categories = taskAdditionalInfo.categories;\n\n                        try {\n                            task.categories = task.categories.map(_ => {\n                                _.imageUrl = categories.find(category => category.code === _.code).imageUrl;\n\n                                return _;\n                            });\n                        } catch (err) {\n                            console.error(err);\n                        }\n\n                        task.images = taskAdditionalInfo.images;\n                        task.location = taskAdditionalInfo.location;\n\n                        return cb();\n                    }, cb);\n                }, err => {\n                    if (err) {\n                        return reject(err);\n                    }\n\n                    return resolve(tasks);\n                });\n            });\n        })).then(tasks => sendResponse(res, null, tasks), err => {\n            sendResponse(res, err);\n        });\n    });\n\n    app.get(\"/api/task/location/last\", isLoggedIn, (req, res) => {\n        return req.models.taskLocation.findOne({\n            order: [[\"createdAt\", \"DESC\"]],\n            include: [{\n                model: req.models.task,\n                include: [{\n                    model: req.models.user,\n                    require: true\n                }]\n            }]\n        }).then(lastLocation => sendResponse(res, null, lastLocation), err => sendResponse(res, err));\n    });\n\n    app.post(\"/api/task\", isLoggedInAndVerified, (req, res) => {\n        req.models.task.create({\n            status: req.models.task.TASK_STATUS.CREATION_IN_PROGRESS,\n            // supply listings are the defaults ones\n            taskType: req.user.userType === 1 ? 1 : 2,\n            userId: req.user.id\n        }).then(task => sendResponse(res, null, task)).catch(err => sendResponse(res, err));\n    });\n\n    app.post(\"/api/task/:taskId/comment\", isLoggedIn, (req, res) => {\n        req.models.taskComment.create({\n            comment: req.body.comment,\n            userId: req.user.id,\n            taskId: req.params.taskId\n        }).then(data => sendResponse(res, null, data)).catch(err => sendResponse(res, err));\n    });\n\n    app.post(\"/api/task/:taskId/category\", isLoggedIn, (req, res) => {\n        isMyTask(req.models, req.params.taskId, req.user.id).then(() => req.models.taskCategory.destroy({\n            where: {\n                taskId: req.params.taskId\n            }\n        })).then(() => new Promise((resolve, reject) => async.each(req.body, (code, cb) => {\n            return req.models.taskCategory.create({ code, taskId: req.params.taskId }).then(() => cb(), err => cb(err));\n        }, err => {\n            if (err) {\n                return reject(err);\n            }\n\n            return resolve();\n        }))).then(() => sendResponse(res, null, { ok: true }), err => sendResponse(res, err));\n    });\n\n    app.post(\"/api/task/:taskId/image\", isLoggedIn, (req, res) => {\n        isMyTask(req.models, req.params.taskId, req.user.id).then(() => req.models.taskImage.destroy({\n            where: {\n                taskId: req.params.taskId\n            }\n        })).then(() => new Promise((resolve, reject) => async.each(req.body, (image, cb) => {\n            return req.models.taskImage.create({ imageUrl: image.imageUrl, taskId: req.params.taskId }).then(() => cb(), err => cb(err));\n        }, err => {\n            if (err) {\n                return reject(err);\n            }\n\n            return resolve();\n        }))).then(() => sendResponse(res, null, { ok: true }), err => sendResponse(res, err));\n    });\n\n    app.post(\"/api/task/:taskId/timing\", isLoggedIn, (req, res) => {\n        const taskId = req.params.taskId;\n\n        isMyTask(req.models, req.params.taskId, req.user.id).then(() => req.models.taskTiming.destroy({\n            where: {\n                taskId\n            }\n        })).then(() => new Promise((resolve, reject) => async.each(req.body.dates, (timing, cb) => {\n            timing.endDate = timing.endDate || timing.date;\n\n            return req.models.taskTiming.create({\n                duration: req.body.duration,\n                date: timing.date,\n                endDate: timing.endDate,\n                type: \"\",\n                taskId\n            }).then(() => cb(), err => cb(err));\n        }, err => {\n            if (err) {\n                return reject(err);\n            }\n\n            return resolve();\n        }))).then(() => sendResponse(res, null, { ok: true }), err => sendResponse(res, err));\n    });\n\n    /*\n     Updates location for a task\n    */\n    app.post(\"/api/task/:taskId/location\", isLoggedIn, (req, res) => {\n        const userId = req.user.id;\n        const taskId = req.params.taskId;\n\n        req.body.taskId = taskId;\n\n        isMyTask(req.models, taskId, userId).then(() => req.models.taskLocation.destroy({\n            where: {\n                taskId\n            }\n        })).then(() => new Promise((resolve, reject) => {\n            req.models.taskLocation.findOne({\n                where: {\n                    userId\n                }\n            }).then(defaultLocation => {\n                const taskLocation = req.body;\n                const lat = taskLocation.lat;\n                const lng = taskLocation.lng;\n\n                const geoPoint = {\n                    type: \"Point\",\n                    coordinates: [lat, lng]\n                };\n\n                taskLocation.geo = geoPoint;\n\n                if (!defaultLocation) {\n                    taskLocation.userId = userId;\n                }\n\n                return req.models.taskLocation.create(taskLocation).then(_ => {\n                    resolve(_);\n                }, _ => {\n                    reject(_);\n                });\n            });\n        })).then(taskLocation => {\n            return sendResponse(res, null, taskLocation);\n        }).catch(err => {\n            return sendResponse(res, err);\n        });\n    });\n\n    app.post(\"/api/task-location\", isLoggedIn, (req, res) => {\n        const userId = req.user.id;\n        const taskLocation = req.body;\n        const lat = taskLocation.lat;\n        const lng = taskLocation.lng;\n\n        const geoPoint = {\n            type: \"Point\",\n            coordinates: [lat, lng]\n        };\n\n        taskLocation.geo = geoPoint;\n\n        req.models.taskLocation.findOne({\n            where: {\n                userId\n            }\n        }).then(taskLocationRef => {\n            if (taskLocationRef) {\n                delete taskLocation.id;\n                delete taskLocation.createdAt;\n                delete taskLocation.updatedAt;\n                delete taskLocation.userId;\n\n                return taskLocationRef.update(taskLocation).then(() => sendResponse(res, null, taskLocation), err => sendResponse(res, err));\n            }\n\n            return req.models.taskLocation.create({\n                userId,\n                countryCode: taskLocation.countryCode,\n                postalCode: taskLocation.postalCode,\n                city: taskLocation.city,\n                street: taskLocation.street,\n                streetNo: taskLocation.streetNo,\n                addressAddition: taskLocation.addressAddition,\n                taxNumber: taskLocation.taxNumber,\n                lat: taskLocation.lat,\n                lng: taskLocation.lng,\n                geo: taskLocation.geo\n            }).then(_ => {\n                sendResponse(res, null, _);\n            }, err => {\n                sendResponse(res, err);\n            });\n        });\n    });\n\n    app.get(\"/api/task-location\", isLoggedIn, (req, res) => {\n        return req.models.taskLocation.findAll({\n            where: {\n                userId: req.user.id\n            }\n        }).then(locations => sendResponse(res, null, locations), err => sendResponse(res, err));\n    });\n\n    app.get(\"/api/task/:taskId\", identifyUser, (req, res) => async.parallel([cb => req.models.task.findOne({\n        where: {\n            id: req.params.taskId\n        },\n        include: [{\n            model: req.models.user\n        }]\n    }).then(task => {\n        if (!task) {\n            return cb({\n                code: \"LISTING_NOT_FOUND\"\n            });\n        }\n\n        return cb(null, task);\n    }, cb), cb => req.models.taskCategory.findAll({\n        where: {\n            taskId: req.params.taskId\n        }\n    }).then(categories => cb(null, categories), err => cb(err)), cb => req.models.taskImage.findAll({ where: { taskId: req.params.taskId } }).then(images => cb(null, images), err => cb(err)), cb => req.models.taskLocation.findOne({ where: { taskId: req.params.taskId } }).then(location => cb(null, location), err => cb(err)), cb => req.models.taskTiming.findAll({ where: {\n            taskId: req.params.taskId\n        } }).then(timing => cb(null, timing), err => cb(err)), cb => req.models.taskComment.findAll({\n        where: {\n            taskId: req.params.taskId\n        },\n        include: [{\n            model: req.models.user\n        }]\n    }).then(timing => cb(null, timing), err => cb(err)), cb => req.models.request.findAll({\n        where: {\n            $and: [{\n                taskId: req.params.taskId\n            }]\n        },\n        include: [{ model: req.models.user, as: \"fromUser\" }]\n    }).then(requests => cb(null, requests), err => cb(err))], (err, data) => {\n        if (err) {\n            return res.status(400).send(err);\n        }\n\n        const task = JSON.parse(JSON.stringify(data[0]));\n\n        task.categories = JSON.parse(JSON.stringify(data[1]));\n        task.images = JSON.parse(JSON.stringify(data[2]));\n        task.location = JSON.parse(JSON.stringify(data[3]));\n        task.timing = JSON.parse(JSON.stringify(data[4]));\n        task.comments = JSON.parse(JSON.stringify(data[5]));\n        task.requests = JSON.parse(JSON.stringify(data[6]));\n\n        return res.send(task);\n    }));\n\n    /*\n        updates task header info like title or description\n    */\n    app.put(\"/api/task/:taskId\", isLoggedIn, (req, res) => {\n        const taskId = req.params.taskId;\n        const userId = String(req.user.id);\n        const updatedTask = req.body;\n        const newStatus = updatedTask.status;\n\n        /*\n            updatedTask.description = striptags(updatedTask.description, [\n                'p',\n                'br'\n            ]);\n        */\n\n        const fieldsToBeExcluded = [\"id\", \"userId\", \"categories\", \"duration\"];\n\n        Object.keys(updatedTask).forEach(itemKey => {\n            if (fieldsToBeExcluded.indexOf(itemKey) !== -1) {\n                delete updatedTask[itemKey];\n            }\n        });\n\n        updatedTask.status = updatedTask.status ? String(updatedTask.status) : \"0\";\n\n        var task;\n\n        async.waterfall([cb => {\n            isMyTask(req.models, taskId, userId).then(rTask => {\n                task = rTask;\n\n                cb();\n            }, cb);\n        }, cb => {\n            task.update(updatedTask).then(() => cb(), cb);\n        }, cb => {\n            if (newStatus === req.models.task.TASK_STATUS.ACTIVE) {\n                // emails are enabled now just for demand listings\n                if (task.taskType === 1) {\n                    taskEmitter.emit(\"new-task\", req.models, task.id);\n                }\n            }\n\n            if (newStatus === req.models.task.TASK_STATUS.INACTIVE) {\n                taskEmitter.emit(\"cancelled\", req.models, task);\n\n                requestCtrl.declineAllPendingRequestsForTask(req.models, taskId, err => {\n                    if (err) {\n                        console.error(err);\n                    }\n\n                    console.log(`[SUCCESS] All pending requests for task ${taskId} have been declined!`);\n                });\n            }\n\n            cb();\n        }], err => {\n            sendResponse(res, err, task);\n        });\n    });\n};\n\n//# sourceURL=webpack:///./src/app/routes/task.js?");

/***/ }),

/***/ "./src/app/routes/upload.js":
/*!**********************************!*\
  !*** ./src/app/routes/upload.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const multer = __webpack_require__(/*! multer */ \"multer\");\nconst async = __webpack_require__(/*! async */ \"async\");\nconst UploadService = __webpack_require__(/*! ../services/UploadService */ \"./src/app/services/UploadService.js\");\nconst responseController = __webpack_require__(/*! ../controllers/responseController */ \"./src/app/controllers/responseController.js\");\nconst isLoggedIn = responseController.isLoggedIn;\nconst uploader = UploadService(process.env.AWS_S3_BUCKET);\n\nmodule.exports = app => {\n    app.post(\"/api/upload/image\", isLoggedIn, (req, res) => {\n        multer({\n            limits: {\n                fileSize: 5 * 1024 * 1024 // 5MB is the limit\n            }\n        }).single(\"file\")(req, res, err => {\n            if (err) {\n                if (err.code === \"LIMIT_FILE_SIZE\") {\n                    return res.status(400).send({\n                        code: \"LIMIT_IMAGE_SIZE\"\n                    });\n                }\n            }\n\n            if (!req.file) {\n                return res.status(400).send(\"No files uploaded!\");\n            }\n\n            const imageBuffer = new Buffer(req.file.buffer);\n            const width = Number(req.query.width);\n            const height = Number(req.query.height);\n\n            /** \n            if (!width && !height) {\n                return res.status(400)\n                    .send(\"Width or height is not specifed\");\n            }\n            */\n\n            const mimetype = req.file.mimetype.split(\"/\")[1];\n\n            if (mimetype !== \"jpeg\" && mimetype !== \"png\") {\n                return res.status(400).send({\n                    code: \"UNSUPPORTED_IMAGE_FORMAT\"\n                });\n            }\n\n            async.waterfall([fn => uploader.uploadToBucket(imageBuffer, req.models.tenantId, mimetype, width, height, (err, locationPath) => {\n                if (err) {\n                    return fn(err, locationPath);\n                }\n\n                return fn(null, locationPath);\n            })], (err, locationPath) => {\n                if (err) {\n                    console.error(err);\n                    return res.status(500).send(err);\n                }\n\n                res.status(200).send(req.query.json ? {\n                    url: locationPath\n                } : locationPath);\n            });\n        });\n    });\n\n    app.post(\"/api/upload/file\", isLoggedIn, (req, res) => {\n        multer({\n            limits: {\n                fileSize: 5 * 1024 * 1024 // 5MB is the limit\n            }\n        }).single(\"file\")(req, res, err => {\n            if (err) {\n                if (err.code === \"LIMIT_FILE_SIZE\") {\n                    return res.status(400).send({\n                        code: \"LIMIT_IMAGE_SIZE\"\n                    });\n                }\n            }\n\n            if (!req.file) {\n                return res.status(400).send(\"No files uploaded!\");\n            }\n\n            const fileBuffer = new Buffer(req.file.buffer);\n\n            const mimetype = req.file.mimetype.split(\"/\")[1];\n\n            if (mimetype !== \"pdf\") {\n                return res.status(400).send({\n                    code: \"UNSUPPORTED_FILE_FORMAT\"\n                });\n            }\n\n            async.waterfall([fn => uploader.uploadFileToBucket(fileBuffer, \"st\", mimetype, (err, locationPath) => {\n                if (err) {\n                    return fn(err, locationPath);\n                }\n\n                return fn(null, locationPath);\n            })], (err, locationPath) => {\n                if (err) {\n                    console.error(err);\n                    return res.status(500).send(err);\n                }\n\n                res.status(200).send(req.query.json ? {\n                    url: locationPath\n                } : locationPath);\n            });\n        });\n    });\n};\n\n//# sourceURL=webpack:///./src/app/routes/upload.js?");

/***/ }),

/***/ "./src/app/routes/user-preference.js":
/*!*******************************************!*\
  !*** ./src/app/routes/user-preference.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const responseController = __webpack_require__(/*! ../controllers/responseController.js */ \"./src/app/controllers/responseController.js\");\nconst isLoggedIn = responseController.isLoggedIn;\n\nmodule.exports = app => {\n    app.get(\"/api/user/:userId/preference\", (req, res) => {\n        req.models.userPreference.findAll({\n            where: {\n                userId: req.params.userId\n            }\n        }).then(data => responseController.sendResponse(res, null, data), err => responseController.sendResponse(res, err));\n    });\n\n    app.get(\"/api/user/:userId/preference/:type\", (req, res) => {\n        req.models.userPreference.findAll({\n            where: {\n                $and: [{ userId: req.params.userId }, { type: req.params.type }]\n            }\n        }).then(data => responseController.sendResponse(res, null, data), err => responseController.sendResponse(res, err));\n    });\n\n    app.post(\"/api/user/:userId/preference\", isLoggedIn, (req, res) => {\n        const preference = {\n            userId: req.user.id,\n            type: \"category\",\n            value: req.body.value\n        };\n\n        req.models.userPreference.findOne({\n            where: {\n                $and: [{ userId: preference.userId }, { type: preference.type }, { value: preference.value }]\n            }\n        }).then(rPreference => {\n            if (rPreference) {\n                const updatedPreference = rPreference;\n\n                updatedPreference.value = preference.value;\n\n                req.models.userPreference.update({\n                    value: preference.value\n                }, {\n                    where: [{ id: rPreference.id }]\n                }).then(() => {\n                    responseController.sendResponse(res, null, updatedPreference);\n                }, err => responseController.sendResponse(res, err));\n            } else {\n                req.models.userPreference.create(preference).then(rCreatedPreference => {\n                    responseController.sendResponse(res, null, rCreatedPreference);\n                }, err => responseController.sendResponse(res, err));\n            }\n        });\n    });\n\n    app.delete(\"/api/user/:userId/preference/:preferenceId\", isLoggedIn, (req, res) => {\n        const preference = {\n            id: req.params.preferenceId,\n            userId: req.user.id\n        };\n\n        req.models.userPreference.destroy({\n            where: {\n                $and: [{ userId: preference.userId }, { id: preference.id }]\n            }\n        }).then(() => {\n            responseController.sendResponse(res, null, { desc: \"Deleted \" });\n        }, err => responseController.sendResponse(res, err));\n    });\n};\n\n//# sourceURL=webpack:///./src/app/routes/user-preference.js?");

/***/ }),

/***/ "./src/app/routes/user-property.js":
/*!*****************************************!*\
  !*** ./src/app/routes/user-property.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const async = __webpack_require__(/*! async */ \"async\");\nconst responseController = __webpack_require__(/*! ../controllers/responseController.js */ \"./src/app/controllers/responseController.js\");\nconst isLoggedIn = responseController.isLoggedIn;\nconst identifyUser = responseController.identifyUser;\n\nmodule.exports = app => {\n    app.get(\"/api/user/:userId/property\", identifyUser, (req, res) => {\n        const userId = req.params.userId;\n\n        async.waterfall([cb => req.models.userProperty.findAll({\n            where: {\n                userId\n            }\n        }).then(properties => cb(null, properties), cb)], (err, properties) => {\n            responseController.sendResponse(res, err, properties);\n        });\n    });\n\n    app.post(\"/api/user/:userId/property\", isLoggedIn, (req, res) => {\n        const userId = req.user.id;\n        const propValue = req.body.propValue;\n        const propKey = req.body.propKey;\n        const property = {\n            userId,\n            propValue,\n            propKey\n        };\n\n        var commitedProperty;\n\n        async.waterfall([cb => req.models.userProperty.findOne({\n            where: {\n                $and: [{ userId }, { propKey: property.propKey }]\n\n            }\n        }).then(prop => cb(null, prop), cb), (prop, cb) => {\n            if (prop) {\n                return prop.update({\n                    propValue\n                }).then(() => {\n                    commitedProperty = prop;\n\n                    return cb();\n                }, cb);\n            }\n\n            return req.models.userProperty.create(property).then(newProperty => {\n                commitedProperty = newProperty;\n\n                return cb();\n            }, cb);\n        }], err => {\n            responseController.sendResponse(res, err, commitedProperty);\n        });\n    });\n};\n\n//# sourceURL=webpack:///./src/app/routes/user-property.js?");

/***/ }),

/***/ "./src/app/routes/user.js":
/*!********************************!*\
  !*** ./src/app/routes/user.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const responseController = __webpack_require__(/*! ../controllers/responseController.js */ \"./src/app/controllers/responseController.js\");\nconst isLoggedIn = responseController.isLoggedIn;\nconst sendResponse = responseController.sendResponse;\n\nmodule.exports = app => {\n  app.get(\"/api/me\", isLoggedIn, (req, res) => {\n    return sendResponse(res, null, req.user);\n  });\n\n  app.get(\"/api/user/:userId\", (req, res) => {\n    req.models.user.findOne({\n      where: {\n        id: req.params.userId\n      },\n      include: [{ model: req.models.userProperty }, { model: req.models.userPreference }]\n    }).then(user => {\n      user = JSON.parse(JSON.stringify(user));\n\n      if (req.user && !req.user.isAdmin && req.query.adminView) {\n        user.userProperties.forEach(_ => {\n          const prop = _;\n\n          prop.propValue = Boolean(prop.propValue);\n        });\n      }\n\n      return sendResponse(res, null, user);\n    }, err => sendResponse(res, err));\n  });\n\n  app.put(\"/api/user/:userId\", isLoggedIn, (req, res) => {\n    const mutableFields = [\"firstName\", \"lastName\", \"bio\", \"website\", \"imageUrl\"];\n\n    const updateObj = {};\n\n    try {\n      Object.keys(req.body).filter(_ => mutableFields.indexOf(_) !== -1).forEach(fieldKey => {\n        updateObj[fieldKey] = req.body[fieldKey];\n      });\n    } catch (err) {\n      return sendResponse(res, err);\n    }\n\n    req.models.user.update(updateObj, {\n      where: {\n        id: req.params.userId\n      }\n    }).then(data => sendResponse(res, null, data), err => sendResponse(res, err));\n  });\n\n  /**\n   * Deactivates user account\n   */\n  app.delete(\"/api/user/:userId\", isLoggedIn, (req, res) => {\n    req.models.user.update({\n      status: \"15\"\n    }, {\n      where: {\n        id: req.user.id\n      }\n    }).then(() => req.models.user.destroy({\n      where: {\n        id: req.user.id\n      }\n    })).then(() => {\n      return sendResponse(res, null, {});\n    }, err => sendResponse(res, err));\n  });\n};\n\n//# sourceURL=webpack:///./src/app/routes/user.js?");

/***/ }),

/***/ "./src/app/routes/vq-services.js":
/*!***************************************!*\
  !*** ./src/app/routes/vq-services.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var NodeGeocoder = __webpack_require__(/*! node-geocoder */ \"node-geocoder\");\nvar options = {\n    provider: \"google\",\n    // Optional depending on the providers\n    httpAdapter: \"http\" // Default\n    // apiKey: 'YOUR_API_KEY', // for Mapquest, OpenCage, Google Premier\n    // formatter: null         // 'gpx', 'string', ...\n};\n\nvar geocoder = NodeGeocoder(options);\n\nmodule.exports = app => {\n    app.post(\"/api/vq-services/address-validation\", (req, res) => {\n        const addressBody = req.body;\n\n        const addressString = `${addressBody.street}, ${addressBody.city}, ${addressBody.countryCode}`;\n\n        geocoder.geocode(addressString, (err, data) => {\n            if (err) {\n                res.status(400).send(err);\n            }\n\n            return res.send(data);\n        });\n    });\n};\n\n//# sourceURL=webpack:///./src/app/routes/vq-services.js?");

/***/ }),

/***/ "./src/app/services/UploadService.js":
/*!*******************************************!*\
  !*** ./src/app/services/UploadService.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const randomToken = __webpack_require__(/*! random-token */ \"random-token\");\nconst sharp = __webpack_require__(/*! sharp */ \"sharp\");\nconst s3 = __webpack_require__(/*! ../config/bucket.js */ \"./src/app/config/bucket.js\");\n\nmodule.exports = bucket => {\n    const convertPicture = (buffer, fileFormat, width, height) => new Promise((resolve, reject) => {\n\n        if (width && height) {\n            return sharp(buffer).resize(width, height, {\n                kernel: sharp.kernel.lanczos2,\n                interpolator: sharp.interpolator.nohalo\n            }).crop(sharp.strategy.entropy)\n            // .background('white')\n            // .embed()\n            .toBuffer((err, imgBuffer) => {\n                if (err) {\n                    console.error(err);\n\n                    return reject(err);\n                }\n\n                return resolve(imgBuffer);\n            });\n        }\n\n        return sharp(buffer)\n        /**\n            .resize(width, height, {\n                kernel: sharp.kernel.lanczos2,\n                interpolator: sharp.interpolator.nohalo\n            })\n        */\n        .toBuffer((err, imgBuffer) => {\n            if (err) {\n                console.error(err);\n\n                return reject(err);\n            }\n\n            return resolve(imgBuffer);\n        });\n    });\n\n    const uploadToBucket = (rawBuffer, namespace, fileFormat, width, height, callback) => {\n        convertPicture(rawBuffer, fileFormat, width, height).then(buffer => {\n            const key = `${namespace}/${randomToken(32)}.jpeg`;\n            const params = {\n                Bucket: bucket,\n                Body: buffer,\n                Key: key,\n                ContentType: \"image/jpeg\"\n            };\n\n            s3.upload(params, (err, pres) => {\n                if (err) {\n                    return callback(err);\n                }\n\n                return callback(null, pres.Location);\n            });\n        });\n    };\n\n    const uploadFileToBucket = (rawBuffer, namespace, fileFormat, callback) => {\n        const key = `${namespace}/${randomToken(32)}.${fileFormat}`;\n\n        const params = {\n            Bucket: bucket,\n            Body: rawBuffer,\n            Key: key,\n            ContentType: \"application/pdf\"\n        };\n\n        s3.upload(params, (err, pres) => {\n            if (err) {\n                return callback(err);\n            }\n\n            return callback(null, pres.Location);\n        });\n    };\n\n    return {\n        uploadFileToBucket,\n        uploadToBucket\n    };\n};\n\n//# sourceURL=webpack:///./src/app/services/UploadService.js?");

/***/ }),

/***/ "./src/app/services/cryptoService.js":
/*!*******************************************!*\
  !*** ./src/app/services/cryptoService.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst CryptoJS = __webpack_require__(/*! crypto-js */ \"crypto-js\");\n\nconst encodeObj = obj => {\n    // the default value for private key sucks...\n    const encodedHash = CryptoJS.AES.encrypt(JSON.stringify(obj), process.env.SECRET || \"blabla\").toString();\n\n    return encodedHash;\n};\n\nconst decodeObj = encodedHash => {\n    // the default value for private key sucks...\n    const obj = JSON.parse(CryptoJS.AES.decrypt(encodedHash, process.env.SECRET || \"blabla\").toString(CryptoJS.enc.Utf8));\n\n    return obj;\n};\n\nconst buildVerificationUrl = (tenantId, user) => {\n    const verificationToken = encodeObj(user);\n    const builtServerUrl = process.env.APP_URL ? process.env.APP_URL.replace('?tenantId', tenantId) : `http://localhost:${process.env.PORT}`;\n    const verificationUrl = `${builtServerUrl}/api/verify/email?code=${verificationToken}`;\n\n    return verificationUrl;\n};\n\nmodule.exports = {\n    encodeObj,\n    decodeObj,\n    buildVerificationUrl\n};\n\n//# sourceURL=webpack:///./src/app/services/cryptoService.js?");

/***/ }),

/***/ "./src/app/services/emailService.js":
/*!******************************************!*\
  !*** ./src/app/services/emailService.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const ejs = __webpack_require__(/*! ejs */ \"ejs\");\nconst mandrill = __webpack_require__(/*! mandrill-api/mandrill */ \"mandrill-api/mandrill\");\nconst custProvider = __webpack_require__(/*! ../config/custProvider.js */ \"./src/app/config/custProvider.js\");\nconst unescape = __webpack_require__(/*! unescape */ \"unescape\");\nconst _ = __webpack_require__(/*! underscore */ \"underscore\");\n\nconst mandrill_client = new mandrill.Mandrill(process.env.MANDRILL);\n\nconst EMAILS = {\n\tWELCOME: \"welcome\",\n\tPASSWORD_RESET: \"password-reset\",\n\tREQUEST_SENT: \"new-request-sent\",\n\tREQUEST_RECEIVED: \"new-request-received\",\n\tNEW_LISTING: \"new-task\"\n};\n\nconst checkIfShouldSendEmail = (models, emailCode, userId, cb, shouldNotCb) => models.userProperty.findOne({\n\twhere: {\n\t\t$and: [{\n\t\t\tpropKey: \"EMAIL_\" + emailCode\n\t\t}, {\n\t\t\tpropValue: \"1\"\n\t\t}, {\n\t\t\tuserId\n\t\t}]\n\t}\n}).then(isDeactived => {\n\tif (!isDeactived) {\n\t\treturn cb();\n\t}\n\n\tif (shouldNotCb) {\n\t\tshouldNotCb();\n\t}\n}, err => {\n\tconsole.error(err);\n});\n\nconst getEmailBody = (models, code) => models.post.findOne({\n\twhere: {\n\t\t$and: [{\n\t\t\ttype: \"email\"\n\t\t}, {\n\t\t\tcode\n\t\t}]\n\t} });\n\nconst getEventEmails = (models, eventTrigger) => models.post.findAll({\n\twhere: {\n\t\t$and: [{\n\t\t\ttype: \"email\"\n\t\t}, {\n\t\t\teventTrigger\n\t\t}]\n\t} });\n\nconst sendEmailsOnEvent = (models, eventTrigger, demandUserEmails, supplyUserEmails, emailData) => custProvider.getConfig(models).then(config => {\n\tif (typeof emailData === \"string\") {\n\t\temailData = {\n\t\t\tACTION_URL: emailData,\n\t\t\tLISTING_TITLE: \"<LISTING_TITLE NOT SPECIFIED>\",\n\t\t\tSENDER_FIRST_NAME: \"<SENDER_FIRST_NAME NOT SPECIFIED>\",\n\t\t\tSENDER_LAST_NAME: \"<SENDER_LAST_NAME NOT SPECIFIED>\",\n\t\t\tMESSAGE_BODY: \"<MESSAGE_BODY NOT SPECIFIED>\",\n\t\t\tEMAIL_SETTINGS_URL: `${config.DOMAIN}/app/account/notifications`\n\t\t};\n\t} else {\n\t\temailData.ACTION_URL = emailData.ACTION_URL || \"<ACTION_URL NOT SPECIFIED>\";\n\t\temailData.SUPPLY_ACTION_URL = emailData.SUPPLY_ACTION_URL || \"<SUPPLY_ACTION_URL NOT SPECIFIED>\";\n\t\temailData.LISTING_TITLE = emailData.LISTING_TITLE || \"<LISTING_TITLE NOT SPECIFIED>\";\n\t\temailData.SENDER_FIRST_NAME = emailData.SENDER_FIRST_NAME || \"<SENDER_FIRST_NAME NOT SPECIFIED>\";\n\t\temailData.SENDER_LAST_NAME = emailData.SENDER_LAST_NAME || \"<SENDER_LAST_NAME NOT SPECIFIED>\";\n\t\temailData.MESSAGE_BODY = emailData.MESSAGE_BODY || \"<MESSAGE_BODY NOT SPECIFIED>\";\n\t\temailData.EMAIL_SETTINGS_URL = emailData.EMAIL_SETTINGS_URL = `${config.DOMAIN}/app/account/notifications`;\n\t}\n\n\temailData.CONFIG = config;\n\n\tgetEventEmails(models, eventTrigger).then(emails => {\n\t\temails.filter(email => email.targetUserType && email.eventTrigger).forEach(email => {\n\t\t\tconst params = {};\n\t\t\tlet compiledEmail;\n\n\t\t\tconst specialEmailData = email.targetUserType === 2 ? _.extend({}, emailData, {\n\t\t\t\tACTION_URL: emailData.SUPPLY_ACTION_URL\n\t\t\t}) : emailData;\n\n\t\t\ttry {\n\t\t\t\tcompiledEmail = ejs.compile(unescape(email.body))(specialEmailData);\n\t\t\t} catch (err) {\n\t\t\t\treturn console.error(err);\n\t\t\t}\n\n\t\t\tparams.subject = email.title;\n\n\t\t\tconsole.log(`Sending email ${email.code} (event: ${eventTrigger}) to ${email.targetUserType === 1 ? demandUserEmails.length : supplyUserEmails.length} users.`);\n\n\t\t\treturn sendEmail(models, compiledEmail, email.targetUserType === 1 ? demandUserEmails : supplyUserEmails, params, err => {\n\t\t\t\tif (err) {\n\t\t\t\t\tconsole.error(err);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t});\n});\n\nconst getEmailAndSend = (models, emailCode, email, emailData) => custProvider.getConfig(models).then(config => {\n\t// in case emails are disabled... only the welcome email can be sent.\n\tif (emailCode !== EMAILS.WELCOME && config.EMAILS_ENABLED !== \"1\") {\n\t\treturn;\n\t}\n\n\tgetEmailBody(models, emailCode).then(emailBody => {\n\t\tconst params = {};\n\t\tvar compiledEmail;\n\n\t\tif (!emailBody) {\n\t\t\treturn console.error(`Email template \"${emailCode}\" has not been found`);\n\t\t}\n\n\t\tif (typeof emailData === \"string\") {\n\t\t\temailData = {\n\t\t\t\tACTION_URL: emailData,\n\t\t\t\tLISTING_TITLE: \"<LISTING_TITLE NOT SPECIFIED>\",\n\t\t\t\tSENDER_FIRST_NAME: \"<SENDER_FIRST_NAME NOT SPECIFIED>\",\n\t\t\t\tSENDER_LAST_NAME: \"<SENDER_LAST_NAME NOT SPECIFIED>\",\n\t\t\t\tMESSAGE_BODY: \"<MESSAGE_BODY NOT SPECIFIED>\",\n\t\t\t\tEMAIL_SETTINGS_URL: `${config.DOMAIN}/app/account/notifications`\n\t\t\t};\n\t\t} else {\n\t\t\temailData.ACTION_URL = emailData.ACTION_URL || \"<ACTION_URL NOT SPECIFIED>\";\n\t\t\temailData.LISTING_TITLE = emailData.LISTING_TITLE || \"<LISTING_TITLE NOT SPECIFIED>\";\n\t\t\temailData.SENDER_FIRST_NAME = emailData.SENDER_FIRST_NAME || \"<SENDER_FIRST_NAME NOT SPECIFIED>\";\n\t\t\temailData.SENDER_LAST_NAME = emailData.SENDER_LAST_NAME || \"<SENDER_LAST_NAME NOT SPECIFIED>\";\n\t\t\temailData.MESSAGE_BODY = emailData.MESSAGE_BODY || \"<MESSAGE_BODY NOT SPECIFIED>\";\n\t\t\temailData.EMAIL_SETTINGS_URL = emailData.EMAIL_SETTINGS_URL = `${config.DOMAIN}/app/account/notifications`;\n\t\t}\n\n\t\temailData.CONFIG = config;\n\n\t\ttry {\n\t\t\tcompiledEmail = ejs.compile(unescape(emailBody.body))(emailData);\n\t\t} catch (err) {\n\t\t\treturn console.error(err);\n\t\t}\n\n\t\tparams.subject = emailBody.title;\n\n\t\treturn sendEmail(models, compiledEmail, typeof email === \"string\" ? [email] : email, params, err => {\n\t\t\tif (err) {\n\t\t\t\tconsole.error(err);\n\t\t\t}\n\t\t});\n\t});\n});\n\nconst sendNewTenant = (email, VERIFICATION_LINK) => {\n\tconst emailBody = `\n\t\t<%- VERIFICATION_LINK %>\n\t`;\n\n\tconst params = {};\n\n\tconst html = ejs.compile(unescape(emailBody))({\n\t\tVERIFICATION_LINK\n\t});\n\n\tparams.subject = \"Verify your email\";\n\n\tconst message = getRawMessagePrototype();\n\n\tmessage.subject = params.subject;\n\tmessage.html = html;\n\tmessage.text = html;\n\tmessage.to = [{\n\t\temail,\n\t\ttype: \"to\"\n\t}];\n\n\tvar lAsync = false;\n\tvar ip_pool = \"Main Pool\";\n\n\tmandrill_client.messages.send({\n\t\t\"message\": message,\n\t\t\"async\": lAsync,\n\t\t\"ip_pool\": ip_pool\n\t}, result => {\n\t\tconsole.log(result);\n\t}, e => {\n\t\tconsole.log(\"A mandrill error occurred: \" + e.name + \" - \" + e.message);\n\t});\n};\n\nconst sendTemplateEmail = (email, subject, body) => {\n\tconst message = getRawMessagePrototype();\n\n\tmessage.subject = subject;\n\tmessage.html = body;\n\tmessage.text = body;\n\tmessage.to = [{\n\t\temail,\n\t\ttype: \"to\"\n\t}];\n\n\tvar lAsync = false;\n\tvar ip_pool = \"Main Pool\";\n\n\tmandrill_client.messages.send({\n\t\t\"message\": message,\n\t\t\"async\": lAsync,\n\t\t\"ip_pool\": ip_pool\n\t}, result => {\n\t\tconsole.log(result);\n\t}, e => {\n\t\tconsole.log(\"A mandrill error occurred: \" + e.name + \" - \" + e.message);\n\t});\n};\n\nconst getRawMessagePrototype = (fromName, supportEmail, domain) => ({\n\t\"from_email\": \"noreply@vq-labs.com\",\n\t\"from_name\": fromName,\n\t\"to\": [],\n\t\"headers\": {\n\t\t\"Reply-To\": supportEmail\n\t},\n\t\"important\": false,\n\t\"global_merge_vars\": [],\n\t\"metadata\": {\n\t\t\"website\": domain\n\t},\n\t\"recipient_metadata\": [{}]\n});\n\nconst getMessagePrototype = models => new Promise((resolve, reject) => {\n\tcustProvider.getConfig(models).then(config => {\n\t\treturn resolve(getRawMessagePrototype(config.NAME || \"VQ LABS\", config.SUPPORT_EMAIL, config.DOMAIN));\n\t}, reject);\n});\n\nfunction sendEmail(models, html, tEmails, params, callback) {\n\tgetMessagePrototype(models).then(message => {\n\t\tmessage.subject = params.subject;\n\t\tmessage.html = html;\n\t\tmessage.text = html;\n\t\tmessage.to = tEmails.map(email => {\n\t\t\treturn {\n\t\t\t\temail,\n\t\t\t\ttype: \"to\"\n\t\t\t};\n\t\t});\n\n\t\tvar lAsync = false;\n\t\tvar ip_pool = \"Main Pool\";\n\n\t\tmandrill_client.messages.send({\n\t\t\t\"message\": message,\n\t\t\t\"async\": lAsync,\n\t\t\t\"ip_pool\": ip_pool\n\t\t}, result => {\n\t\t\tconsole.log(result);\n\n\t\t\tif (callback) {\n\t\t\t\tcallback(null, result);\n\t\t\t}\n\t\t}, e => {\n\t\t\tconsole.log(\"A mandrill error occurred: \" + e.name + \" - \" + e.message);\n\n\t\t\treturn callback(e);\n\t\t});\n\t});\n}\n\nmodule.exports = {\n\tEMAILS,\n\tcheckIfShouldSendEmail,\n\tsendEmailsOnEvent,\n\tgetEmailAndSend,\n\tsendEmail,\n\tsendTemplateEmail,\n\tsendNewTenant\n};\n\n//# sourceURL=webpack:///./src/app/services/emailService.js?");

/***/ }),

/***/ "./src/app/services/emailTemplateGenerator.js":
/*!****************************************************!*\
  !*** ./src/app/services/emailTemplateGenerator.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(__dirname) {const path = __webpack_require__(/*! path */ \"path\");\nconst fs = __webpack_require__(/*! graceful-fs */ \"graceful-fs\");\n\nconst defaultValuesForReplace = {\n    companyName: \"VQ-Labs\",\n    address: \"Robert-Bosch-Strasse 49\\n\" + \"69190 Walldorf\\n\" + \"GERMANY\",\n    telephone: \"info@vq-labs.com\",\n    website: \"vq-labs.com\"\n};\n\nconst replaceDefaultValues = html => {\n    Object.keys(defaultValuesForReplace).forEach(function (key) {\n        html = html.replace(new RegExp(\"#\" + key + \"#\", \"g\"), defaultValuesForReplace[key]);\n    });\n\n    return html;\n};\n\nconst generateSingleColumnEmail = (heading, title, body, cb) => {\n    fs.readFile(path.join(__dirname, \"../emailTemplates/singleColumn.html\"), \"utf8\", (err, html) => {\n\n        var headingRegExp = new RegExp(\"#heading#\", \"g\");\n        var titleRegExp = new RegExp(\"#title#\", \"g\");\n        var bodyRegExp = new RegExp(\"#body#\", \"g\");\n\n        html = replaceDefaultValues(html);\n        html = html.replace(headingRegExp, heading);\n        html = html.replace(titleRegExp, title);\n        html = html.replace(bodyRegExp, body);\n\n        return cb(html);\n    });\n};\n\nconst generateDoubleColumnEmail = (heading, title, bodyLeft, bodyRight, cb) => {\n    fs.readFile(path.join(__dirname, \"../emailTemplates/doubleColumn.html\"), \"utf8\", (err, html) => {\n\n        var headingRegExp = new RegExp(\"#heading#\", \"g\");\n        var titleRegExp = new RegExp(\"#title#\", \"g\");\n        var bodyLeftRegExp = new RegExp(\"#bodyLeft#\", \"g\");\n        var bodyRightRegExp = new RegExp(\"#bodyRight#\", \"g\");\n\n        html = replaceDefaultValues(html);\n        html = html.replace(headingRegExp, heading);\n        html = html.replace(titleRegExp, title);\n        html = html.replace(bodyLeftRegExp, bodyLeft);\n        html = html.replace(bodyRightRegExp, bodyRight);\n\n        return cb(html);\n    });\n};\n\nconst generateTriplePanelTopEmail = (heading, title, bodyTop, bodyLeft, bodyRight, cb) => {\n    fs.readFile(path.join(__dirname, \"../emailTemplates/triplePanelTop.html\"), \"utf8\", (err, html) => {\n\n        var headingRegExp = new RegExp(\"#heading#\", \"g\");\n        var titleRegExp = new RegExp(\"#title#\", \"g\");\n        var bodyTopRegExp = new RegExp(\"#bodyTop#\", \"g\");\n        var bodyLeftRegExp = new RegExp(\"#bodyLeft#\", \"g\");\n        var bodyRightRegExp = new RegExp(\"#bodyRight#\", \"g\");\n\n        html = replaceDefaultValues(html);\n        html = html.replace(headingRegExp, heading);\n        html = html.replace(titleRegExp, title);\n        html = html.replace(bodyTopRegExp, bodyTop);\n        html = html.replace(bodyLeftRegExp, bodyLeft);\n        html = html.replace(bodyRightRegExp, bodyRight);\n\n        return cb(html);\n    });\n};\n\nconst generateTriplePanelBottomEmail = (heading, title, bodyLeft, bodyRight, bodyBottom, cb) => {\n    fs.readFile(path.join(__dirname, \"../emailTemplates/triplePanelBottom.html\"), \"utf8\", (err, html) => {\n\n        var headingRegExp = new RegExp(\"#heading#\", \"g\");\n        var titleRegExp = new RegExp(\"#title#\", \"g\");\n        var bodyLeftRegExp = new RegExp(\"#bodyLeft#\", \"g\");\n        var bodyRightRegExp = new RegExp(\"#bodyRight#\", \"g\");\n        var bodyBottomRegExp = new RegExp(\"#bodyBottom#\", \"g\");\n\n        html = replaceDefaultValues(html);\n        html = html.replace(headingRegExp, heading);\n        html = html.replace(titleRegExp, title);\n        html = html.replace(bodyLeftRegExp, bodyLeft);\n        html = html.replace(bodyRightRegExp, bodyRight);\n        html = html.replace(bodyBottomRegExp, bodyBottom);\n\n        return cb(html);\n    });\n};\n\nconst generateFourPanelEmail = (heading, title, bodyBottom, bodyLeft, bodyRight, cb) => {\n    fs.readFile(path.join(__dirname, \"../emailTemplates/fourPanel.html\"), \"utf8\", (err, html) => {\n\n        var headingRegExp = new RegExp(\"#heading#\", \"g\");\n        var titleRegExp = new RegExp(\"#title#\", \"g\");\n        // var bodyTopRegExp = new RegExp(\"#bodyTop#\", \"g\");\n        var bodyLeftRegExp = new RegExp(\"#bodyLeft#\", \"g\");\n        var bodyRightRegExp = new RegExp(\"#bodyRight#\", \"g\");\n        var bodyBottomRegExp = new RegExp(\"#bodyBottom#\", \"g\");\n\n        html = replaceDefaultValues(html);\n        html = html.replace(headingRegExp, heading);\n        html = html.replace(titleRegExp, title);\n        // html = html.replace(bodyTopRegExp, bodyTop);\n        html = html.replace(bodyLeftRegExp, bodyLeft);\n        html = html.replace(bodyRightRegExp, bodyRight);\n        html = html.replace(bodyBottomRegExp, bodyBottom);\n\n        return cb(html);\n    });\n};\n\nmodule.exports = {\n    generateSingleColumnEmail,\n    generateDoubleColumnEmail,\n    generateTriplePanelTopEmail,\n    generateTriplePanelBottomEmail,\n    generateFourPanelEmail\n};\n/* WEBPACK VAR INJECTION */}.call(this, \"/\"))\n\n//# sourceURL=webpack:///./src/app/services/emailTemplateGenerator.js?");

/***/ }),

/***/ "./src/app/services/subscriptionService.js":
/*!*************************************************!*\
  !*** ./src/app/services/subscriptionService.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const chargebee = __webpack_require__(/*! chargebee */ \"chargebee\");\nconst async = __webpack_require__(/*! async */ \"async\");\n\nchargebee.configure({\n  site: process.env.CHARGEBEE_SITE,\n  api_key: process.env.CHARGEBEE_API_KEY\n});\n\nconst createCustomer = (tenantRef, cb) => {\n  chargebee.customer.create({\n    first_name: tenantRef.firstName,\n    last_name: tenantRef.lastName,\n    email: tenantRef.email,\n    locale: \"en-GB\",\n    meta_data: {\n      tenantId: tenantRef.tenantId,\n      marketplaceUrl: `https://${tenantRef.tenantId}.vqmarketplace.com`,\n      marketplaceType: tenantRef.marketplaceType,\n      country: tenantRef.country\n    }\n  }).request((err, result) => {\n    if (err) {\n      //handle error\n      console.log(err);\n\n      return cb(err);\n    }\n\n    tenantRef.chargebeeCustomerId = result.customer.id;\n\n    tenantRef.save().then(() => cb && cb(undefined, tenantRef)).catch(err => cb && cb(err, tenantRef));\n  });\n};\n\nconst listPlans = cb => {\n  const plans = [];\n\n  chargebee.plan.list({\n    \"limit\": 5,\n    \"status\": \"active\"\n  }).request((error, result) => {\n    if (error) {\n      //handle error\n      console.log(error);\n\n      cb(error);\n    } else {\n      for (var i = 0; i < result.list.length; i++) {\n\n        var entry = result.list[i];\n\n        plans.push(entry.plan);\n      }\n\n      cb(undefined, plans);\n    }\n  });\n};\n\nconst chargebeeNewSubCheckout = (subId, tenantRef, cb) => {\n  chargebee.hosted_page.checkout_new({\n    subscription: {\n      plan_id: subId\n    },\n    customer: {\n      email: tenantRef.email,\n      first_name: tenantRef.firstName,\n      last_name: tenantRef.lastName,\n      locale: \"en\"\n    }\n  }).request(function (error, result) {\n    if (error) {\n      //handle error\n      console.log(error);\n\n      cb(error);\n    } else {\n      console.log(result);\n      var hosted_page = result.hosted_page;\n\n      cb(undefined, hosted_page);\n    }\n  });\n};\n\nconst chargebeeCustomerPortalSignIn = (tenantRef, cb) => {\n  async.waterfall([cb => {\n    if (tenantRef.chargebeeCustomerId) {\n\n      return cb();\n    }\n\n    createCustomer(tenantRef, (err, newTenantRef) => {\n      if (err) {\n        cb(err);\n\n        return;\n      }\n\n      tenantRef = newTenantRef;\n\n      cb();\n    });\n  }, cb => {\n    chargebee.portal_session.create({\n      redirect_url: `https://${tenantRef.tenantId}.vqmarketplace.com`,\n      customer: {\n        id: tenantRef.chargebeeCustomerId\n      }\n    }).request((err, result) => {\n      if (err) {\n        //handle error\n        console.log(err);\n\n        return cb(err);\n      }\n\n      console.log(result);\n\n      cb(undefined, result);\n    });\n  }], cb);\n\n  /**\n    chargebee.subscription.create({\n        plan_id : \"full-ps4-vr\", \n        customer : {\n          email : \"john@user.com\", \n          first_name : \"John\", \n          last_name : \"Doe\", \n          locale : \"en-GB\", \n          phone : \"+1-949-999-9999\"\n        }, \n        billing_address : {\n          first_name : \"John\", \n          last_name : \"Doe\", \n          line1 : \"PO Box 9999\", \n          city : \"Walnut\", \n          state : \"California\", \n          zip : \"91789\", \n          country : \"US\"\n        }\n      }).request(function(error,result){\n        if(error){\n          //handle error\n          console.log(error);\n        }else{\n          console.log(result);\n          var subscription = result.subscription;\n          var customer = result.customer;\n          var card = result.card;\n          var invoice = result.invoice;\n          var unbilled_charge = result.unbilled_charge;\n        }\n         cb(error, result);\n      });\n      */\n};\n\n/**\n * Creates customer entity in external CRM and Billing Services for tenant and saves the reference.\n */\nconst ensureCustomerDataSaved = (tenantRef, cb) => {\n  console.log(\"Creating Chargebee Customer\");\n\n  async.waterfall([cb => {\n    chargebee.customer.create({\n      first_name: tenantRef.firstName,\n      last_name: tenantRef.lastName,\n      email: tenantRef.email,\n      locale: \"en-GB\",\n      meta_data: {\n        tenantId: tenantRef.tenantId,\n        marketplaceUrl: `https://${tenantRef.tenantId}.vqmarketplace.com`,\n        marketplaceType: tenantRef.marketplaceType,\n        country: tenantRef.country\n      }\n    }).request((err, result) => {\n      if (err) {\n        cb(err);\n\n        return;\n      }\n\n      tenantRef.chargebeeCustomerId = result.customer.id;\n\n      cb();\n\n      return;\n    });\n  }, cb => {\n    tenantRef.save().then(() => cb()).catch(cb);\n  }, cb => {\n    chargebee.subscription.create_for_customer(tenantRef.chargebeeCustomerId, {\n      plan_id: \"starter\"\n    }).request((err, result) => {\n      if (err) {\n        console.log(err);\n\n        cb(err);\n\n        return;\n      }\n\n      tenantRef.chargebeeActiveSubscriptionId = result.subscription.id;\n\n      cb();\n\n      return;\n    });\n  }, cb => {\n    tenantRef.save().then(() => cb()).catch(cb);\n  }], err => {\n    if (cb) {\n      cb(err, tenantRef);\n    }\n  });\n};\n\nconst createSubscription = (data, cb) => {\n  chargebee.customer.create({\n    /**\n    first_name : data.firstName, \n    last_name : data.lastName, \n    email : data.email, \n    locale : \"en-GB\",\n    billing_address: {\n      first_name : \"John\", \n      last_name : \"Doe\", \n      line1 : \"PO Box 9999\", \n      city : \"Walnut\", \n      state : \"California\", \n      zip : \"91789\", \n      country : \"US\"\n    }\n    */\n  }).request(function (error, result) {\n    if (error) {\n      //handle error\n      console.log(error);\n    } else {\n      console.log(result);\n      var customer = result.customer;\n      var card = result.card;\n    }\n  });\n\n  /**\n    chargebee.subscription.create({\n        plan_id : \"full-ps4-vr\", \n        customer : {\n          email : \"john@user.com\", \n          first_name : \"John\", \n          last_name : \"Doe\", \n          locale : \"en-GB\", \n          phone : \"+1-949-999-9999\"\n        }, \n        billing_address : {\n          first_name : \"John\", \n          last_name : \"Doe\", \n          line1 : \"PO Box 9999\", \n          city : \"Walnut\", \n          state : \"California\", \n          zip : \"91789\", \n          country : \"US\"\n        }\n      }).request(function(error,result){\n        if(error){\n          //handle error\n          console.log(error);\n        }else{\n          console.log(result);\n          var subscription = result.subscription;\n          var customer = result.customer;\n          var card = result.card;\n          var invoice = result.invoice;\n          var unbilled_charge = result.unbilled_charge;\n        }\n         cb(error, result);\n      });\n      */\n};\n\nconst getSubscription = () => {\n  chargebee.subscription.create({\n    plan_id: \"basic\",\n    customer: {\n      email: \"john@user.com\",\n      first_name: \"John\",\n      last_name: \"Doe\",\n      locale: \"fr-CA\",\n      phone: \"+1-949-999-9999\"\n    },\n    billing_address: {\n      first_name: \"John\",\n      last_name: \"Doe\",\n      line1: \"PO Box 9999\",\n      city: \"Walnut\",\n      state: \"California\",\n      zip: \"91789\",\n      country: \"US\"\n    }\n  }).request(function (error, result) {\n    if (error) {\n      //handle error\n      console.log(error);\n    } else {\n      console.log(result);\n      var subscription = result.subscription;\n      var customer = result.customer;\n      var card = result.card;\n      var invoice = result.invoice;\n      var unbilled_charge = result.unbilled_charge;\n    }\n  });\n};\n\nmodule.exports = {\n  listPlans,\n  chargebeeCustomerPortalSignIn,\n  ensureCustomerDataSaved,\n  createSubscription,\n  getSubscription,\n  chargebeeNewSubCheckout\n};\n\n//# sourceURL=webpack:///./src/app/services/subscriptionService.js?");

/***/ }),

/***/ "./src/app/utils/index.js":
/*!********************************!*\
  !*** ./src/app/utils/index.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("const stringToSlug = str => {\n    str = str.replace(/^\\s+|\\s+$/g, \"\"); // trim\n    str = str.toLowerCase();\n\n    // remove accents, swap  for n, etc\n    var from = \"/_,:;\";\n    var to = \"aaaaeeeeiiiioooouuuunc------\";\n\n    for (var i = 0, l = from.length; i < l; i++) {\n        str = str.replace(new RegExp(from.charAt(i), \"g\"), to.charAt(i));\n    }\n\n    str = str.replace(/[^a-z0-9 -]/g, \"\") // remove invalid chars\n    .replace(/\\s+/g, \"-\") // collapse whitespace and replace by -\n    .replace(/-+/g, \"-\"); // collapse dashes\n\n    return str;\n};\n\nconst transformJSDateToSqlFormat = date => date.toISOString().slice(0, 19).replace(\"T\", \" \");\n\nconst getUtcUnixTimeNow = () => {\n    const now = new Date();\n    const nowUtc = new Date(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate(), now.getUTCHours(), now.getUTCMinutes(), now.getUTCSeconds());\n    const nowUtcUnix = nowUtc.getTime() / 1000;\n\n    return nowUtcUnix;\n};\n\nmodule.exports = {\n    getUtcUnixTimeNow,\n    stringToSlug,\n    transformJSDateToSqlFormat\n};\n\n//# sourceURL=webpack:///./src/app/utils/index.js?");

/***/ }),

/***/ "./src/example-configs sync recursive ^\\.\\/.*\\/categories\\.json$":
/*!*************************************************************!*\
  !*** ./src/example-configs sync ^\.\/.*\/categories\.json$ ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var map = {\n\t\"./bitcoinmeetup/categories.json\": \"./src/example-configs/bitcoinmeetup/categories.json\",\n\t\"./blank/categories.json\": \"./src/example-configs/blank/categories.json\",\n\t\"./products/categories.json\": \"./src/example-configs/products/categories.json\",\n\t\"./rentals/categories.json\": \"./src/example-configs/rentals/categories.json\",\n\t\"./services/categories.json\": \"./src/example-configs/services/categories.json\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tvar id = map[req];\n\tif(!(id + 1)) { // check for number or string\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn id;\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"./src/example-configs sync recursive ^\\\\.\\\\/.*\\\\/categories\\\\.json$\";\n\n//# sourceURL=webpack:///./src/example-configs_sync_^\\.\\/.*\\/categories\\.json$?");

/***/ }),

/***/ "./src/example-configs sync recursive ^\\.\\/.*\\/config\\.json$":
/*!*********************************************************!*\
  !*** ./src/example-configs sync ^\.\/.*\/config\.json$ ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var map = {\n\t\"./bitcoinmeetup/config.json\": \"./src/example-configs/bitcoinmeetup/config.json\",\n\t\"./blank/config.json\": \"./src/example-configs/blank/config.json\",\n\t\"./offers/config.json\": \"./src/example-configs/offers/config.json\",\n\t\"./products/config.json\": \"./src/example-configs/products/config.json\",\n\t\"./rentals/config.json\": \"./src/example-configs/rentals/config.json\",\n\t\"./services/config.json\": \"./src/example-configs/services/config.json\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tvar id = map[req];\n\tif(!(id + 1)) { // check for number or string\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn id;\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"./src/example-configs sync recursive ^\\\\.\\\\/.*\\\\/config\\\\.json$\";\n\n//# sourceURL=webpack:///./src/example-configs_sync_^\\.\\/.*\\/config\\.json$?");

/***/ }),

/***/ "./src/example-configs/bitcoinmeetup/categories.json":
/*!***********************************************************!*\
  !*** ./src/example-configs/bitcoinmeetup/categories.json ***!
  \***********************************************************/
/*! exports provided: 0, 1, 2, 3, default */
/***/ (function(module) {

eval("module.exports = [{\"code\":\"bitcoin\",\"status\":\"0\",\"bigImageUrl\":null,\"imageUrl\":\"https://vqassets-dev.s3.eu-central-1.amazonaws.com/bitcoinmeetup/dc2jjoptw9iyelabzszfe1gxe6hvcuvt.jpeg\",\"label\":\"Bitcoin\",\"minPriceHour\":0,\"desc\":\"Buy / Sell Bitcoin\",\"minQuantity\":0.01,\"maxQuantity\":10,\"quantityStep\":0.01,\"unitOfMeasure\":\"BTC\",\"createdAt\":\"2017-12-18T20:00:49.000Z\",\"updatedAt\":\"2017-12-19T21:17:39.000Z\"},{\"code\":\"ethereum\",\"status\":\"0\",\"bigImageUrl\":null,\"imageUrl\":\"https://vqassets-dev.s3.eu-central-1.amazonaws.com/bitcoinmeetup/0o4w27f5fb8sw37r31gc8f49zq4qphf9.jpeg\",\"label\":\"Ethereum\",\"minPriceHour\":0,\"desc\":\"Buy / Sell Ether\",\"minQuantity\":0.1,\"maxQuantity\":10,\"quantityStep\":0.1,\"unitOfMeasure\":\"ETH\",\"createdAt\":\"2017-12-18T20:03:03.000Z\",\"updatedAt\":\"2017-12-19T21:18:03.000Z\"},{\"code\":\"litecoin\",\"status\":\"0\",\"bigImageUrl\":null,\"imageUrl\":\"https://vqassets-dev.s3.eu-central-1.amazonaws.com/bitcoinmeetup/0cd9sde2xemd9myquzld9je8apupxiyq.jpeg\",\"label\":\"Litecoin\",\"minPriceHour\":0,\"desc\":\"Buy / Sell Litecoin\",\"minQuantity\":0.1,\"maxQuantity\":30,\"quantityStep\":0.1,\"unitOfMeasure\":\"LTC\",\"createdAt\":\"2017-12-18T20:01:44.000Z\",\"updatedAt\":\"2017-12-19T21:18:22.000Z\"},{\"code\":\"origintrail\",\"status\":\"0\",\"bigImageUrl\":null,\"imageUrl\":\"https://vqassets-dev.s3.eu-central-1.amazonaws.com/bitcoinmeetup/blqozn8pjsx926wnlt9h0z1rmq5nl7uo.jpeg\",\"label\":\"OriginTrail\",\"minPriceHour\":0,\"desc\":\"OriginTrail (TRAC)\",\"minQuantity\":1000,\"maxQuantity\":1000000,\"quantityStep\":1000,\"unitOfMeasure\":\"TRAC\",\"createdAt\":\"2018-02-04T20:35:11.000Z\",\"updatedAt\":\"2018-02-04T20:35:11.000Z\"}];\n\n//# sourceURL=webpack:///./src/example-configs/bitcoinmeetup/categories.json?");

/***/ }),

/***/ "./src/example-configs/bitcoinmeetup/config.json":
/*!*******************************************************!*\
  !*** ./src/example-configs/bitcoinmeetup/config.json ***!
  \*******************************************************/
/*! exports provided: APP_FOOTER_VISIBLE, COLOR_PRIMARY, COLOR_SECONDARY, COUNTRY_RESTRICTION, CUSTOM_BLOG_PAGE_URL, CUSTOM_CONTACT_PAGE_URL, DATE_FORMAT, DEFAULT_LANG, DOMAIN, EMAILS_ENABLED, GOOGLE_ANALYTICS_ID, LANGUAGES, LISTINGS_DEFAULT_VIEW, LISTINGS_VIEW_GRID, LISTINGS_VIEW_LIST, LISTINGS_VIEW_MAP, LISTING_CATEGORY_MODE, LISTING_DATE_MODE, LISTING_DESCRIPTION_MODE, LISTING_DESC_MODE, LISTING_DISCUSSION_MODE, LISTING_DURATION_MODE, LISTING_EDIT_ENABLED, LISTING_GEOFILTER_COUNTRY_RESTRICTION, LISTING_GEOFILTER_ENABLED, LISTING_GEOFILTER_MODE, LISTING_GEOLOCATION_MODE, LISTING_IMAGES_MODE, LISTING_LOCATION_MODE, LISTING_PRICE_FILTER_ENABLED, LISTING_PRICE_FILTER_MAX, LISTING_PRICE_FILTER_MIN, LISTING_PRICE_FILTER_STEP, LISTING_PRICE_MODE, LISTING_PRICING_MODE, LISTING_QUANTITY_MODE, LISTING_RESTRICTED_POSTAL_CODES, LISTING_TASK_WORKFLOW_ENABLED, LISTING_TIMING_MODE, LISTING_TITLE_MODE, LOGO_URL, MARKETPLACE_PROVISION, MULTIPLE_REQUESTS_ENABLED, NAME, PAYMENTS_ENABLED, PRICING_CONTRACT, PRICING_DEFAULT_CURRENCY, PRICING_HOURLY, PRICING_REQUEST, PROMO_URL, PROMO_URL_SELLERS, SEO_DESCRIPTION, SEO_FAVICON_URL, SEO_TITLE, SOCIAL_FB_USERNAME, SOCIAL_GITHUB_USERNAME, SOCIAL_INSTAGRAM_USERNAME, SOCIAL_TWITTER_USERNAME, SOCIAL_YOUTUBE_USERNAME, TIME_FORMAT, USER_ENABLE_SUPPLY_DEMAND_ACCOUNTS, USER_PROFILE_IMAGE_URL, USER_REQUIRE_PHONE_NUMBER, USER_TYPE_DEMAND_DOCUMENT_REQUIRED, USER_TYPE_DEMAND_LISTING_ENABLED, USER_TYPE_SUPPLY_DOCUMENT_REQUIRED, USER_TYPE_SUPPLY_LISTING_ENABLED, default */
/***/ (function(module) {

eval("module.exports = {\"APP_FOOTER_VISIBLE\":\"0\",\"COLOR_PRIMARY\":\"#000000\",\"COLOR_SECONDARY\":\"#000639\",\"COUNTRY_RESTRICTION\":\"hu\",\"CUSTOM_BLOG_PAGE_URL\":null,\"CUSTOM_CONTACT_PAGE_URL\":null,\"DATE_FORMAT\":\"DD.MM.YYYY\",\"DEFAULT_LANG\":\"en\",\"DOMAIN\":\"https://bitcoinmeetup.vqmarketplace.com\",\"EMAILS_ENABLED\":\"1\",\"GOOGLE_ANALYTICS_ID\":null,\"LANGUAGES\":\"\",\"LISTINGS_DEFAULT_VIEW\":\"2\",\"LISTINGS_VIEW_GRID\":\"0\",\"LISTINGS_VIEW_LIST\":\"1\",\"LISTINGS_VIEW_MAP\":\"1\",\"LISTING_CATEGORY_MODE\":\"2\",\"LISTING_DATE_MODE\":\"2\",\"LISTING_DESCRIPTION_MODE\":\"2\",\"LISTING_DESC_MODE\":\"0\",\"LISTING_DISCUSSION_MODE\":\"0\",\"LISTING_DURATION_MODE\":\"0\",\"LISTING_EDIT_ENABLED\":\"0\",\"LISTING_GEOFILTER_COUNTRY_RESTRICTION\":\"de\",\"LISTING_GEOFILTER_ENABLED\":\"1\",\"LISTING_GEOFILTER_MODE\":\"cities\",\"LISTING_GEOLOCATION_MODE\":\"1\",\"LISTING_IMAGES_MODE\":\"0\",\"LISTING_LOCATION_MODE\":\"2\",\"LISTING_PRICE_FILTER_ENABLED\":\"1\",\"LISTING_PRICE_FILTER_MAX\":\"3999\",\"LISTING_PRICE_FILTER_MIN\":\"49\",\"LISTING_PRICE_FILTER_STEP\":\"10\",\"LISTING_PRICE_MODE\":\"2\",\"LISTING_PRICING_MODE\":\"0\",\"LISTING_QUANTITY_MODE\":\"1\",\"LISTING_RESTRICTED_POSTAL_CODES\":null,\"LISTING_TASK_WORKFLOW_ENABLED\":\"1\",\"LISTING_TIMING_MODE\":\"0\",\"LISTING_TITLE_MODE\":\"2\",\"LOGO_URL\":\"https://vqassets-dev.s3.eu-central-1.amazonaws.com/bitcoinmeetup/dbkw20987ejx5pi4jx9248m6s62bjm0f.jpeg\",\"MARKETPLACE_PROVISION\":\"0\",\"MULTIPLE_REQUESTS_ENABLED\":\"0\",\"NAME\":\"Bitcoin Meetup\",\"PAYMENTS_ENABLED\":\"0\",\"PRICING_CONTRACT\":\"1\",\"PRICING_DEFAULT_CURRENCY\":\"EUR\",\"PRICING_HOURLY\":\"1\",\"PRICING_REQUEST\":\"1\",\"PROMO_URL\":\"https://vqassets-dev.s3.eu-central-1.amazonaws.com/bitcoinmeetup/kgcfiphy4di3l84g584xte3gboyej651.jpeg\",\"PROMO_URL_SELLERS\":\"https://vqassets-dev.s3.eu-central-1.amazonaws.com/bitcoinmeetup/buxyj9nz90tm2ggtmdq47q4remyb3dfu.jpeg\",\"SEO_DESCRIPTION\":\"Buy and Sell bitcoin and other cryptocurrencies from people around you\",\"SEO_FAVICON_URL\":\"https://vqassets-dev.s3.eu-central-1.amazonaws.com/bitcoinmeetup/xvxxwl597jpp5dyg0o0buoqodgmum9lo.jpeg\",\"SEO_TITLE\":\"Bitcoin Meetup\",\"SOCIAL_FB_USERNAME\":\"vqlabs\",\"SOCIAL_GITHUB_USERNAME\":\"vq-labs\",\"SOCIAL_INSTAGRAM_USERNAME\":null,\"SOCIAL_TWITTER_USERNAME\":\"vqlabs\",\"SOCIAL_YOUTUBE_USERNAME\":\"\",\"TIME_FORMAT\":\"HH:mm\",\"USER_ENABLE_SUPPLY_DEMAND_ACCOUNTS\":\"1\",\"USER_PROFILE_IMAGE_URL\":\"https://vqassets-dev.s3.eu-central-1.amazonaws.com/bitcoinmeetup/c619n38mc4reip5q86ift0oiiqopd4sc.jpeg\",\"USER_REQUIRE_PHONE_NUMBER\":\"0\",\"USER_TYPE_DEMAND_DOCUMENT_REQUIRED\":\"0\",\"USER_TYPE_DEMAND_LISTING_ENABLED\":\"1\",\"USER_TYPE_SUPPLY_DOCUMENT_REQUIRED\":\"0\",\"USER_TYPE_SUPPLY_LISTING_ENABLED\":\"1\"};\n\n//# sourceURL=webpack:///./src/example-configs/bitcoinmeetup/config.json?");

/***/ }),

/***/ "./src/example-configs/blank/categories.json":
/*!***************************************************!*\
  !*** ./src/example-configs/blank/categories.json ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module) {

eval("module.exports = [];\n\n//# sourceURL=webpack:///./src/example-configs/blank/categories.json?");

/***/ }),

/***/ "./src/example-configs/blank/config.json":
/*!***********************************************!*\
  !*** ./src/example-configs/blank/config.json ***!
  \***********************************************/
/*! exports provided: NAME, default */
/***/ (function(module) {

eval("module.exports = {\"NAME\":\"VQ Marketplace\"};\n\n//# sourceURL=webpack:///./src/example-configs/blank/config.json?");

/***/ }),

/***/ "./src/example-configs/offers/config.json":
/*!************************************************!*\
  !*** ./src/example-configs/offers/config.json ***!
  \************************************************/
/*! exports provided: NAME, SEO_TITLE, COLOR_PRIMARY, COLOR_SECONDARY, DOMAIN, EMAILS_ENABLED, SOCIAL_FB_USERNAME, SOCIAL_TWITTER_USERNAME, SOCIAL_INSTAGRAM_USERNAME, SOCIAL_YOUTUBE_USERNAME, SOCIAL_GITHUB_USERNAME, LOGO_URL, PROMO_URL, SEO_FAVICON_URL, PROMO_URL_SELLERS, CUSTOM_CONTACT_PAGE_URL, CUSTOM_BLOG_PAGE_URL, LISTING_CUSTOM_CALL_TO_ACTION_MODE, PRICING_HOURLY, PRICING_CONTRACT, PRICING_REQUEST, PRICING_DEFAULT_CURRENCY, LISTING_ENABLE_PUBLIC_VIEW, listing_title_mode, listing_category_mode, LISTING_PUBLIC_VIEW_MODE, listing_description_mode, listing_location_mode, listing_date_mode, listing_price_mode, listing_images_mode, country_restriction, DEFAULT_LANG, LISTING_RESTRICTED_POSTAL_CODES, LISTING_GEOFILTER_COUNTRY_RESTRICTION, LISTING_GEOFILTER_MODE, GOOGLE_ANALYTICS_ID, DATE_FORMAT, TIME_FORMAT, LISTINGS_VIEW_LIST, LISTINGS_VIEW_MAP, LISTINGS_DEFAULT_VIEW, LANGUAGES, LISTING_PRICE_FILTER_MAX, LISTING_PRICE_FILTER_MIN, LISTING_PRICE_FILTER_STEP, USER_TYPE_SUPPLY_LISTING_ENABLED, USER_TYPE_DEMAND_LISTING_ENABLED, USER_TYPE_SUPPLY_DOCUMENT_REQUIRED, USER_TYPE_DEMAND_DOCUMENT_REQUIRED, USER_ENABLE_SUPPLY_DEMAND_ACCOUNTS, USER_ENABLE_PUBLIC_VIEW, LISTING_IMAGES_MODE, LISTING_GEOLOCATION_MODE, LISTING_TIMING_MODE, LISTING_TASK_WORKFLOW_ENABLED, LISTING_QUANTITY_MODE, LISTING_PRICING_MODE, LISTING_PRICE_FILTER_ENABLED, LISTING_EDIT_ENABLED, LISTING_DURATION_MODE, LISTING_DISCUSSION_MODE, LISTING_DESC_MODE, USER_PREFERENCES_ENABLED_FOR_SUPPLY, USER_PREFERENCES_ENABLED_FOR_DEMAND, USER_DOCUMENTS_ENABLED_FOR_SUPPLY, USER_DOCUMENTS_ENABLED_FOR_DEMAND, USER_VERIFICATIONS_ENABLED_FOR_SUPPLY, USER_VERIFICATIONS_ENABLED_FOR_DEMAND, LISTING_TASK_WORKFLOW_FOR_DEMAND_LISTINGS, LISTING_TASK_WORKFLOW_FOR_DEMAND_LISTINGS_REQUEST_STEP_ENABLED, LISTING_TASK_WORKFLOW_FOR_DEMAND_LISTINGS_REQUEST_STEP_MULTIPLE_REQUESTS_ENABLED, LISTING_TASK_WORKFLOW_FOR_DEMAND_LISTINGS_BOOKING_STEP_ENABLED, LISTING_TASK_WORKFLOW_FOR_DEMAND_LISTINGS_COMPLETE_STEP_ENABLED, LISTING_TASK_WORKFLOW_FOR_DEMAND_LISTINGS_REVIEW_STEP_ENABLED, LISTING_TASK_WORKFLOW_FOR_DEMAND_LISTINGS_REVIEW_STEP_REQUIRE_BOTH_REVIEWS, LISTING_TASK_WORKFLOW_FOR_SUPPLY_LISTINGS, LISTING_TASK_WORKFLOW_FOR_SUPPLY_LISTINGS_REQUEST_STEP_ENABLED, LISTING_TASK_WORKFLOW_FOR_SUPPLY_LISTINGS_REQUEST_STEP_MULTIPLE_REQUESTS_ENABLED, LISTING_TASK_WORKFLOW_FOR_SUPPLY_LISTINGS_BOOKING_STEP_ENABLED, LISTING_TASK_WORKFLOW_FOR_SUPPLY_LISTINGS_COMPLETE_STEP_ENABLED, LISTING_TASK_WORKFLOW_FOR_SUPPLY_LISTINGS_REVIEW_STEP_ENABLED, LISTING_TASK_WORKFLOW_FOR_SUPPLY_LISTINGS_REVIEW_STEP_REQUIRE_BOTH_REVIEWS, default */
/***/ (function(module) {

eval("module.exports = {\"NAME\":\"Service Marketplace\",\"SEO_TITLE\":\"Service Marketplace\",\"COLOR_PRIMARY\":\"#000639\",\"COLOR_SECONDARY\":\"#000639\",\"DOMAIN\":\"https://vqmarketplace.com\",\"EMAILS_ENABLED\":\"1\",\"SOCIAL_FB_USERNAME\":\"vqlabs\",\"SOCIAL_TWITTER_USERNAME\":\"vqlabs\",\"SOCIAL_INSTAGRAM_USERNAME\":\"\",\"SOCIAL_YOUTUBE_USERNAME\":\"\",\"SOCIAL_GITHUB_USERNAME\":\"vq-labs\",\"LOGO_URL\":\"/images/vq-logo.png\",\"PROMO_URL\":\"/images/vqbg.jpg\",\"SEO_FAVICON_URL\":\"/favicon.png\",\"PROMO_URL_SELLERS\":\"/images/vqbg.jpg\",\"CUSTOM_CONTACT_PAGE_URL\":\"\",\"CUSTOM_BLOG_PAGE_URL\":\"\",\"LISTING_CUSTOM_CALL_TO_ACTION_MODE\":\"0\",\"PRICING_HOURLY\":\"1\",\"PRICING_CONTRACT\":\"1\",\"PRICING_REQUEST\":\"1\",\"PRICING_DEFAULT_CURRENCY\":\"EUR\",\"LISTING_ENABLE_PUBLIC_VIEW\":\"1\",\"listing_title_mode\":2,\"listing_category_mode\":2,\"LISTING_PUBLIC_VIEW_MODE\":\"2\",\"listing_description_mode\":2,\"listing_location_mode\":2,\"listing_date_mode\":2,\"listing_price_mode\":2,\"listing_images_mode\":0,\"country_restriction\":\"de\",\"DEFAULT_LANG\":\"en\",\"LISTING_RESTRICTED_POSTAL_CODES\":\"\",\"LISTING_GEOFILTER_COUNTRY_RESTRICTION\":\"de\",\"LISTING_GEOFILTER_MODE\":\"cities\",\"GOOGLE_ANALYTICS_ID\":\"\",\"DATE_FORMAT\":\"DD.MM.YYYY\",\"TIME_FORMAT\":\"HH:mm\",\"LISTINGS_VIEW_LIST\":\"1\",\"LISTINGS_VIEW_MAP\":\"1\",\"LISTINGS_DEFAULT_VIEW\":\"2\",\"LANGUAGES\":\"de,fr,it,pl\",\"LISTING_PRICE_FILTER_MAX\":\"100\",\"LISTING_PRICE_FILTER_MIN\":\"10\",\"LISTING_PRICE_FILTER_STEP\":\"5\",\"USER_TYPE_SUPPLY_LISTING_ENABLED\":\"1\",\"USER_TYPE_DEMAND_LISTING_ENABLED\":\"0\",\"USER_TYPE_SUPPLY_DOCUMENT_REQUIRED\":\"0\",\"USER_TYPE_DEMAND_DOCUMENT_REQUIRED\":\"0\",\"USER_ENABLE_SUPPLY_DEMAND_ACCOUNTS\":\"1\",\"USER_ENABLE_PUBLIC_VIEW\":\"1\",\"LISTING_IMAGES_MODE\":\"0\",\"LISTING_GEOLOCATION_MODE\":\"1\",\"LISTING_TIMING_MODE\":\"1\",\"LISTING_TASK_WORKFLOW_ENABLED\":\"1\",\"LISTING_QUANTITY_MODE\":\"0\",\"LISTING_PRICING_MODE\":\"1\",\"LISTING_PRICE_FILTER_ENABLED\":\"1\",\"LISTING_EDIT_ENABLED\":\"1\",\"LISTING_DURATION_MODE\":\"1\",\"LISTING_DISCUSSION_MODE\":\"1\",\"LISTING_DESC_MODE\":\"1\",\"USER_PREFERENCES_ENABLED_FOR_SUPPLY\":\"0\",\"USER_PREFERENCES_ENABLED_FOR_DEMAND\":\"0\",\"USER_DOCUMENTS_ENABLED_FOR_SUPPLY\":\"0\",\"USER_DOCUMENTS_ENABLED_FOR_DEMAND\":\"0\",\"USER_VERIFICATIONS_ENABLED_FOR_SUPPLY\":\"0\",\"USER_VERIFICATIONS_ENABLED_FOR_DEMAND\":\"0\",\"LISTING_TASK_WORKFLOW_FOR_DEMAND_LISTINGS\":\"0\",\"LISTING_TASK_WORKFLOW_FOR_DEMAND_LISTINGS_REQUEST_STEP_ENABLED\":\"0\",\"LISTING_TASK_WORKFLOW_FOR_DEMAND_LISTINGS_REQUEST_STEP_MULTIPLE_REQUESTS_ENABLED\":\"0\",\"LISTING_TASK_WORKFLOW_FOR_DEMAND_LISTINGS_BOOKING_STEP_ENABLED\":\"0\",\"LISTING_TASK_WORKFLOW_FOR_DEMAND_LISTINGS_COMPLETE_STEP_ENABLED\":\"0\",\"LISTING_TASK_WORKFLOW_FOR_DEMAND_LISTINGS_REVIEW_STEP_ENABLED\":\"0\",\"LISTING_TASK_WORKFLOW_FOR_DEMAND_LISTINGS_REVIEW_STEP_REQUIRE_BOTH_REVIEWS\":\"0\",\"LISTING_TASK_WORKFLOW_FOR_SUPPLY_LISTINGS\":\"1\",\"LISTING_TASK_WORKFLOW_FOR_SUPPLY_LISTINGS_REQUEST_STEP_ENABLED\":\"1\",\"LISTING_TASK_WORKFLOW_FOR_SUPPLY_LISTINGS_REQUEST_STEP_MULTIPLE_REQUESTS_ENABLED\":\"0\",\"LISTING_TASK_WORKFLOW_FOR_SUPPLY_LISTINGS_BOOKING_STEP_ENABLED\":\"1\",\"LISTING_TASK_WORKFLOW_FOR_SUPPLY_LISTINGS_COMPLETE_STEP_ENABLED\":\"1\",\"LISTING_TASK_WORKFLOW_FOR_SUPPLY_LISTINGS_REVIEW_STEP_ENABLED\":\"1\",\"LISTING_TASK_WORKFLOW_FOR_SUPPLY_LISTINGS_REVIEW_STEP_REQUIRE_BOTH_REVIEWS\":\"1\"};\n\n//# sourceURL=webpack:///./src/example-configs/offers/config.json?");

/***/ }),

/***/ "./src/example-configs/products/categories.json":
/*!******************************************************!*\
  !*** ./src/example-configs/products/categories.json ***!
  \******************************************************/
/*! exports provided: 0, 1, 2, default */
/***/ (function(module) {

eval("module.exports = [{\"code\":\"diy-electronics\",\"status\":\"0\",\"bigImageUrl\":null,\"imageUrl\":\"https://vqassets-dev.s3.eu-central-1.amazonaws.com/b2btemplate/fbsi2whtl2uamba0f78hkyxcozxj3u2j.jpeg\",\"label\":\"DIY Electronics\",\"minPriceHour\":0,\"desc\":\"Do-It-Yourself Electronics\",\"minQuantity\":1,\"maxQuantity\":50,\"quantityStep\":1,\"unitOfMeasure\":\"Units\",\"createdAt\":\"2017-12-20T23:31:16.000Z\",\"updatedAt\":\"2017-12-20T23:31:16.000Z\"},{\"code\":\"iot-smart-home\",\"status\":\"0\",\"bigImageUrl\":null,\"imageUrl\":\"https://vqassets-dev.s3.eu-central-1.amazonaws.com/b2btemplate/5u311gbvz29pj8dajo3mq0kyqjt5w2td.jpeg\",\"label\":\"IoT & Smart Home\",\"minPriceHour\":0,\"desc\":\"\",\"minQuantity\":1,\"maxQuantity\":50,\"quantityStep\":1,\"unitOfMeasure\":\"Units\",\"createdAt\":\"2017-12-20T23:26:32.000Z\",\"updatedAt\":\"2017-12-21T01:06:10.000Z\"},{\"code\":\"robots-drones\",\"status\":\"0\",\"bigImageUrl\":null,\"imageUrl\":\"https://vqassets-dev.s3.eu-central-1.amazonaws.com/b2btemplate/1r9y56esj19sst3it8zejkj70ozkjrv3.jpeg\",\"label\":\"Robots  & Drones\",\"minPriceHour\":0,\"desc\":\"\",\"minQuantity\":1,\"maxQuantity\":50,\"quantityStep\":1,\"unitOfMeasure\":\"Units\",\"createdAt\":\"2017-12-20T23:29:37.000Z\",\"updatedAt\":\"2017-12-20T23:29:37.000Z\"}];\n\n//# sourceURL=webpack:///./src/example-configs/products/categories.json?");

/***/ }),

/***/ "./src/example-configs/products/config.json":
/*!**************************************************!*\
  !*** ./src/example-configs/products/config.json ***!
  \**************************************************/
/*! exports provided: APP_FOOTER_VISIBLE, COLOR_PRIMARY, COLOR_SECONDARY, COUNTRY_RESTRICTION, CUSTOM_BLOG_PAGE_URL, CUSTOM_CONTACT_PAGE_URL, DATE_FORMAT, DEFAULT_LANG, DEFAULT_PRICING_MODE, DOMAIN, EMAILS_ENABLED, GOOGLE_ANALYTICS_ID, LANDING_PAGE_DEMAND_SECTION_CATEGORIES_ENABLED, LANDING_PAGE_DEMAND_SECTION_HOW_IT_WORKS_ENABLED, LANGUAGES, LISTINGS_DEFAULT_VIEW, LISTINGS_VIEW_GRID, LISTINGS_VIEW_LIST, LISTINGS_VIEW_MAP, LISTING_CATEGORY_MODE, LISTING_DATE_MODE, LISTING_DESCRIPTION_MODE, LISTING_DESC_MODE, LISTING_DISCUSSION_MODE, LISTING_DURATION_MODE, LISTING_EDIT_ENABLED, LISTING_GEOFILTER_COUNTRY_RESTRICTION, LISTING_GEOFILTER_ENABLED, LISTING_GEOFILTER_MODE, LISTING_GEOLOCATION_MODE, LISTING_IMAGES_MODE, LISTING_LOCATION_MODE, LISTING_PRICE_FILTER_ENABLED, LISTING_PRICE_FILTER_MAX, LISTING_PRICE_FILTER_MIN, LISTING_PRICE_FILTER_STEP, LISTING_PRICE_MODE, LISTING_PRICING_MODE, LISTING_QUANTITY_MODE, LISTING_RESTRICTED_POSTAL_CODES, LISTING_TASK_WORKFLOW_ENABLED, LISTING_TIMING_MODE, LISTING_TITLE_MODE, LOGO_URL, MARKETPLACE_PROVISION, NAME, PAYMENTS_ENABLED, PRICING_CONTRACT, PRICING_DEFAULT_CURRENCY, PRICING_HOURLY, PRICING_REQUEST, PROMO_URL, PROMO_URL_MARKETPLACE_BROWSE, PROMO_URL_SELLERS, SEO_DESCRIPTION, SEO_FAVICON_URL, SEO_TITLE, SOCIAL_FB_USERNAME, SOCIAL_GITHUB_USERNAME, SOCIAL_INSTAGRAM_USERNAME, SOCIAL_TWITTER_USERNAME, SOCIAL_YOUTUBE_USERNAME, TIME_FORMAT, USER_ENABLE_SUPPLY_DEMAND_ACCOUNTS, USER_PROFILE_IMAGE_URL, USER_REQUIRE_PHONE_NUMBER, USER_TYPE_DEMAND_DOCUMENT_REQUIRED, USER_TYPE_DEMAND_LISTING_ENABLED, USER_TYPE_SUPPLY_DOCUMENT_REQUIRED, USER_TYPE_SUPPLY_LISTING_ENABLED, default */
/***/ (function(module) {

eval("module.exports = {\"APP_FOOTER_VISIBLE\":\"1\",\"COLOR_PRIMARY\":\"#0693e3\",\"COLOR_SECONDARY\":\"#000639\",\"COUNTRY_RESTRICTION\":\"hu\",\"CUSTOM_BLOG_PAGE_URL\":null,\"CUSTOM_CONTACT_PAGE_URL\":null,\"DATE_FORMAT\":\"DD.MM.YYYY\",\"DEFAULT_LANG\":\"en\",\"DEFAULT_PRICING_MODE\":\"3\",\"DOMAIN\":\"https://b2btemplate.vqmarketplace.com\",\"EMAILS_ENABLED\":\"1\",\"GOOGLE_ANALYTICS_ID\":null,\"LANDING_PAGE_DEMAND_SECTION_CATEGORIES_ENABLED\":\"1\",\"LANDING_PAGE_DEMAND_SECTION_HOW_IT_WORKS_ENABLED\":\"1\",\"LANGUAGES\":\"fr,de,it,pt,es\",\"LISTINGS_DEFAULT_VIEW\":\"1\",\"LISTINGS_VIEW_GRID\":\"1\",\"LISTINGS_VIEW_LIST\":\"0\",\"LISTINGS_VIEW_MAP\":\"1\",\"LISTING_CATEGORY_MODE\":\"2\",\"LISTING_DATE_MODE\":\"2\",\"LISTING_DESCRIPTION_MODE\":\"2\",\"LISTING_DESC_MODE\":\"1\",\"LISTING_DISCUSSION_MODE\":\"0\",\"LISTING_DURATION_MODE\":\"0\",\"LISTING_EDIT_ENABLED\":\"1\",\"LISTING_GEOFILTER_COUNTRY_RESTRICTION\":\"de\",\"LISTING_GEOFILTER_ENABLED\":\"0\",\"LISTING_GEOFILTER_MODE\":\"cities\",\"LISTING_GEOLOCATION_MODE\":\"1\",\"LISTING_IMAGES_MODE\":\"1\",\"LISTING_LOCATION_MODE\":\"2\",\"LISTING_PRICE_FILTER_ENABLED\":\"1\",\"LISTING_PRICE_FILTER_MAX\":\"3000\",\"LISTING_PRICE_FILTER_MIN\":\"50\",\"LISTING_PRICE_FILTER_STEP\":\"10\",\"LISTING_PRICE_MODE\":\"2\",\"LISTING_PRICING_MODE\":\"1\",\"LISTING_QUANTITY_MODE\":\"1\",\"LISTING_RESTRICTED_POSTAL_CODES\":null,\"LISTING_TASK_WORKFLOW_ENABLED\":\"1\",\"LISTING_TIMING_MODE\":\"0\",\"LISTING_TITLE_MODE\":\"2\",\"LOGO_URL\":\"https://vqassets-dev.s3.eu-central-1.amazonaws.com/b2btemplate/j3df9iq8r49te2altj9aqxonnflvo8qi.jpeg\",\"MARKETPLACE_PROVISION\":\"5\",\"NAME\":\"TechieStore\",\"PAYMENTS_ENABLED\":\"0\",\"PRICING_CONTRACT\":\"1\",\"PRICING_DEFAULT_CURRENCY\":\"EUR\",\"PRICING_HOURLY\":\"1\",\"PRICING_REQUEST\":\"1\",\"PROMO_URL\":\"https://vqassets-dev.s3.eu-central-1.amazonaws.com/b2btemplate/z0yrakr3yhdnw0dlth7md69b8jtmod4f.jpeg\",\"PROMO_URL_MARKETPLACE_BROWSE\":null,\"PROMO_URL_SELLERS\":\"https://vqassets-dev.s3.eu-central-1.amazonaws.com/b2btemplate/jufmrm73s6ozpdl15icjq6lb15r6v1vz.jpeg\",\"SEO_DESCRIPTION\":\"Buy awesome things directly from makers and get pioneering hardware picks on the hardware platform for the 21st century\",\"SEO_FAVICON_URL\":\"https://vqassets-dev.s3.eu-central-1.amazonaws.com/b2btemplate/kw7wsn3twpcjheg8kscp3kpipqekwrud.jpeg\",\"SEO_TITLE\":\"TechieStore\",\"SOCIAL_FB_USERNAME\":\"vqlabs\",\"SOCIAL_GITHUB_USERNAME\":\"vq-labs\",\"SOCIAL_INSTAGRAM_USERNAME\":null,\"SOCIAL_TWITTER_USERNAME\":\"vqlabs\",\"SOCIAL_YOUTUBE_USERNAME\":\"\",\"TIME_FORMAT\":\"HH:mm\",\"USER_ENABLE_SUPPLY_DEMAND_ACCOUNTS\":\"0\",\"USER_PROFILE_IMAGE_URL\":\"https://vqassets-dev.s3.eu-central-1.amazonaws.com/bitcoinmeetup/c619n38mc4reip5q86ift0oiiqopd4sc.jpeg\",\"USER_REQUIRE_PHONE_NUMBER\":\"0\",\"USER_TYPE_DEMAND_DOCUMENT_REQUIRED\":\"0\",\"USER_TYPE_DEMAND_LISTING_ENABLED\":\"0\",\"USER_TYPE_SUPPLY_DOCUMENT_REQUIRED\":\"0\",\"USER_TYPE_SUPPLY_LISTING_ENABLED\":\"1\"};\n\n//# sourceURL=webpack:///./src/example-configs/products/config.json?");

/***/ }),

/***/ "./src/example-configs/rentals/categories.json":
/*!*****************************************************!*\
  !*** ./src/example-configs/rentals/categories.json ***!
  \*****************************************************/
/*! exports provided: 0, 1, 2, default */
/***/ (function(module) {

eval("module.exports = [{\"code\":\"entire-kitchen\",\"status\":\"103\",\"bigImageUrl\":null,\"imageUrl\":\"https://egamix.s3.eu-central-1.amazonaws.com/rental-kitchen/m5wacnbuajjxsinzn3g0gt2jy64niw4j.jpeg\",\"label\":\"\",\"minPriceHour\":0,\"desc\":\"\",\"minQuantity\":null,\"maxQuantity\":null,\"quantityStep\":null,\"unitOfMeasure\":null,\"createdAt\":\"2018-01-06T10:05:48.000Z\",\"updatedAt\":\"2018-02-26T13:10:52.000Z\"},{\"code\":\"shared-kitchen\",\"status\":\"0\",\"bigImageUrl\":null,\"imageUrl\":\"https://vqassets-dev.s3.eu-central-1.amazonaws.com/airbnb/a9p2c4q4plzhya775dwe09d60140lmvk.jpeg\",\"label\":\"Entire flat\",\"minPriceHour\":25,\"desc\":\"\",\"minQuantity\":null,\"maxQuantity\":null,\"quantityStep\":null,\"unitOfMeasure\":null,\"createdAt\":\"2018-01-07T11:07:39.000Z\",\"updatedAt\":\"2018-02-25T19:35:39.000Z\"},{\"code\":\"private-kitchen\",\"status\":\"0\",\"bigImageUrl\":null,\"imageUrl\":\"https://vqassets-dev.s3.eu-central-1.amazonaws.com/airbnb/t7ku1juhd7tf65k0kxji3yy0c7nd9ond.jpeg\",\"label\":\"Private room\",\"minPriceHour\":15,\"desc\":\"\",\"minQuantity\":null,\"maxQuantity\":null,\"quantityStep\":null,\"unitOfMeasure\":null,\"createdAt\":\"2018-01-07T11:10:21.000Z\",\"updatedAt\":\"2018-02-25T19:34:21.000Z\"}];\n\n//# sourceURL=webpack:///./src/example-configs/rentals/categories.json?");

/***/ }),

/***/ "./src/example-configs/rentals/config.json":
/*!*************************************************!*\
  !*** ./src/example-configs/rentals/config.json ***!
  \*************************************************/
/*! exports provided: APP_FOOTER_VISIBLE, COLOR_PRIMARY, COLOR_SECONDARY, COMPANY_NAME, COMPANY_NAME_SHORT, COUNTRY_RESTRICTION, CUSTOM_BLOG_PAGE_URL, CUSTOM_CONTACT_PAGE_URL, DATE_FORMAT, DEFAULT_LANG, DEFAULT_PRICING_MODE, DOMAIN, EMAILS_ENABLED, GOOGLE_ANALYTICS_ID, LANDING_PAGE_DEMAND_SECTION_CATEGORIES_ENABLED, LANDING_PAGE_DEMAND_SECTION_HOW_IT_WORKS_ENABLED, LANDING_PAGE_HEADER_BUTTON_TEXT_FOR_SELLERS, LANGUAGES, LISTINGS_DEFAULT_VIEW, LISTINGS_VIEW_GRID, LISTINGS_VIEW_LIST, LISTINGS_VIEW_MAP, LISTING_CATEGORY_MODE, LISTING_DATE_MODE, LISTING_DESCRIPTION_MODE, LISTING_DESC_MODE, LISTING_DISCUSSION_MODE, LISTING_DURATION_MODE, LISTING_EDIT_ENABLED, LISTING_ENABLE_PUBLIC_VIEW, LISTING_GEOFILTER_COUNTRY_RESTRICTION, LISTING_GEOFILTER_ENABLED, LISTING_GEOFILTER_MODE, LISTING_GEOLOCATION_MODE, LISTING_IMAGES_MODE, LISTING_LOCATION_MODE, LISTING_PRICE_FILTER_ENABLED, LISTING_PRICE_FILTER_MAX, LISTING_PRICE_FILTER_MIN, LISTING_PRICE_FILTER_STEP, LISTING_PRICE_MODE, LISTING_PRICING_MODE, LISTING_PUBLIC_VIEW_MODE, LISTING_QUANTITY_MODE, LISTING_RANGE_FILTER_DEFAULT_VALUE, LISTING_RANGE_FILTER_ENABLED, LISTING_RANGE_FILTER_MAX, LISTING_RANGE_FILTER_MIN, LISTING_RANGE_FILTER_STEP, LISTING_RESTRICTED_POSTAL_CODES, LISTING_TASK_WORKFLOW_ENABLED, LISTING_TASK_WORKFLOW_FOR_DEMAND_LISTINGS, LISTING_TASK_WORKFLOW_FOR_DEMAND_LISTINGS_BOOKING_STEP_ENABLED, LISTING_TASK_WORKFLOW_FOR_DEMAND_LISTINGS_COMPLETE_STEP_ENABLED, LISTING_TASK_WORKFLOW_FOR_DEMAND_LISTINGS_REQUEST_STEP_ENABLED, LISTING_TASK_WORKFLOW_FOR_DEMAND_LISTINGS_REQUEST_STEP_MULTIPLE_REQUESTS_ENABLED, LISTING_TASK_WORKFLOW_FOR_DEMAND_LISTINGS_REVIEW_STEP_ENABLED, LISTING_TASK_WORKFLOW_FOR_DEMAND_LISTINGS_REVIEW_STEP_REQUIRE_BOTH_REVIEWS, LISTING_TASK_WORKFLOW_FOR_SUPPLY_LISTINGS, LISTING_TASK_WORKFLOW_FOR_SUPPLY_LISTINGS_BOOKING_STEP_ENABLED, LISTING_TASK_WORKFLOW_FOR_SUPPLY_LISTINGS_COMPLETE_STEP_ENABLED, LISTING_TASK_WORKFLOW_FOR_SUPPLY_LISTINGS_REQUEST_STEP_ENABLED, LISTING_TASK_WORKFLOW_FOR_SUPPLY_LISTINGS_REQUEST_STEP_INSTANT_BOOKING_ENABLED, LISTING_TASK_WORKFLOW_FOR_SUPPLY_LISTINGS_REQUEST_STEP_MULTIPLE_REQUESTS_ENABLED, LISTING_TASK_WORKFLOW_FOR_SUPPLY_LISTINGS_REVIEW_STEP_ENABLED, LISTING_TASK_WORKFLOW_FOR_SUPPLY_LISTINGS_REVIEW_STEP_REQUIRE_BOTH_REVIEWS, LISTING_TIMING_MODE, LISTING_TITLE_MODE, LOGO_URL, MULTIPLE_REQUESTS_ENABLED, NAME, PRICING_CONTRACT, PRICING_DEFAULT_CURRENCY, PRICING_HOURLY, PRICING_REQUEST, PROMO_URL, PROMO_URL_MARKETPLACE_BROWSE, PROMO_URL_SELLERS, SEO_DESCRIPTION, SEO_FAVICON_URL, SEO_IMAGE, SEO_KEYWORDS, SEO_TITLE, SOCIAL_FB_USERNAME, SOCIAL_GITHUB_USERNAME, SOCIAL_INSTAGRAM_USERNAME, SOCIAL_TWITTER_USERNAME, SOCIAL_YOUTUBE_USERNAME, STRIPE_PRIVATE_KEY, STRIPE_PUBLIC_KEY, TIME_FORMAT, USER_DOCUMENTS_ENABLED_FOR_DEMAND, USER_DOCUMENTS_ENABLED_FOR_SUPPLY, USER_ENABLE_PUBLIC_VIEW, USER_ENABLE_SUPPLY_DEMAND_ACCOUNTS, USER_HIDE_DECLINED_REQUESTS_TAB, USER_PREFERENCES_ENABLED_FOR_DEMAND, USER_PREFERENCES_ENABLED_FOR_SUPPLY, USER_PROFILE_IMAGE_URL, USER_REQUIRE_PHONE_NUMBER, USER_TYPE_DEMAND_DOCUMENT_REQUIRED, USER_TYPE_DEMAND_LISTING_ENABLED, USER_TYPE_SUPPLY_DOCUMENT_REQUIRED, USER_TYPE_SUPPLY_LISTING_ENABLED, USER_VERIFICATIONS_ENABLED_FOR_DEMAND, USER_VERIFICATIONS_ENABLED_FOR_SUPPLY, USER_VERIFICATIONS_REQUIRED_FOR_DEMAND, USER_VERIFICATIONS_REQUIRED_FOR_SUPPLY, default */
/***/ (function(module) {

eval("module.exports = {\"APP_FOOTER_VISIBLE\":\"0\",\"COLOR_PRIMARY\":\"#cd5c5c\",\"COLOR_SECONDARY\":\"#000639\",\"COMPANY_NAME\":\"Airhome\",\"COMPANY_NAME_SHORT\":\"\",\"COUNTRY_RESTRICTION\":\"hu\",\"CUSTOM_BLOG_PAGE_URL\":null,\"CUSTOM_CONTACT_PAGE_URL\":null,\"DATE_FORMAT\":\"DD.MM.YYYY\",\"DEFAULT_LANG\":\"en\",\"DEFAULT_PRICING_MODE\":\"1\",\"DOMAIN\":\"https://airhome.vqmarketplace.com\",\"EMAILS_ENABLED\":\"1\",\"GOOGLE_ANALYTICS_ID\":null,\"LANDING_PAGE_DEMAND_SECTION_CATEGORIES_ENABLED\":\"0\",\"LANDING_PAGE_DEMAND_SECTION_HOW_IT_WORKS_ENABLED\":\"0\",\"LANDING_PAGE_HEADER_BUTTON_TEXT_FOR_SELLERS\":\"hosts\",\"LANGUAGES\":\"\",\"LISTINGS_DEFAULT_VIEW\":\"1\",\"LISTINGS_VIEW_GRID\":\"1\",\"LISTINGS_VIEW_LIST\":\"1\",\"LISTINGS_VIEW_MAP\":\"1\",\"LISTING_CATEGORY_MODE\":\"2\",\"LISTING_DATE_MODE\":\"2\",\"LISTING_DESCRIPTION_MODE\":\"2\",\"LISTING_DESC_MODE\":\"1\",\"LISTING_DISCUSSION_MODE\":\"0\",\"LISTING_DURATION_MODE\":\"0\",\"LISTING_EDIT_ENABLED\":\"1\",\"LISTING_ENABLE_PUBLIC_VIEW\":\"1\",\"LISTING_GEOFILTER_COUNTRY_RESTRICTION\":\"de\",\"LISTING_GEOFILTER_ENABLED\":\"1\",\"LISTING_GEOFILTER_MODE\":\"cities\",\"LISTING_GEOLOCATION_MODE\":\"1\",\"LISTING_IMAGES_MODE\":\"1\",\"LISTING_LOCATION_MODE\":\"2\",\"LISTING_PRICE_FILTER_ENABLED\":\"1\",\"LISTING_PRICE_FILTER_MAX\":\"500\",\"LISTING_PRICE_FILTER_MIN\":\"50\",\"LISTING_PRICE_FILTER_STEP\":\"10\",\"LISTING_PRICE_MODE\":\"2\",\"LISTING_PRICING_MODE\":\"1\",\"LISTING_PUBLIC_VIEW_MODE\":\"2\",\"LISTING_QUANTITY_MODE\":\"0\",\"LISTING_RANGE_FILTER_DEFAULT_VALUE\":\"20000\",\"LISTING_RANGE_FILTER_ENABLED\":\"1\",\"LISTING_RANGE_FILTER_MAX\":\"50000\",\"LISTING_RANGE_FILTER_MIN\":\"2000\",\"LISTING_RANGE_FILTER_STEP\":\"100\",\"LISTING_RESTRICTED_POSTAL_CODES\":null,\"LISTING_TASK_WORKFLOW_ENABLED\":\"0\",\"LISTING_TASK_WORKFLOW_FOR_DEMAND_LISTINGS\":\"0\",\"LISTING_TASK_WORKFLOW_FOR_DEMAND_LISTINGS_BOOKING_STEP_ENABLED\":\"1\",\"LISTING_TASK_WORKFLOW_FOR_DEMAND_LISTINGS_COMPLETE_STEP_ENABLED\":\"1\",\"LISTING_TASK_WORKFLOW_FOR_DEMAND_LISTINGS_REQUEST_STEP_ENABLED\":\"1\",\"LISTING_TASK_WORKFLOW_FOR_DEMAND_LISTINGS_REQUEST_STEP_MULTIPLE_REQUESTS_ENABLED\":\"0\",\"LISTING_TASK_WORKFLOW_FOR_DEMAND_LISTINGS_REVIEW_STEP_ENABLED\":\"0\",\"LISTING_TASK_WORKFLOW_FOR_DEMAND_LISTINGS_REVIEW_STEP_REQUIRE_BOTH_REVIEWS\":\"0\",\"LISTING_TASK_WORKFLOW_FOR_SUPPLY_LISTINGS\":\"1\",\"LISTING_TASK_WORKFLOW_FOR_SUPPLY_LISTINGS_BOOKING_STEP_ENABLED\":\"1\",\"LISTING_TASK_WORKFLOW_FOR_SUPPLY_LISTINGS_COMPLETE_STEP_ENABLED\":\"1\",\"LISTING_TASK_WORKFLOW_FOR_SUPPLY_LISTINGS_REQUEST_STEP_ENABLED\":\"1\",\"LISTING_TASK_WORKFLOW_FOR_SUPPLY_LISTINGS_REQUEST_STEP_INSTANT_BOOKING_ENABLED\":\"1\",\"LISTING_TASK_WORKFLOW_FOR_SUPPLY_LISTINGS_REQUEST_STEP_MULTIPLE_REQUESTS_ENABLED\":\"1\",\"LISTING_TASK_WORKFLOW_FOR_SUPPLY_LISTINGS_REVIEW_STEP_ENABLED\":\"1\",\"LISTING_TASK_WORKFLOW_FOR_SUPPLY_LISTINGS_REVIEW_STEP_REQUIRE_BOTH_REVIEWS\":\"0\",\"LISTING_TIMING_MODE\":\"0\",\"LISTING_TITLE_MODE\":\"2\",\"LOGO_URL\":\"https://vqassets-dev.s3.eu-central-1.amazonaws.com/airbnb/ejgvzukatqlos21zjx1wuzj1tavbk251.jpeg\",\"MULTIPLE_REQUESTS_ENABLED\":\"1\",\"NAME\":\"Airhome\",\"PRICING_CONTRACT\":\"1\",\"PRICING_DEFAULT_CURRENCY\":\"EUR\",\"PRICING_HOURLY\":\"1\",\"PRICING_REQUEST\":\"1\",\"PROMO_URL\":\"https://vqassets-dev.s3.eu-central-1.amazonaws.com/airbnb/z0msoann7vh18q5zppc9gjr6hi7pjf83.jpeg\",\"PROMO_URL_MARKETPLACE_BROWSE\":\"https://vqassets-dev.s3.eu-central-1.amazonaws.com/airbnb/ytnqbypxjrp2g0gk87u5kxr43wqpysqw.jpeg\",\"PROMO_URL_SELLERS\":\"https://vqassets-dev.s3.eu-central-1.amazonaws.com/airbnb/upxsul1prptbucfzr9mng6hk9y5yjbfg.jpeg\",\"SEO_DESCRIPTION\":\"Airhome (VQ Marketplace Template) - Example Rental Marketplace by VQ LABS\",\"SEO_FAVICON_URL\":\"https://vqassets-dev.s3.eu-central-1.amazonaws.com/airbnb/dyy1rjwvb73my4tfignp2sz7xz3b3rum.jpeg\",\"SEO_IMAGE\":\"https://vqassets-dev.s3.eu-central-1.amazonaws.com/airbnb/gu4ck7stjmtj96nuenxolf3iqui410vn.jpeg\",\"SEO_KEYWORDS\":\"Rent rooms and flats. \",\"SEO_TITLE\":\"Airhome\",\"SOCIAL_FB_USERNAME\":\"vqlabs\",\"SOCIAL_GITHUB_USERNAME\":\"\",\"SOCIAL_INSTAGRAM_USERNAME\":\"\",\"SOCIAL_TWITTER_USERNAME\":\"vqlabs\",\"SOCIAL_YOUTUBE_USERNAME\":\"\",\"STRIPE_PRIVATE_KEY\":\"XXXXXXXXXXXXXXXXXXXXXXXX\",\"STRIPE_PUBLIC_KEY\":\"\",\"TIME_FORMAT\":\"HH:mm\",\"USER_DOCUMENTS_ENABLED_FOR_DEMAND\":\"0\",\"USER_DOCUMENTS_ENABLED_FOR_SUPPLY\":\"0\",\"USER_ENABLE_PUBLIC_VIEW\":\"0\",\"USER_ENABLE_SUPPLY_DEMAND_ACCOUNTS\":\"0\",\"USER_HIDE_DECLINED_REQUESTS_TAB\":\"1\",\"USER_PREFERENCES_ENABLED_FOR_DEMAND\":\"0\",\"USER_PREFERENCES_ENABLED_FOR_SUPPLY\":\"0\",\"USER_PROFILE_IMAGE_URL\":\"https://vqassets-dev.s3.eu-central-1.amazonaws.com/rental-kitchen/hqqb8n62idt1e9gz2laiaeq1hty5icsw.jpeg\",\"USER_REQUIRE_PHONE_NUMBER\":\"1\",\"USER_TYPE_DEMAND_DOCUMENT_REQUIRED\":\"0\",\"USER_TYPE_DEMAND_LISTING_ENABLED\":\"0\",\"USER_TYPE_SUPPLY_DOCUMENT_REQUIRED\":\"0\",\"USER_TYPE_SUPPLY_LISTING_ENABLED\":\"1\",\"USER_VERIFICATIONS_ENABLED_FOR_DEMAND\":\"0\",\"USER_VERIFICATIONS_ENABLED_FOR_SUPPLY\":\"0\",\"USER_VERIFICATIONS_REQUIRED_FOR_DEMAND\":\"0\",\"USER_VERIFICATIONS_REQUIRED_FOR_SUPPLY\":\"1\"};\n\n//# sourceURL=webpack:///./src/example-configs/rentals/config.json?");

/***/ }),

/***/ "./src/example-configs/services/categories.json":
/*!******************************************************!*\
  !*** ./src/example-configs/services/categories.json ***!
  \******************************************************/
/*! exports provided: 0, 1, 2, 3, default */
/***/ (function(module) {

eval("module.exports = [{\"code\":\"furniture-assembly\",\"status\":\"0\",\"bigImageUrl\":null,\"imageUrl\":\"https://vqassets-dev.s3.eu-central-1.amazonaws.com/vqtemplate-airtasker/4rflr5ejpuuzdgvgamil5mf9evwvqrem.jpeg\",\"label\":\"Furniture Assembly\",\"minPriceHour\":8,\"desc\":\"Get help for your furniture assembly.\",\"minQuantity\":null,\"maxQuantity\":null,\"quantityStep\":null,\"unitOfMeasure\":null,\"createdAt\":\"2018-02-01T18:50:52.000Z\",\"updatedAt\":\"2018-02-13T19:23:26.000Z\"},{\"code\":\"gardening\",\"status\":\"0\",\"bigImageUrl\":null,\"imageUrl\":\"https://vqassets-dev.s3.eu-central-1.amazonaws.com/vqtemplate-airtasker/9gz9ga3fnmnh8iug018cagdaqag0kijk.jpeg\",\"label\":\"Gardening\",\"minPriceHour\":9,\"desc\":\"General garden maintenance.\",\"minQuantity\":null,\"maxQuantity\":null,\"quantityStep\":null,\"unitOfMeasure\":null,\"createdAt\":\"2018-02-01T18:48:42.000Z\",\"updatedAt\":\"2018-02-13T19:23:31.000Z\"},{\"code\":\"households\",\"status\":\"0\",\"bigImageUrl\":null,\"imageUrl\":\"https://vqassets-dev.s3.eu-central-1.amazonaws.com/vqtemplate-airtasker/6ril5denz0la0sti12123j29mbeg1pg8.jpeg\",\"label\":\"Households\",\"minPriceHour\":10,\"desc\":\"Cleaning, ironing and for more help.\",\"minQuantity\":null,\"maxQuantity\":null,\"quantityStep\":null,\"unitOfMeasure\":null,\"createdAt\":\"2018-02-01T18:46:26.000Z\",\"updatedAt\":\"2018-02-13T19:23:09.000Z\"},{\"code\":\"moving\",\"status\":\"0\",\"bigImageUrl\":null,\"imageUrl\":\"https://vqassets-dev.s3.eu-central-1.amazonaws.com/vqtemplate-airtasker/wjp6dnigxb7czke3n1rovt47npz4tcbj.jpeg\",\"label\":\"Moving help\",\"minPriceHour\":8,\"desc\":\"Get help for your moving\",\"minQuantity\":null,\"maxQuantity\":null,\"quantityStep\":null,\"unitOfMeasure\":null,\"createdAt\":\"2018-02-01T18:49:57.000Z\",\"updatedAt\":\"2018-02-13T19:22:47.000Z\"}];\n\n//# sourceURL=webpack:///./src/example-configs/services/categories.json?");

/***/ }),

/***/ "./src/example-configs/services/config.json":
/*!**************************************************!*\
  !*** ./src/example-configs/services/config.json ***!
  \**************************************************/
/*! exports provided: APP_FOOTER_VISIBLE, COLOR_PRIMARY, COLOR_SECONDARY, COMPANY_NAME, COMPANY_NAME_SHORT, COUNTRY_RESTRICTION, CUSTOM_BLOG_PAGE_URL, CUSTOM_FAQ_URL, CUSTOM_HOW_IT_WORKS_URL, DATE_FORMAT, DEFAULT_LANG, DEFAULT_PRICING_MODE, DOMAIN, EMAILS_ENABLED, GOOGLE_ANALYTICS_ID, LANDING_PAGE_DEMAND_SECTION_CATEGORIES_ENABLED, LANDING_PAGE_DEMAND_SECTION_HOW_IT_WORKS_ENABLED, LANDING_PAGE_HEADER_BUTTON_TEXT_FOR_SELLERS, LANGUAGES, LISTINGS_DEFAULT_VIEW, LISTINGS_VIEW_GRID, LISTINGS_VIEW_LIST, LISTINGS_VIEW_MAP, LISTING_CATEGORY_MODE, LISTING_CUSTOM_CALL_TO_ACTION_MODE, LISTING_DATE_MODE, LISTING_DESCRIPTION_MODE, LISTING_DESC_MODE, LISTING_DISCUSSION_MODE, LISTING_DURATION_MODE, LISTING_EDIT_ENABLED, LISTING_ENABLE_PUBLIC_VIEW, LISTING_GEOFILTER_COUNTRY_RESTRICTION, LISTING_GEOFILTER_ENABLED, LISTING_GEOFILTER_MODE, LISTING_GEOLOCATION_MODE, LISTING_IMAGES_MODE, LISTING_LOCATION_MODE, LISTING_PRICE_FILTER_ENABLED, LISTING_PRICE_FILTER_MAX, LISTING_PRICE_FILTER_MIN, LISTING_PRICE_FILTER_STEP, LISTING_PRICE_MODE, LISTING_PRICING_MODE, LISTING_PUBLIC_VIEW_MODE, LISTING_QUANTITY_MODE, LISTING_RESTRICTED_POSTAL_CODES, LISTING_TASK_WORKFLOW_ENABLED, LISTING_TASK_WORKFLOW_FOR_DEMAND_LISTINGS, LISTING_TASK_WORKFLOW_FOR_DEMAND_LISTINGS_BOOKING_STEP_ENABLED, LISTING_TASK_WORKFLOW_FOR_DEMAND_LISTINGS_COMPLETE_STEP_ENABLED, LISTING_TASK_WORKFLOW_FOR_DEMAND_LISTINGS_REQUEST_STEP_ENABLED, LISTING_TASK_WORKFLOW_FOR_DEMAND_LISTINGS_REQUEST_STEP_MULTIPLE_REQUESTS_ENABLED, LISTING_TASK_WORKFLOW_FOR_DEMAND_LISTINGS_REVIEW_STEP_ENABLED, LISTING_TASK_WORKFLOW_FOR_DEMAND_LISTINGS_REVIEW_STEP_REQUIRE_BOTH_REVIEWS, LISTING_TASK_WORKFLOW_FOR_SUPPLY_LISTINGS, LISTING_TASK_WORKFLOW_FOR_SUPPLY_LISTINGS_BOOKING_STEP_ENABLED, LISTING_TASK_WORKFLOW_FOR_SUPPLY_LISTINGS_COMPLETE_STEP_ENABLED, LISTING_TASK_WORKFLOW_FOR_SUPPLY_LISTINGS_REQUEST_STEP_ENABLED, LISTING_TASK_WORKFLOW_FOR_SUPPLY_LISTINGS_REQUEST_STEP_MULTIPLE_REQUESTS_ENABLED, LISTING_TASK_WORKFLOW_FOR_SUPPLY_LISTINGS_REVIEW_STEP_ENABLED, LISTING_TASK_WORKFLOW_FOR_SUPPLY_LISTINGS_REVIEW_STEP_REQUIRE_BOTH_REVIEWS, LISTING_TIMING_MODE, LISTING_TITLE_MODE, LOGO_URL, NAME, PRICING_CONTRACT, PRICING_DEFAULT_CURRENCY, PRICING_HOURLY, PRICING_REQUEST, PROMO_URL, PROMO_URL_MARKETPLACE_BROWSE, PROMO_URL_SELLERS, SEO_DESCRIPTION, SEO_FAVICON_URL, SEO_IMAGE, SEO_KEYWORDS, SEO_TITLE, SOCIAL_FB_USERNAME, SOCIAL_GITHUB_USERNAME, SOCIAL_INSTAGRAM_USERNAME, SOCIAL_TWITTER_USERNAME, SOCIAL_YOUTUBE_USERNAME, STRIPE_PUBLIC_KEY, STRIPE_SECRET_KEY, TIME_FORMAT, USER_DOCUMENTS_ENABLED_FOR_DEMAND, USER_DOCUMENTS_ENABLED_FOR_SUPPLY, USER_ENABLE_PUBLIC_VIEW, USER_ENABLE_SUPPLY_DEMAND_ACCOUNTS, USER_HIDE_DECLINED_REQUESTS_TAB, USER_PREFERENCES_ENABLED_FOR_DEMAND, USER_PREFERENCES_ENABLED_FOR_SUPPLY, USER_REQUIRE_PHONE_NUMBER, USER_TYPE_DEMAND_LISTING_ENABLED, USER_TYPE_SUPPLY_LISTING_ENABLED, USER_VERIFICATIONS_ENABLED_FOR_DEMAND, USER_VERIFICATIONS_ENABLED_FOR_SUPPLY, default */
/***/ (function(module) {

eval("module.exports = {\"APP_FOOTER_VISIBLE\":\"1\",\"COLOR_PRIMARY\":\"#0693e3\",\"COLOR_SECONDARY\":\"#00d084\",\"COMPANY_NAME\":\"Taskbee\",\"COMPANY_NAME_SHORT\":\"\",\"COUNTRY_RESTRICTION\":\"hu\",\"CUSTOM_BLOG_PAGE_URL\":\"https://medium.com/@vqlabs\",\"CUSTOM_FAQ_URL\":\"\",\"CUSTOM_HOW_IT_WORKS_URL\":\"\",\"DATE_FORMAT\":\"DD/MM/YYYY\",\"DEFAULT_LANG\":\"en\",\"DEFAULT_PRICING_MODE\":\"1\",\"DOMAIN\":\"https://taskbee.vqmarketplace.com\",\"EMAILS_ENABLED\":\"1\",\"GOOGLE_ANALYTICS_ID\":\"\",\"LANDING_PAGE_DEMAND_SECTION_CATEGORIES_ENABLED\":\"0\",\"LANDING_PAGE_DEMAND_SECTION_HOW_IT_WORKS_ENABLED\":\"0\",\"LANDING_PAGE_HEADER_BUTTON_TEXT_FOR_SELLERS\":\"taskers\",\"LANGUAGES\":\"\",\"LISTINGS_DEFAULT_VIEW\":\"1\",\"LISTINGS_VIEW_GRID\":\"1\",\"LISTINGS_VIEW_LIST\":\"1\",\"LISTINGS_VIEW_MAP\":\"1\",\"LISTING_CATEGORY_MODE\":\"2\",\"LISTING_CUSTOM_CALL_TO_ACTION_MODE\":\"0\",\"LISTING_DATE_MODE\":\"2\",\"LISTING_DESCRIPTION_MODE\":\"2\",\"LISTING_DESC_MODE\":\"1\",\"LISTING_DISCUSSION_MODE\":\"1\",\"LISTING_DURATION_MODE\":\"1\",\"LISTING_EDIT_ENABLED\":\"1\",\"LISTING_ENABLE_PUBLIC_VIEW\":\"1\",\"LISTING_GEOFILTER_COUNTRY_RESTRICTION\":\"de\",\"LISTING_GEOFILTER_ENABLED\":\"1\",\"LISTING_GEOFILTER_MODE\":\"cities\",\"LISTING_GEOLOCATION_MODE\":\"1\",\"LISTING_IMAGES_MODE\":\"1\",\"LISTING_LOCATION_MODE\":\"2\",\"LISTING_PRICE_FILTER_ENABLED\":\"1\",\"LISTING_PRICE_FILTER_MAX\":\"100\",\"LISTING_PRICE_FILTER_MIN\":\"10\",\"LISTING_PRICE_FILTER_STEP\":\"5\",\"LISTING_PRICE_MODE\":\"2\",\"LISTING_PRICING_MODE\":\"1\",\"LISTING_PUBLIC_VIEW_MODE\":\"1\",\"LISTING_QUANTITY_MODE\":\"0\",\"LISTING_RESTRICTED_POSTAL_CODES\":\"\",\"LISTING_TASK_WORKFLOW_ENABLED\":\"1\",\"LISTING_TASK_WORKFLOW_FOR_DEMAND_LISTINGS\":\"1\",\"LISTING_TASK_WORKFLOW_FOR_DEMAND_LISTINGS_BOOKING_STEP_ENABLED\":\"1\",\"LISTING_TASK_WORKFLOW_FOR_DEMAND_LISTINGS_COMPLETE_STEP_ENABLED\":\"1\",\"LISTING_TASK_WORKFLOW_FOR_DEMAND_LISTINGS_REQUEST_STEP_ENABLED\":\"1\",\"LISTING_TASK_WORKFLOW_FOR_DEMAND_LISTINGS_REQUEST_STEP_MULTIPLE_REQUESTS_ENABLED\":\"0\",\"LISTING_TASK_WORKFLOW_FOR_DEMAND_LISTINGS_REVIEW_STEP_ENABLED\":\"1\",\"LISTING_TASK_WORKFLOW_FOR_DEMAND_LISTINGS_REVIEW_STEP_REQUIRE_BOTH_REVIEWS\":\"1\",\"LISTING_TASK_WORKFLOW_FOR_SUPPLY_LISTINGS\":\"0\",\"LISTING_TASK_WORKFLOW_FOR_SUPPLY_LISTINGS_BOOKING_STEP_ENABLED\":\"0\",\"LISTING_TASK_WORKFLOW_FOR_SUPPLY_LISTINGS_COMPLETE_STEP_ENABLED\":\"0\",\"LISTING_TASK_WORKFLOW_FOR_SUPPLY_LISTINGS_REQUEST_STEP_ENABLED\":\"0\",\"LISTING_TASK_WORKFLOW_FOR_SUPPLY_LISTINGS_REQUEST_STEP_MULTIPLE_REQUESTS_ENABLED\":\"0\",\"LISTING_TASK_WORKFLOW_FOR_SUPPLY_LISTINGS_REVIEW_STEP_ENABLED\":\"0\",\"LISTING_TASK_WORKFLOW_FOR_SUPPLY_LISTINGS_REVIEW_STEP_REQUIRE_BOTH_REVIEWS\":\"0\",\"LISTING_TIMING_MODE\":\"1\",\"LISTING_TITLE_MODE\":\"2\",\"LOGO_URL\":\"https://vqassets-dev.s3.eu-central-1.amazonaws.com/vqtemplate-airtasker/29by90vp210iztey96vwk15sts1pbjqm.jpeg\",\"NAME\":\"Taskbee\",\"PRICING_CONTRACT\":\"0\",\"PRICING_DEFAULT_CURRENCY\":\"EUR\",\"PRICING_HOURLY\":\"1\",\"PRICING_REQUEST\":\"0\",\"PROMO_URL\":\"https://vqassets-dev.s3.eu-central-1.amazonaws.com/taskrabbit/cgjpsbbripxhj3ht8btncddxjz4zmgyw.jpeg\",\"PROMO_URL_MARKETPLACE_BROWSE\":\"https://vqassets-dev.s3.eu-central-1.amazonaws.com/taskrabbit/y8q2qdlrz3d3ow5w9zo851ynafczknoz.jpeg\",\"PROMO_URL_SELLERS\":\"https://vqassets-dev.s3.eu-central-1.amazonaws.com/taskrabbit/ld84ghn28eurdq7m396yo026ywzp8tee.jpeg\",\"SEO_DESCRIPTION\":\"Taskbee (VQ Marketplace Template) - Example Service Marketplace by VQ LABS\",\"SEO_FAVICON_URL\":\"https://vqassets-dev.s3.eu-central-1.amazonaws.com/vqtemplate-airtasker/mbyf4mcbj1h1681ev12n21zkps061lke.jpeg\",\"SEO_IMAGE\":\"https://vqassets-dev.s3.eu-central-1.amazonaws.com/taskrabbit/m3c13d151p5ye566fmairzj8znfehvr9.jpeg\",\"SEO_KEYWORDS\":\"get help nearby\",\"SEO_TITLE\":\"Taskbee\",\"SOCIAL_FB_USERNAME\":\"vqlabs\",\"SOCIAL_GITHUB_USERNAME\":\"\",\"SOCIAL_INSTAGRAM_USERNAME\":\"\",\"SOCIAL_TWITTER_USERNAME\":\"vqlabs\",\"SOCIAL_YOUTUBE_USERNAME\":\"\",\"STRIPE_PUBLIC_KEY\":\"\",\"STRIPE_SECRET_KEY\":\"\",\"TIME_FORMAT\":\"HH:mm\",\"USER_DOCUMENTS_ENABLED_FOR_DEMAND\":\"0\",\"USER_DOCUMENTS_ENABLED_FOR_SUPPLY\":\"0\",\"USER_ENABLE_PUBLIC_VIEW\":\"1\",\"USER_ENABLE_SUPPLY_DEMAND_ACCOUNTS\":\"0\",\"USER_HIDE_DECLINED_REQUESTS_TAB\":\"1\",\"USER_PREFERENCES_ENABLED_FOR_DEMAND\":\"0\",\"USER_PREFERENCES_ENABLED_FOR_SUPPLY\":\"0\",\"USER_REQUIRE_PHONE_NUMBER\":\"1\",\"USER_TYPE_DEMAND_LISTING_ENABLED\":\"1\",\"USER_TYPE_SUPPLY_LISTING_ENABLED\":\"0\",\"USER_VERIFICATIONS_ENABLED_FOR_DEMAND\":\"0\",\"USER_VERIFICATIONS_ENABLED_FOR_SUPPLY\":\"0\"};\n\n//# sourceURL=webpack:///./src/example-configs/services/config.json?");

/***/ }),

/***/ "./src/server.js":
/*!***********************!*\
  !*** ./src/server.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(/*! dotenv */ \"dotenv\").config();\n\nconst async = __webpack_require__(/*! async */ \"async\");\nconst db = __webpack_require__(/*! ./app/models/models */ \"./src/app/models/models.ts\");\nconst tenantService = __webpack_require__(/*! ./app-tenant */ \"./src/app-tenant/index.ts\");\n// const workers = require(\"./app/workers\");\nconst cors = __webpack_require__(/*! cors */ \"cors\");\nconst bodyParser = __webpack_require__(/*! body-parser */ \"body-parser\");\nconst morgan = __webpack_require__(/*! morgan */ \"morgan\");\nconst express = __webpack_require__(/*! express */ \"express\");\nconst app = express();\nconst tenantApp = express();\n\nlet TENANT_ID;\n\nconst setTenantIdForTesting = tenantId => {\n    TENANT_ID = tenantId;\n};\n\nconst startServer = cb => {\n    async.parallel([cb => {\n        const appServer = app.listen(process.env.PORT, () => {\n            const port = appServer.address().port;\n\n            console.log(`VQ-Marketplace API listening at port ${port}. Supporting ${db.getTenantIds().length} tenants.`);\n\n            cb();\n        });\n    }, cb => {\n        const tenantServer = tenantApp.listen(process.env.TENANT_PORT, () => {\n            const port = tenantServer.address().port;\n\n            console.log(`Tenant management API listening at port ${port}.`);\n\n            cb();\n        });\n    }], cb);\n};\n\nconst startServerDeamons = () => {\n    setInterval(() => {\n        Object.keys(db.tenantRegister).filter(tenantId => db.tenantConnections[tenantId]).forEach(tenantId => {\n            const secsPassedSinceNotUsed = Date.now() / 1000 - db.tenantRegister[tenantId].established;\n\n            console.log(`Tenant ${tenantId} not active since ${secsPassedSinceNotUsed}s`);\n\n            // is 15 sec ok?\n            if (secsPassedSinceNotUsed > 15) {\n                console.log(`Closing tenant connection ${tenantId}`);\n\n                db.tenantConnections[tenantId].seq.close();\n\n                delete db.tenantConnections[tenantId];\n            }\n        });\n    }, 1 * 5000);\n\n    if (process.env.SHOW_MEMORY_USAGE) {\n        setInterval(() => {\n            const usedMemory = process.memoryUsage().heapUsed / 1024 / 1024;\n\n            console.log(`[VQ-MARKETPLACE-API] ${Math.round(usedMemory * 100) / 100} MB usage | ${Object.keys(db.tenantConnections).length} tenants`);\n        }, 1 * 60 * 1000);\n    }\n};\n\nconst initTenants = cb => {\n    async.waterfall([cb => {\n        tenantService.getModels((err, tenantModels) => {\n            if (err) {\n                return cb(err);\n            }\n\n            tenantModels.tenant.findAll({\n                where: {\n                    $and: [{ status: 3 }, { emailVerified: true }]\n                }\n            }).then(rTenants => {\n                cb(null, rTenants);\n            }, cb);\n        });\n    }, (tenants, cb) => {\n        async.eachLimit(tenants, 3,\n        // we register it here, they are then lazy loaded when needed.\n        (tenant, cb) => {\n            console.log(`Registering tenant ${tenant.tenantId}`);\n\n            db.refreshTenantRegister(tenant.tenantId);\n\n            // workers.registerWorkers(tenant.tenantId);\n\n            cb();\n            /**\n                 db.create(tenant.dataValues.tenantId, tenant.dataValues.marketplaceType, (err) => {\n                    if (err) {\n                        return cb(err);\n                    }\n                         workers\n                    .registerWorkers(tenant.dataValues.tenantId);\n                         cb(null, tenants);\n                })\n            */\n        }, cb);\n    }], cb);\n};\n\nconst tenantConfigs = {};\n\nconst setupApp = cb => {\n    const initApp = app => {\n        app.set(\"view engine\", \"ejs\");\n        app.set(\"json spaces\", 2);\n        app.set(\"superSecret\", process.env.secret);\n        app.use(cors());\n        app.use(bodyParser.urlencoded({ extended: false }));\n        app.use(bodyParser.json());\n    };\n\n    initApp(app);\n    initApp(tenantApp);\n\n    // app.use(morgan(\"combined\"));\n    tenantApp.use(morgan(\"combined\"));\n\n    app.use((req, res, next) => {\n        req.auth = {\n            token: req.headers[\"x-auth-token\"]\n        };\n\n        let tenantId = TENANT_ID || process.env.TENANT_ID;\n\n        if (!tenantId) {\n            const subdomains = req.subdomains;\n\n            tenantId = subdomains[subdomains.length - 1];\n\n            console.log(`Accessing ${tenantId}`);\n        }\n\n        req.models = db.get(tenantId);\n\n        if (!req.models) {\n            return res.status(400).send({\n                code: \"TENANT_NOT_FOUND\"\n            });\n        }\n\n        if (tenantConfigs[tenantId]) {\n            const timeDiff = Date.now() - tenantConfigs[tenantId].refreshed;\n\n            // everything less than 2 minutes\n            if (timeDiff < 120 * 1000) {\n                req.tenantConfig = tenantConfigs[tenantId].data;\n\n                return next();\n            }\n        }\n\n        req.models.appConfig.findAll().then(configArr => {\n            const configObj = {};\n\n            configArr.forEach(configItem => {\n                configObj[configItem.fieldKey] = configItem.fieldValue;\n            });\n\n            tenantConfigs[tenantId] = {\n                refreshed: Date.now(),\n                data: configObj\n            };\n\n            req.tenantConfig = configObj;\n\n            console.log(req.tenantConfig);\n\n            return next();\n        }, err => {\n            res.status(500).send({\n                code: \"DB_ERROR\",\n                err\n            });\n        });\n    });\n\n    console.log(\"-------------------------------------------------\");\n    const upperCaseENV = process.env.ENV.toUpperCase();\n    console.log(`[${upperCaseENV} MODE] THIS API RUNS IN ${upperCaseENV} MODE..`);\n    console.log(\"-------------------------------------------------\");\n\n    __webpack_require__(/*! ./app/routes.js */ \"./src/app/routes.js\")(app);\n\n    tenantService.initRoutes(tenantApp, express);\n\n    startServerDeamons();\n\n    initTenants(err => {\n        if (err) {\n            if (cb) {\n                cb(err);\n            }\n\n            throw new Error(err);\n        }\n\n        cb = cb || function () {};\n\n        startServer(cb);\n    });\n};\n\nmodule.exports = {\n    initTenants,\n    setupApp,\n    setTenantIdForTesting,\n    startServerDeamons\n};\n\n//# sourceURL=webpack:///./src/server.js?");

/***/ }),

/***/ "./src/shared-providers/stripe.ts":
/*!****************************************!*\
  !*** ./src/shared-providers/stripe.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const stripe = __webpack_require__(/*! stripe */ \"stripe\");\nmodule.exports = {\n    vqStripe: stripe(process.env.STRIPE_SECRET),\n    getTenantStripe: (stripeSecret) => __webpack_require__(/*! stripe */ \"stripe\")(stripeSecret)\n};\n\n\n//# sourceURL=webpack:///./src/shared-providers/stripe.ts?");

/***/ }),

/***/ "async":
/*!************************!*\
  !*** external "async" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"async\");\n\n//# sourceURL=webpack:///external_%22async%22?");

/***/ }),

/***/ "aws-sdk":
/*!**************************!*\
  !*** external "aws-sdk" ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"aws-sdk\");\n\n//# sourceURL=webpack:///external_%22aws-sdk%22?");

/***/ }),

/***/ "bcrypt-nodejs":
/*!********************************!*\
  !*** external "bcrypt-nodejs" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"bcrypt-nodejs\");\n\n//# sourceURL=webpack:///external_%22bcrypt-nodejs%22?");

/***/ }),

/***/ "body-parser":
/*!******************************!*\
  !*** external "body-parser" ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"body-parser\");\n\n//# sourceURL=webpack:///external_%22body-parser%22?");

/***/ }),

/***/ "chargebee":
/*!****************************!*\
  !*** external "chargebee" ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"chargebee\");\n\n//# sourceURL=webpack:///external_%22chargebee%22?");

/***/ }),

/***/ "cors":
/*!***********************!*\
  !*** external "cors" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"cors\");\n\n//# sourceURL=webpack:///external_%22cors%22?");

/***/ }),

/***/ "crypto-js":
/*!****************************!*\
  !*** external "crypto-js" ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"crypto-js\");\n\n//# sourceURL=webpack:///external_%22crypto-js%22?");

/***/ }),

/***/ "dotenv":
/*!*************************!*\
  !*** external "dotenv" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"dotenv\");\n\n//# sourceURL=webpack:///external_%22dotenv%22?");

/***/ }),

/***/ "ejs":
/*!**********************!*\
  !*** external "ejs" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"ejs\");\n\n//# sourceURL=webpack:///external_%22ejs%22?");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"events\");\n\n//# sourceURL=webpack:///external_%22events%22?");

/***/ }),

/***/ "express":
/*!**************************!*\
  !*** external "express" ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"express\");\n\n//# sourceURL=webpack:///external_%22express%22?");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"fs\");\n\n//# sourceURL=webpack:///external_%22fs%22?");

/***/ }),

/***/ "graceful-fs":
/*!******************************!*\
  !*** external "graceful-fs" ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"graceful-fs\");\n\n//# sourceURL=webpack:///external_%22graceful-fs%22?");

/***/ }),

/***/ "jsonwebtoken":
/*!*******************************!*\
  !*** external "jsonwebtoken" ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"jsonwebtoken\");\n\n//# sourceURL=webpack:///external_%22jsonwebtoken%22?");

/***/ }),

/***/ "mandrill-api/mandrill":
/*!****************************************!*\
  !*** external "mandrill-api/mandrill" ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"mandrill-api/mandrill\");\n\n//# sourceURL=webpack:///external_%22mandrill-api/mandrill%22?");

/***/ }),

/***/ "morgan":
/*!*************************!*\
  !*** external "morgan" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"morgan\");\n\n//# sourceURL=webpack:///external_%22morgan%22?");

/***/ }),

/***/ "multer":
/*!*************************!*\
  !*** external "multer" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"multer\");\n\n//# sourceURL=webpack:///external_%22multer%22?");

/***/ }),

/***/ "mysql2":
/*!*************************!*\
  !*** external "mysql2" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"mysql2\");\n\n//# sourceURL=webpack:///external_%22mysql2%22?");

/***/ }),

/***/ "node-geocoder":
/*!********************************!*\
  !*** external "node-geocoder" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"node-geocoder\");\n\n//# sourceURL=webpack:///external_%22node-geocoder%22?");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"path\");\n\n//# sourceURL=webpack:///external_%22path%22?");

/***/ }),

/***/ "rand-token":
/*!*****************************!*\
  !*** external "rand-token" ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"rand-token\");\n\n//# sourceURL=webpack:///external_%22rand-token%22?");

/***/ }),

/***/ "random-token":
/*!*******************************!*\
  !*** external "random-token" ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"random-token\");\n\n//# sourceURL=webpack:///external_%22random-token%22?");

/***/ }),

/***/ "randomstring":
/*!*******************************!*\
  !*** external "randomstring" ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"randomstring\");\n\n//# sourceURL=webpack:///external_%22randomstring%22?");

/***/ }),

/***/ "request":
/*!**************************!*\
  !*** external "request" ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"request\");\n\n//# sourceURL=webpack:///external_%22request%22?");

/***/ }),

/***/ "sequelize":
/*!****************************!*\
  !*** external "sequelize" ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"sequelize\");\n\n//# sourceURL=webpack:///external_%22sequelize%22?");

/***/ }),

/***/ "sharp":
/*!************************!*\
  !*** external "sharp" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"sharp\");\n\n//# sourceURL=webpack:///external_%22sharp%22?");

/***/ }),

/***/ "stripe":
/*!*************************!*\
  !*** external "stripe" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"stripe\");\n\n//# sourceURL=webpack:///external_%22stripe%22?");

/***/ }),

/***/ "underscore":
/*!*****************************!*\
  !*** external "underscore" ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"underscore\");\n\n//# sourceURL=webpack:///external_%22underscore%22?");

/***/ }),

/***/ "unescape":
/*!***************************!*\
  !*** external "unescape" ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"unescape\");\n\n//# sourceURL=webpack:///external_%22unescape%22?");

/***/ })

/******/ });